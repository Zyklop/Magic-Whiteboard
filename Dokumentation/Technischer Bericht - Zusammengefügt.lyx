#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language german-ch
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 0
\use_esint 0
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Stichwortverzeichnis
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Presentation Writer
\end_layout

\begin_layout Standard
TODO: richtiges Abstract
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Einleitung
\end_layout

\begin_layout Standard
Die in dieser Arbeit entworfene Software soll einer Person ermöglichen,
 interaktive Präsentationen in einem kleinen oder mittelgrossen Sitzungszimmer
 zu halten.
 Die Person kann ihren eigenen Laptop dafür verwenden.
 Der Laptop wird am dort vorhandenen Beamer angeschlossen.
 Nach einer kurzen Kalibrierung kann die Person die Präsentation starten.
 Dabei schreibt sie falls gewünscht mit einem virtuellen Stift an die Leinwand.
 Das geschriebene wird aufgezeichnet und wieder auf das Beamerbild projiziert.
\end_layout

\begin_layout Paragraph
Aufbau
\end_layout

\begin_layout Standard
In einem normalen Sitzungszimmer soll ein Vortrag gehalten werden können.
 Dazu sollen Standardausstattung wie Laptop, integrierte Kamera und Beamer
 benutzt werden können.
 Als Addendum wird ein spezieller Stift mitgeliefert.
 Der Stift soll günstig sein.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Aufbau/rendered-perspective.png
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Beispiel eines Aufbaus in der Perspektive
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Kalibrierung
\end_layout

\begin_layout Standard
Bevor ein Stift auf der Leinwand gefunden werden kann, muss die Erkennungssoftwa
re kalibriert werden.
 Dazu müssen folgende Schritte vorgenommen werden:
\end_layout

\begin_layout Itemize
Laptopkamera so ausrichten, dass der ganze Bereich der Leinwand gefilmt
 werden kann
\end_layout

\begin_layout Itemize
Lichtverhältnisse anpassen falls nötig
\end_layout

\begin_layout Itemize
Projiziertes Bild erkennen und ein Mapping von Kamerakoordinaten zu Bildschirmko
ordinaten berechnen
\end_layout

\begin_layout Paragraph
Präsentation
\end_layout

\begin_layout Standard
Die Person soll mit einem Stift auf die das Beamerbild schreiben können.
 Sie benutzt dazu ein helles Licht.
 Die Person muss darauf achten, dass der Stift für die Kamera sichtbar ist.
 Das erfordert Disziplin.
 Deshalb gilt abzuklären, ob und wie das Präsentationssystem akzeptiert
 wird.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Problemstellung
\end_layout

\begin_layout Standard
Sowohl bei der verwendeten Hardware als auch bei der Art und Weise wie die
 Software benutzt werden kann, gibt es Einschränkungen.
 Obwohl das erarbeitete Präsentationssystem zum Ziel hat, einschneidende
 Beschränkungen zu vermeiden, gibt es doch verschiedene Grenzen, die von
 Anfang an definiert sind und als nicht überwindbar gelten.
 Grundsätzlich sind sie physischer und physikalischer Art.
\end_layout

\begin_layout Subsubsection
Aufnahmegerät
\end_layout

\begin_layout Standard
Das in dieser Arbeit verwendete Aufnahmegerät ist eine integrierte Laptopkamera
 eines Thinkpad T420s mit einer Auflösung von 640x480 Pixel à 30 Bilder
 pro Sekunde.
 Sie übertreibt es völlig mit dem automatischen Weissabgleich, hat aber
 einen in den Treiber integrierten Konfigurationsdialog, mit welchem sich
 das Problem manuell minimieren lässt.
 Allgemein formuliert ist an der verwendeten Kamera die Bildauflösung weniger
 wichtig als eine korrekte Belichtung.
 Das liegt daran, dass die präsentierende Person immer in Bewegung ist,
 mal mehr beleuchtet, mal weniger, und somit ein irritierendes Ungleichgewicht
 für die Kamera schafft.
 Übertriebene Änderungen der Beleuchtung seitens der Kamera übertönen den
 Stift.
 Folglich ist er nicht mehr der hellste Punkte der Aufnahme und wird nicht
 mehr erkannt, bzw.
 gefunden.
\end_layout

\begin_layout Paragraph
Beispiel:
\end_layout

\begin_layout Standard
Abbildung 2 zeigt eine Beamerprojektion einer weissen Fläche.
 Der Raum ist wenig abgedunkelt, damit die Kamera welche die Aufnahme gemacht
 hat, einen weniger starken automatischen Weissabgleich vornimmt.
 Nichtsdestotrotz beträgt die Anzahl völlig weisser Pixel in diesem Bild
 mehr als 11'000.
 Das macht es unmöglich, optisch einen hellen Punkt (Stift) zu finden.
 Eine stärker abgedunkelte Umgebung erhöht den Kontrast und somit auch das
 Problem.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Camera/whitebalance.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Überbeleuchtetes Kamerabild
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Fazit:
\end_layout

\begin_layout Standard
Der automatische Weissabgleich kann über den Hardwaretreiber abgestellt
 werden, erfordert aber einiges an Arbeit (bei Windows schwierig, bei Linux
 einfacher).
 Die verwendeten Geräte müssten genau bekannt sein, um ihre Treiber konfiguriere
n zu können.
 Wahrscheinlich stellt dieser Aufwand ein Hindernis dar, welches man eher
 durch Mitliefern einer eigenen Infrarot-Kamera lösen würde.
 Das hätte den Vorteil, dass sowohl Präsentator als auch Zuschauer nicht
 von sichtbarem Licht abgelenkt würden.
 In dieser Arbeit wird der Einfachheit halber lediglich auf das Finden einer
 von Menschen sichtbaren Lichtquelle eingegangen.
 Es wird angenommen, dass sich alle Konzepte auf nicht sichtbares Licht
 übertragen lassen.
\end_layout

\begin_layout Subsubsection
Präsentationsgerät
\end_layout

\begin_layout Standard
Ein weniger wichtige Rolle als die Kamera spielt der Beamer.
 Weder die Auflösung, noch die Bildwiederholrate spielen eine nennenswerte
 Rolle auf die Qualität des Präsentationssystem.
 Die Helligkeitseinstellung ist jedoch wichtig.
 Der in dieser Arbeit verwendete Beamer beleuchtet die Leinwand sehr stark
 und verstärkt dadurch das Problem des automatischen Weissabgleiches der
 Kamera.
 Zur Minimierung des Problems wurde die Helligkeit auf ein schwächeres Niveau
 reduziert.
 Es wurde darauf geachtet, dass die Einstellung als 
\begin_inset Quotes gld
\end_inset

üblich für eine Präsentation
\begin_inset Quotes grd
\end_inset

 wahrgenommen wird.
\end_layout

\begin_layout Subsubsection
Positionierung
\end_layout

\begin_layout Standard
Der Laptop wird so aufgestellt, dass das Sichtfeld der integrierten Kamera
 den Projektionsbereich auf der Leinwand voll umfasst.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Aufbau/wireframe-top.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Beispiel eines Aufbaus von oben
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der Winkel zwischen Projektionsfläche und Laptopkamera hat Auswirkungen
 auf die Genauigkeit des Präsentationssystems.
 Je grösser der Winkel zwischen Kamera und Projektionsfläche ist, desto
 stärker verzerrt nimmt die Kamera das projizierte Bild wahr.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Aufbau/aufbau-verzerrung.png
	lyxscale 50
	width 100col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Leinwand mit drei verschiedenen Verzerrungen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
So sieht die Kamera die Leinwand aus drei verschiedenen Winkeln.
 Die Kalibrierung kann die perspektivische Verzerrung nur begrenzt ausgleichen.
 Deshalb kann die Position eines Stiftes nicht immer gut oder in allen Bereichen
 der Leinwand gleich gut erfolgen.
\end_layout

\begin_layout Itemize
Links sieht man den üblichen Fall: Beamerbild und Laptopkamera liegen auf
 zwei parallelen Ebenen.
 
\end_layout

\begin_layout Itemize
In der Mitte ist der Optimalfall dargestellt: Die Kamera sieht direkt von
 vorne auf das Beamerbild, d.h.
 die perspektivische Verzerrung ist minimal
\end_layout

\begin_layout Itemize
Rechts ist das Bild in alle Richtungen verzerrt und stellt somit die grössten
 Anforderungen an die Kalibrierung.
\end_layout

\begin_layout Standard
Zur Vereinfachung des zu lösenden Problems wird im Folgenden jeweils angenommen,
 dass die perspektivische Verzerrung lediglich auf der Horizontalen (X-Achse)
 der aufgenommenen Bilder verläuft.
 Messungen zur Genauigkeit unseres verwendeten Abbildungsverfahrens (s.u.)
 zeigen, dass die Verzerrung auf der Vertikalen (Y-Achse) vernachlässigt
 werden kann.
\end_layout

\begin_layout Subsubsection
Leinwand
\end_layout

\begin_layout Standard
Es ergeben sich Beschränkungen aus dem Untergrund, auf welchen präsentiert
 wird.
 Unebene oder glänzende Texturen sind ungeeignete Präsentationsflächen,
 da sowohl Kalibrierung als auch Stifterkennung darunter leiden können.
 Grosse Probleme können Reflexionen der Beamerlampe auf der Leinwand verursachen.
 Dies kann passieren, wenn Beamer und Laptop in einem ungünstigen Winkel
 zueinander stehen.
\end_layout

\begin_layout Subsubsection
Laptop
\end_layout

\begin_layout Standard
Bildverarbeitung braucht in der Regel viel Rechenleistung.
 Die in dieser Arbeit entwickelte Software berücksichtigt dies, indem zum
 Teil Kompromisse eingegangen werden um den Leistungsanforderungen gerecht
 zu werden.
 Um eine reibungslose Erkennung zu gewährleisten, sollten 2GHz Doppelkernprozess
oren oder ähnlich verwendet werden.
\end_layout

\begin_layout Subsubsection
Präsentationsweise
\end_layout

\begin_layout Standard
Da der Stift immer von der Laptopkamera gesehen werden muss, ist es am Präsentat
or, die richtige Haltung beim Schreiben anzunehmen.
 Eine gute Art zu präsentieren ist, wenn das Publikum sieht, wo der Präsentator
 hinzeigt.
 Dies hat den Vorteil hat, dass auch die Laptopkamera sieht, wo auf die
 Leinwand geschrieben werden soll.
 Falls sich der Präsentator zwischen Kamera und Leinwand stellt, kann nicht
 mehr geschrieben werden.
 Da in diesem Fall meist auch das Publikum nichts mehr sieht, wird diese
 Einschränkung ohne weiteren Diskurs in Kauf genommen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Setup/IMGP0366.JPG
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Gute Präsentationsweise - Die zeigende Hand ist von Laptopkamera (links)
 und Publikum aus (rechts) sichtbar.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Ergebnis
\end_layout

\begin_layout Standard
Das Resultat erstaunt.
 Die in dieser Arbeit entwickelte Software 
\begin_inset Quotes gld
\end_inset

Presentation Writer
\begin_inset Quotes grd
\end_inset

 kann gewinnbringend für Vorträge eingesetzt werden.
 Die tiefe Auflösung der Kamera von 640x480 Pixel und die schlechten Lichteigens
chaften haben wenig Einfluss auf die Güte des Resultates.
 Eine erfolgreiche Kalibrierung der Kamera, gute Einstellungen der Bildfilter
 und genügend gute Abbildungsalgorithmen mit Interpolation machen dies möglich.
 Optimierungen wie eine hochauflösendere Kamera würden noch genauere und
 bessere Resultate liefern.
 Aus Zeitgründen wurde in der Software zum Teil auf Optimierungen verzichtet.
 Jene die erschlossen wurden, sind jedoch in der schriftlichen Arbeit jeweils
 kurz erwähnt.
\end_layout

\begin_layout Standard
Im Folgenden dieser Arbeit wird genauer darauf eingegangen, wie alle diese
 Zwischenschritte vom Kamerabild bis zum gezeichneten Bildpunkt auf dem
 Beamer analysiert und gelöst wurden.
 Zum einen werden Ideen zum Finden eines Stiftes in einem Kamerabild diskutiert,
 zum anderen werden verschiedene Ansätze erarbeitet, die eine näherungsweise
 korrekte Abbildung von Kamera- zu Beamerpunkten ermöglichen.
 Im Anhang werden erweiterte oder fehlgeschlagene Ideen genauer erläutert.
 Zudem wird dort auch die Vision vom virtuellen Touchpanel ausgearbeitet,
 eine Idee, die eventuell auch mit einer optischen Kamera, aber ohne Stift
 lösbar ist.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Setup/writing.jpg
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Presentation Writer - Unterstützung bei Vorträgen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Setup/classic-painting.jpg
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Kleines Gekritzel macht Spass - Trotz der tiefen Auflösung von 640x480 Pixel
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Analyse
\end_layout

\begin_layout Standard
Im Folgenden werden Überlegungen zur Beziehung Beamer-Kamera und zu den
 konkreten Eigenschaften eines Stiftes gemacht.
 Es gilt zu analysieren, wie und ob die oben postulierten Probleme gelöst
 werden können.
 Es wird auf Kamerakalibrierung und Bildverarbeitungsschritte eingegangen.
 Dazu werden eigene Algorithmen beschrieben und analysiert.
\end_layout

\begin_layout Subsection
Erkennen von Vierecken
\end_layout

\begin_layout Subsubsection
Eckpunkte erkennen
\end_layout

\begin_layout Standard
Es werden lediglich die Bildschirmecken erkannt.
\end_layout

\begin_layout Paragraph
Vorteile
\end_layout

\begin_layout Itemize
Zuverlässigkeit
\end_layout

\begin_layout Itemize
Fehlerkennungen können einfach detektiert werden
\end_layout

\begin_layout Paragraph
Nachteile
\end_layout

\begin_layout Itemize
Nur vier nutzbare Punkte
\end_layout

\begin_layout Paragraph
Fazit
\end_layout

\begin_layout Standard
Für die meisten Interpolationsansätze reicht das schon.
 Wir haben schon damit sehr gute Ergebnisse erzielt.
\end_layout

\begin_layout Paragraph
Rekursives traversieren von Vierecken
\end_layout

\begin_layout Standard
Rechtecke werden mit einem rekursiven Algorithmus erkannt.
\end_layout

\begin_layout Subparagraph
Vorteile
\end_layout

\begin_layout Itemize
Stabile Erkennung
\end_layout

\begin_layout Itemize
Verbesserungsmöglichkeiten
\end_layout

\begin_layout Subparagraph
Nachteile
\end_layout

\begin_layout Itemize
Gravierende Fehlerkennungen
\end_layout

\begin_layout Itemize
Probleme mit nicht erkannten Blobs
\end_layout

\begin_layout Itemize
Fehlerdetektion ist nist absolut möglich, höchstens Fehlerwahrscheinlichkeiten
 abschätzen.
\end_layout

\begin_layout Itemize
Verbesserungen verursachen hohe Code-Komplexität
\end_layout

\begin_layout Subparagraph
Fazit
\end_layout

\begin_layout Standard
Dieser Algorithmus lässt sich unendlich verbessern, wird aber niemals korrekt
 funktionieren.
 Für ein Mapping sind wir aber auf 100% Korrektheit.
\end_layout

\begin_layout Paragraph
Nutzung der Interpolation
\end_layout

\begin_layout Standard
Zuordning aufgrund der Interpolation anzand der Eckpunkten.
\end_layout

\begin_layout Subparagraph
Vorteile
\end_layout

\begin_layout Itemize
Einfaches Verfahren
\end_layout

\begin_layout Itemize
Die meisten Fehler können korrigiert werden
\end_layout

\begin_layout Itemize
Sehr performant.
\end_layout

\begin_layout Subparagraph
Nachteile
\end_layout

\begin_layout Itemize
Gravierende Fehlerkennungen
\end_layout

\begin_layout Itemize
Abhängig von einer guten Interpolation.
\end_layout

\begin_layout Subparagraph
Fazit
\end_layout

\begin_layout Standard
Mit einem guten Interpolationsverfahren wird das nicht mehr benötigt.
 Es könnte sich allenfalls lohnen, diese Verfahren später nochmals anzusehen.
\end_layout

\begin_layout Paragraph
K-Means Clustering
\end_layout

\begin_layout Standard
Inkrementeller Clustering-Algorithmus
\end_layout

\begin_layout Subparagraph
Vorteile
\end_layout

\begin_layout Itemize
Fehler sind detektierbar
\end_layout

\begin_layout Subparagraph
Nachteile
\end_layout

\begin_layout Itemize
Iterationstiefe abhängig von der Rechteckgrösse
\end_layout

\begin_layout Itemize
Stellt hohe Anforderungen an Blobdetektion
\end_layout

\begin_layout Subparagraph
Fazit
\end_layout

\begin_layout Standard
Dieser Algorithmus ist sehr stabil und 100% korrekt.
 Im Fehlerfall kann er jedoch nie abschliessen.
 Mit Verbesserungen könnte jedoch auch dieser Algorithmus sinnvoll eingesetzt
 werden.
\end_layout

\begin_layout Subsection
Kalibrierung
\end_layout

\begin_layout Standard
Bei der Kalibrierung geht es darum, Punkte im Kamerabild zu erkennen, die
 eindeutigen Punkten auf der Präsentation zugeordnet werden können.
 Dabei müssen sicher die Eckpunkte der Präsentation erkannt werden.
 Durch erkennung weiterer Punkte kann allerdings die Genauigkeit des Mappings
 erhöht werden.
 Hierbei haben wir verschiedene Ansätze ausprobiert.
 Hier wird nur die Analyse beschrieben, das genaue Vorgehen ist jeweils
 im Anhang beschrieben.
\end_layout

\begin_layout Subsubsection
Referenzpunkte
\end_layout

\begin_layout Standard
Die Abbildung vom Kamerabild zum ursprünglich projizierten Beamerbild ist
 eine Transformation 
\begin_inset Formula $\left(x_{k},y_{k}\right)\rightarrow\left(x_{b},y_{b}\right)$
\end_inset

 und lässt sich durch eine Transformationsmatrix mit 11 Freiheitsgraden
 korrekt beschreiben
\begin_inset Foot
status open

\begin_layout Plain Layout
3 Translation, 3 Rotation, 2 Kameranullpunkt, 1 Brennweite, 2 Bildskalierung
 
\end_layout

\end_inset

.
 Falls die Brennweite ausser Acht gelassen und mit einer bekannten Bildskalierun
g gearbeitet wird, hat die Transformation lediglich 8 Freiheitsgrade, welche
 durch 4 Messpunkte gebunden werden können.
 Unsere Implementationen der Abbildungsberechnungen verlassen sich jeweils
 auf die vier gemessenen Eckpunkte der Projektion und lassen somit Linseneffekte
 ausser Acht.
 Messungen haben ergeben, dass auftretende Ungenauigkeiten regelmässig sind
 und sich grösstenteils auf die horizontale Achse beschränken.
 Durch eine einfache Korrekturfunktion lassen sich sichtbare Effekte vermeiden.
 4 Referenzpunkte reichen also für das zu entwickelnde Präsentationssystem.
\end_layout

\begin_layout Paragraph
Eckdetektion per Differenzbild
\end_layout

\begin_layout Standard
TODO: genau beschreiben was wieso gemacht wird
\end_layout

\begin_layout Standard
Ergebnisse sind brauchbar aber nicht sicher.
 Fehlerkennungen kommen gelegentlich vor.
\end_layout

\begin_layout Subparagraph
Vorteile
\end_layout

\begin_layout Itemize
Ecken des Bildschirms wurden ungefähr erkannt, die meisten der dargestellten
 Rechtecken auch.
 
\end_layout

\begin_layout Subparagraph
Nachteile
\end_layout

\begin_layout Itemize
Ich habe nur wenig Verbesserungspotenzial bei dieser Lösung gesehen, und
 dieses wäre teuer zu erkaufen gewesen.
 
\end_layout

\begin_layout Itemize
Da grosse Teile des Bildschirms umgefärbt wurden, gab es Probleme mit der
 Belichtungskorrektur.
 
\end_layout

\begin_layout Itemize
Zufällig verteilte Punkte sind für ein Mapping nicht gut brauchbar.
\end_layout

\begin_layout Itemize
Die Farbkanäle waren schwierig sauber zu trennen und haben häufig Probleme
 verursacht.
 Überschneidungen waren sehr Problematisch.
 
\end_layout

\begin_layout Subparagraph
Fazit
\end_layout

\begin_layout Standard
Dieses Verfahren birgt zu viele Risiken und Aufgrund des kleinen Verbesserungspo
tenzials lohnt es sich nicht, diesen Ansatz weiterzuverfolgen.
\end_layout

\begin_layout Paragraph
Einfacher Differenzbildansatz
\end_layout

\begin_layout Standard
TODO: genau beschreiben was wieso gemacht wird
\end_layout

\begin_layout Standard
Es wird ein universeller Differenzbild-hintergrund verwendet.
 Damit werden alle Bilder so dargestellt, wie sie sein sollten.
\end_layout

\begin_layout Subparagraph
Vorteile
\end_layout

\begin_layout Itemize
Es müssen weiger Bilder dargestellt werden.
\end_layout

\begin_layout Itemize
Statische Störungen (Umgebung werden herausgefiltert.
\end_layout

\begin_layout Subparagraph
Nachteile
\end_layout

\begin_layout Itemize
Gleichmässige Lichtverhältnisse sind unmöglich einzuhalten.
\end_layout

\begin_layout Itemize
Belichtungskorrektur kann grosse Probleme bereiten
\end_layout

\begin_layout Itemize
Rauschen nimmt mit der Zeit zu
\end_layout

\begin_layout Subparagraph
Fazit
\end_layout

\begin_layout Standard
Solange wir keinen Zugriff auf die Konfiguration der Kamera haben, funktioniert
 dieses Verfahren nicht.
\end_layout

\begin_layout Paragraph
Histogramm-Analyse
\end_layout

\begin_layout Standard
TODO: genau beschreiben was wieso gemacht wird
\end_layout

\begin_layout Standard
Hierbei wird direkt mit Kamerabildern gearbeitet.
 Die Bilder werden nach Helligkeitsverteilung analysiert.
\end_layout

\begin_layout Subparagraph
Vorteile
\end_layout

\begin_layout Itemize
Es müssen keine zusätzlichen Bilder dargestellt werden.
\end_layout

\begin_layout Subparagraph
Nachteile
\end_layout

\begin_layout Itemize
Die Farbverteilung ist in verschiedenen Bildregionen unterschiedlich.
\end_layout

\begin_layout Itemize
Starkes Rauschen
\end_layout

\begin_layout Itemize
Ungenaue Erkennung
\end_layout

\begin_layout Subparagraph
Fazit
\end_layout

\begin_layout Standard
Es werden höchstens Teile des Bildes richtig erkannt.
 Unbrauchbar für uns.
\end_layout

\begin_layout Paragraph
Histogramm-Analyse auf Bildausschnitten
\end_layout

\begin_layout Standard
TODO: genau beschreiben was wieso gemacht wird
\end_layout

\begin_layout Standard
Auch hierbei wird direkt mit Kamerabildern gearbeitet.
 Die Bilder werden aufgeteilt, nach Helligkeitsverteilung analysiert und
 wieder zusammengesetzt.
\end_layout

\begin_layout Subparagraph
Vorteile
\end_layout

\begin_layout Itemize
Es müssen keine zusätzlichen Bilder dargestellt werden.
\end_layout

\begin_layout Itemize
Regionen mit unterschiedlichen Lichtverhältnissen werden gut korrigiert.
\end_layout

\begin_layout Itemize
Zu erkennende Objekte werden erkannt
\end_layout

\begin_layout Subparagraph
Nachteile
\end_layout

\begin_layout Itemize
Noch stärkeres Rauschen
\end_layout

\begin_layout Itemize
Unscharfe Kanten
\end_layout

\begin_layout Itemize
Viele Fehlerkennungen
\end_layout

\begin_layout Itemize
Unscharfe Übergänge
\end_layout

\begin_layout Subparagraph
Fazit
\end_layout

\begin_layout Standard
Dieses Verfahren funktioniert erkennt meist alle gesuchten Blobs.
 Deren Erkennung ist aber nicht gut und die Kanten sind unscharf.
 Das führt zu unkorrekten Werten.
 Zudem müssen viele Fehlerkennungen herausgefiltert werden.
 Brauchbar aber nicht optimal.
\end_layout

\begin_layout Paragraph
Schachbrett-Muster
\end_layout

\begin_layout Standard
Es werden nur Bilder projiziert, die eine identische Helligkeitsverteilung
 aufweisen.
\end_layout

\begin_layout Subparagraph
Vorteile
\end_layout

\begin_layout Itemize
Die Belichtungskorrektur der Kamera macht keine Probleme mehr
\end_layout

\begin_layout Itemize
Fast kein Rauschen vorhanden
\end_layout

\begin_layout Subparagraph
Nachteile
\end_layout

\begin_layout Itemize
Es müssen doppelt so viele Bilder projiziert werden, wie genutzt werden
 können
\end_layout

\begin_layout Itemize
Aufwändige Bildkonstruktion
\end_layout

\begin_layout Subparagraph
Fazit
\end_layout

\begin_layout Standard
Aufgrund der hohen stabilität verwenden wir dieses Verfahren.
 Wir sind zudem nicht so stark auf Performance angewisesen.
\end_layout

\begin_layout Paragraph
Bestehende Bibliotheken
\end_layout

\begin_layout Standard
Es gibt die Möglichkeit, eine Kamerakalibration mit vollständiger Transformation
smatrix (11 Freiheitsgrade) mit OpenCV vollautomatisch vornehmen zu lassen.
 Diese Funktionalität konnte mit OpenCV nicht erfolgreich getestet werden.
 Aufgrund dessen wurde schliesslich vollständig auf OpenCV verzichtet.
\end_layout

\begin_layout Subsubsection
Abbildung & Interpolation
\end_layout

\begin_layout Standard
Es wurden verschiedene Verfahren zur Beschreibung der Abbildungen erarbeitet.
\end_layout

\begin_layout Standard
blablablabla
\end_layout

\begin_layout Standard
blabla
\end_layout

\begin_layout Paragraph
Linear
\end_layout

\begin_layout Standard
Dieser Ansatz berücksichtigt keine Perspektivische Verzerrung.
\end_layout

\begin_layout Subparagraph
Vorteile
\end_layout

\begin_layout Itemize
Berechnung ist relativ schnell
\end_layout

\begin_layout Itemize
Keine Knicke
\end_layout

\begin_layout Itemize
Eckpunkte reichen
\end_layout

\begin_layout Subparagraph
Nachteile
\end_layout

\begin_layout Itemize
Vorberechnung nötig
\end_layout

\begin_layout Itemize
Starke Abweichungen aufgrund der perspektifischen Verzerrung
\end_layout

\begin_layout Subparagraph
Fazit
\end_layout

\begin_layout Standard
Dieser Ansatzt war gut für einen schnellen Test.
 Wenn keine Perspektivische Verzerrung vorhanden ist, funktioniert er relativ
 gut.
 Das ist jedoch nicht Realtitätsnah.
\end_layout

\begin_layout Paragraph
Baryzentrische Koordinaten
\end_layout

\begin_layout Standard
Normale Baryzentrische Koordinaten in Dreiecken
\end_layout

\begin_layout Subparagraph*
Vorteile
\end_layout

\begin_layout Itemize
Erhöhte Genauigkeit mit mehr Refernzpunkten
\end_layout

\begin_layout Itemize
Relativ einfacher Algorithmus
\end_layout

\begin_layout Subparagraph
Nachteile
\end_layout

\begin_layout Itemize
Gewisse Ungenauigkeiten
\end_layout

\begin_layout Itemize
Hoher Rechenaufwand
\end_layout

\begin_layout Itemize
Gewichtung ist nur schwer realisierbar
\end_layout

\begin_layout Subparagraph
Fazit
\end_layout

\begin_layout Standard
Dieses Verfahren funktioniert zwar, hat jedoch zu wenig Verbesserungspotenzial
 und ist abhängig von einer sehr stabilen Konfiguration.
\end_layout

\begin_layout Paragraph
Baryzentrische Vierecke mit Korrenkturfaktor
\end_layout

\begin_layout Standard
Dieses Verfahren berücksichtigt zusätzlich noch den Faktor, dass die Rechtecke
 weder Winkel- noch Flächentreu sind, wovon die Barizentrischen Dreiecke
 ausgehen aber bei uns nicht der Fall ist.
\end_layout

\begin_layout Subparagraph
Vorteile
\end_layout

\begin_layout Itemize
Genauere Interpolation
\end_layout

\begin_layout Itemize
Gewichtung ist möglich
\end_layout

\begin_layout Subparagraph
Nachteile
\end_layout

\begin_layout Itemize
Setzt eine Ordnung der Referenzpunkte voraus
\end_layout

\begin_layout Itemize
Komplizierterer Algorithmus
\end_layout

\begin_layout Subparagraph
Fazit
\end_layout

\begin_layout Standard
Dieser Algorithmus sollte relativ gut funktionieren, wenn man entsprechende
 Referenzpunkte hat.
 Er kann Knicke komplett eliminieren.
\end_layout

\begin_layout Paragraph
Homogene Tranmsformation
\end_layout

\begin_layout Standard
Hierbei verwenden wir den Algorithmus der Homogenen Transformation.
\end_layout

\begin_layout Subparagraph
Vorteile
\end_layout

\begin_layout Itemize
Berücksichtigt die perspektivische Verzerrung bis zu einem gewissen Grad
\end_layout

\begin_layout Itemize
Schnelle Berechnung
\end_layout

\begin_layout Itemize
Funktioniert mit vier Punkten
\end_layout

\begin_layout Subparagraph
Nachteile
\end_layout

\begin_layout Itemize
Kompliziert um eigen Anpassungen anzubringen
\end_layout

\begin_layout Subparagraph
Fazit
\end_layout

\begin_layout Standard
Dieser Algorithmus funktioniert etwas besser als der lineare Ansatz, ist
 aber weniger genau als der Integral-Ansatz
\end_layout

\begin_layout Subsubsection
Optimierungen
\end_layout

\begin_layout Standard
Da die Helligkeitskorrektur der Kamera sehr unberechenbar reagiert müssen
 wir sehr ähnliche Bilder projizieren, da wir sonst nicht mit Differenzbilder
 arbeiten können.
\end_layout

\begin_layout Subsection
Stift Erkennen
\end_layout

\begin_layout Standard
Als Ziel dieser Arbeit soll ein Stift an einer Leinwand gefunden werden.
 Dies soll das virtuelle Schreiben auf diese Leinwand ermöglichen.
 Da Bildverarbeitung auch heute noch viel Rechenleistung benötigt, gilt
 es genau zu wissen, was man wann und wieso tut.
 Das Finden eines Stiftes besteht aus verschiedenen Teilproblemen, die verschied
en zu lösen sind.
 So sind zum Beispiel Präsenz- und Positionsaspekt des Stiftes zu unterscheiden.
 Es ist teilweise nicht unbedingt notwendig zu wissen, wo der Stift auf
 dem Bild ist.
 Falls es einfach ist, die Präsenz des Stiftes festzustellen, nicht aber
 die Position, kann erstere Information verwendet werden um komplizerte
 und rechenintensive Schritte erst anzustossen wenn nötig.
 Neben den verschiedenen vorzunehmenden Schritten, ist auch Kontextwissen
 wichtig.
 Ein Bild kann gezielter nach Präsenz und Position des Stiftes durchsucht
 werden, wenn bekannt ist, wie er sich zeitlich bewegt.
\end_layout

\begin_layout Paragraph
Präsenz durch Helligkeit
\end_layout

\begin_layout Standard
Generell ist es nicht einfach, herauszufinden, ob sich ein Objekt in einem
 Bild befindet.
 Ansätze aus der digitalen Bildverarbeitung wie die Diskrete Fourier-Transformat
ion
\begin_inset Foot
status open

\begin_layout Plain Layout
Die Diskrete Fourier-Transformation erhält die Eigenschaften Verschiebung
 und Skalierung in Zeit und Frequenz.
\end_layout

\end_inset

 oder der Gradientenabstieg mittels dynamischer Bildskalierung
\begin_inset Foot
status open

\begin_layout Plain Layout
James MacLean in 
\begin_inset Quotes gld
\end_inset

Fast Pattern Recognition Using Gradient-Descent Search in an Image Pyramid
\begin_inset Quotes grd
\end_inset


\end_layout

\end_inset

 sind kompliziert und benötigen viel Rechenleistung.
 Die Komplexität des Problems wird immens reduziert, wenn die Eigenschaften
 des Stiftes klarer definiert sind.
 Es wäre möglich, Form, Farbe, Helligkeit, Farbtemperatur, Geschwindigkeit,
 Bewegung, Puls, etc.
 auf einem oder mehreren Kamerabilder zu analysieren.
 Der Einfachheit halber reduzieren wir den Stift auf seine Helligkeit.
 Wir gehen noch weiter und sagen, der Stift ist der hellste Punkt in einem
 Bild.
 Zur Umsetzung könnte ein optisches Licht (ev.
 Infrarot) als Stift verwendet werden.
\end_layout

\begin_layout Paragraph
Präsenz durch Kardinalität
\end_layout

\begin_layout Standard
Der hellste Punkt auf dem Kamerabild bildet den Stift ab.
 Es gibt verschiedene Möglichkeiten, den Fall, dass mehrere Spot auftreten,
 zu behandeln.
 
\end_layout

\begin_layout Itemize
Es könnte lediglich der hellste Punkt gewertet werden.
\end_layout

\begin_layout Itemize
Es könnte eine genaue Anzahl Punkte aus dem Kontext gewählt werden.
\end_layout

\begin_layout Itemize
Es könnten alle Punkte verworfen werden.
\end_layout

\begin_layout Standard
Um Fehler zu vermeiden, scheint es sinnvoll, alle undefinierten Zustände
 zu verwerfen, Punkte also nur zu werten, wenn sie alleine in ihrem definierten
 Zustand auftreten.
 Es befindet sich also ein Stift auf dem Kamerabild, wenn ein gewisser Helligkei
tswert überschritten wird.
 Diese Entscheidung ist nur sinnvoll, wenn die Fehlerrate (zu viele Punkte
 erkannt) nicht zu hoch und die Framerate nicht zu tief ist.
\end_layout

\begin_layout Paragraph*
Position durch Mittelwert oder Schwerpunkt
\end_layout

\begin_layout Standard
Die Position des Stiftes hängt vorzugsweise von der Präsenz eines Stiftes
 ab.
 So muss die Position des Stiftes nur dann gesucht werden wenn er präsent
 ist.
 Dies spart Rechenzeit.
 Die oben beschriebenen Kriterien zur Präsenz ergeben jeweils eine Stiftpräsenz.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/theory/light-point.png
	scale 200

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Stehender Lichtpunkt in der Theorie
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die genaue Position des Stiftes befindet sich in der Mittel am hellsten
 Punkt.
 In der Theorie ist das der Mittelwert aller hellen umgebenden Pixel oder
 der Schwerpunkt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs/frame1.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs/frame2.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs/diff.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Frame x, Frame x+1, Differenz - Der Punkt bewegt sich nach rechts unten
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Messungen zeigen, dass ein bewegter Lichtpunkt in der Praxis nicht rund
 ist, sondern in der Bewegungsrichtung gestaucht.
 Die Stauchung wird durch die Belichtung verursacht.
 In der Bewegungsrichtung erfährt der CCD-Sensor der Kamera eine starke
 Intensitätsänderung, während sich die Intensität am Rand der Laufrichtung
 weniger stark ändert.
 Der CCD trägt der starken Änderung mehr Rechnung als der schwachen.
 Im Weiteren ist die Helligkeit des Lichtpunktes vom Zentrum her nicht weich
 abfallend, sonder eher scharfkantig.
 Die rührt von Reflexionen auf der dahinter liegenden Leinwand.
\end_layout

\begin_layout Standard
Um der Stabilität Willen wird vorgeschlagen, die Position der Stiftposition
 nicht zu genau zu bestimmen.
 Für eine Anwendung, die lediglich auf eine Leinwand zeichnen kann, sollte
 die Mitte einer Umrandung der hellsten Werte mittels fixem Grenzwert reichen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/theory/light-point - thresholded.png
	scale 200

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Per Grenzwert wird der Lichtpunkt in das Zentrum eines Vierecks gelegt.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Gezieltes Suchen
\end_layout

\begin_layout Standard
Ein Algorithmus zum Finden der Stiftposition sollte den erarbeiteten Kontext
 berücksichtigen.
 In einem Bild kann zum Beispiel in der Nähe eines im vorherigen Bild gefundenen
 Punktes gesucht werden.
 So reduziert sich der Aufwand des Algorithmus von 
\begin_inset Formula $O\left(cn^{2}\right)$
\end_inset

auf 
\begin_inset Formula $O\left(c\left(\frac{n}{x}\right)^{2}\right)$
\end_inset

wobei 
\begin_inset Formula $x$
\end_inset

 die Seitenlänge 
\begin_inset Formula $n$
\end_inset

 des Kamerabildes in ein kleineres Suchfenster mit Seitenlänge 
\begin_inset Formula $\frac{n}{x}$
\end_inset

 teilt
\begin_inset Foot
status open

\begin_layout Plain Layout
Asymptotisch wird angenommen, dass das Kamerabild quadratisch ist.
\end_layout

\end_inset

.
 Im Fall, dass entweder keine oder keine brauchbaren Kontextinformationen
 vorhanden sind, kann die Suche auf ein grösseres oder das ganze Suchfenster
 ausgeweitet werden.
 Dies erhöht die Worstcase Laufzeit auf 
\begin_inset Formula $O\left(c\left(\frac{n}{x}\right)^{2}+c\left(y\frac{n}{x}\right)^{2}\right)$
\end_inset

, wobei 
\begin_inset Formula $y$
\end_inset

 der Faktor der Vergrösserung ist.
 Wir denken, dass es reicht, 
\begin_inset Formula $y:=x$
\end_inset

 zu setzen, wenn das erste Suchfenster gut gewählt ist, da die Wahrscheinlichkei
t gross ist, dass entweder gar kein Punkt gefunden wird oder dass sich der
 Punkte entgegen dem Kontext verhält
\begin_inset Foot
status open

\begin_layout Plain Layout
Dies macht den kontextabhängigen Algorithmus per se unbrauchbar.
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph*
Stabilität durch Differenzbilder
\end_layout

\begin_layout Standard
Reduktionen des Kontextes muss nicht unbedingt wie oben beschrieben zu Instabili
tät und mehr Fallunterscheidungen führen.
 Zum Beispiel können relevante Informationen durch Differenzbilder hervorgehoben
 und Rauschen unterdrückt werden.
 Sogar Kriterien, die mit den Eigenschaften eines Stiftes konkurrieren,
 wie zum Beispiel helle statische Reflexionen auf der Leinwand können so
 unterdrückt werden.
 Falls Differenzbilder verwendet werden, müssen weitere Überlegungen zur
 Kardinalität der Lichtpunkte gemacht werden.
 Was nun ein oder zwei resultierende Punkte auf dem Bild bedeutet ist nicht
 ganz klar (s.u.).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/rauschen-small.png
	width 50col%

\end_inset


\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/rauschen-small-diff.png
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Auf dem Differenzbild (rechts) ist der Laserpointer Punkt viel besser sichtbar
 als auf dem Quellbild (links).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Umsetzung
\end_layout

\begin_layout Subsection
Technologien
\end_layout

\begin_layout Subsubsection
Programmiersprache
\end_layout

\begin_layout Standard
Wir haben uns für die Programmiersprache C# entschieden, da uns diese besser
 liegt (TODO schnellere Entwicklungszeit...).
 Zudem war es einfacher auf Systemfunktionen wie z.B.
 Direct Show und Mausemulation zuzugreifen.
 In Java wäre das nicht möglich gewesen.
 Mit C++ hätten wir bei der Bildbearbeitung etwas weniger Performance benötigt,
 dafür hätten wir mehr Einarbeitungszeit benötigt.
 Aus unserer Sicht haben wir uns richtig entschieden.
\end_layout

\begin_layout Subsubsection
Framework
\end_layout

\begin_layout Standard
Beim grafischen Framework haben wir uns für AForge entschieden, da es nativ
 in C# geschrieben ist und gut dokumentiert ist.
 Im Gegensatz dazu hätten wir mit OpenCV etwas besser optimierte Algorithmen
 gehabt.
 Da wir nur einen Prototypen produzieren, ist Performance für uns nicht
 besonders wichtig, was unsere Wahl ebenfalls beeinflusst hat.
\end_layout

\begin_layout Paragraph
OpenCV
\end_layout

\begin_layout Standard
OpenCV ist ein riesiges Produkt, das alle Möglichkeiten zur Bildanalyse
 bietet.
 Es gibt einen wrapper für C#, jedoch hat sich auch dieser in unseren Versuchen
 als nicht besonders Einfach in der Benutzung herausgestellt.
 
\end_layout

\begin_layout Subparagraph
Vorteile
\end_layout

\begin_layout Itemize
Unglaublich breite Einsatztmöglichkeiten
\end_layout

\begin_layout Itemize
Bietet native Unterstützung um eine Kamera zu kalibrieren.
\end_layout

\begin_layout Itemize
Grosse Community
\end_layout

\begin_layout Itemize
Sehr performant
\end_layout

\begin_layout Subparagraph
Nachteile
\end_layout

\begin_layout Itemize
Nutzung unter C# ist kompliziert
\end_layout

\begin_layout Itemize
Miserable Dokumentation
\end_layout

\begin_layout Itemize
Für eine Verwendung Out-of-the-Box müssen ca.
 600MB zusätzliche libraries eingebunden werden, selbst wenn diese nicht
 benutzt werden.
\end_layout

\begin_layout Itemize
Aufwand für Einarbeitung ist sehr gross
\end_layout

\begin_layout Itemize
Algorithmen lassen sich nur geringfügig beeinflussen.
\end_layout

\begin_layout Itemize
Es ist unklar, wie die Algorithmen genau funktionieren und eine Codeanalyse
 ist unglaublich Zeitaufwändig.
\end_layout

\begin_layout Subparagraph
Fazit
\end_layout

\begin_layout Standard
Für unseren Prototypen ist OpenCV viel zu aufwändig und benötigt zu viel
 Aufwand um das Framework zu verstehen und korrekt zu nutzen.
\end_layout

\begin_layout Paragraph
AForge
\end_layout

\begin_layout Standard
AForge bietet eine stabile Blob-Detektion, die zuverlässig funktioniert
 und Attribute zur Analyse und Fehlerdetektion bieten.
 Zudem funktieoniert das Anwenden von Filtern auf Bilder sehr zuverlässig
 und intuitiv.
\end_layout

\begin_layout Subparagraph
Vorteile
\end_layout

\begin_layout Itemize
Es stehen viele Filter zur Verfügung
\end_layout

\begin_layout Itemize
Blobs werden genau erkannt.
\end_layout

\begin_layout Itemize
Die Berechnungen sind genügend performant.
\end_layout

\begin_layout Itemize
Die Dokumentation ist sehr gut.
\end_layout

\begin_layout Itemize
Der Code ist einfach zu verstehen.
\end_layout

\begin_layout Subparagraph
Nachteile
\end_layout

\begin_layout Itemize
Die Performance ist etwas schlechter als OpenCV
\end_layout

\begin_layout Itemize
Der Code enhält noch kleine Bugs
\end_layout

\begin_layout Itemize
Der Entwickler kümmert sich nicht gut um das Projekt.
\end_layout

\begin_layout Subparagraph
Fazit
\end_layout

\begin_layout Standard
Für einen Prototypen ist die Nutztung von AForge ideal aufgrund der kurzen
 Einarbeitungszeit.
 Für ein Release sollt dies Entscheidung allerdings nochmals überdenkt werden.
\end_layout

\begin_layout Subsection
Architektur
\end_layout

\begin_layout Subsubsection
Domain
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Domain.emf
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Das Domain Modell berücksichtigt modulare Erweiterungen.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Hauptsequenz
\end_layout

\begin_layout Standard
Unser Hauptprojekt wird eine ausführbare Datei, die alle unsere Subprojekte
 zusammenbringt.
 
\end_layout

\begin_layout Standard
\noindent
Grobablauf unseres Programms: 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/SSD.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
SSD
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Enumerate
Verbindung mit der Kamera 
\end_layout

\begin_deeper
\begin_layout Enumerate
Der Nutzer kriegt eine Auswahl aller gefundenen Kameras und entscheidet
 sich für eine.
 
\end_layout

\begin_layout Enumerate
Anhand der Auswahl wird die Kamera angelegt und gestartet.
 
\end_layout

\end_deeper
\begin_layout Enumerate
Das Programm sucht einen passenden Visualisierer und legt diesen an.
 
\end_layout

\begin_layout Enumerate
Ein DataParser wird angelegt.
 
\end_layout

\begin_layout Enumerate
Die Kalibration kann nun automatisch oder nach einer Interaktion des Benutzers
 gestartet werden.
 
\end_layout

\begin_layout Enumerate
Die Details über den Ablauf des Kalibrationsvorgang sind im Abschnitt Kalibratio
n aufgeführt.
 
\end_layout

\begin_layout Enumerate
Kalibration wird erfolgreich abgeschlossen und das Pentracking gestartet.
 Die Details über den Ablauf des Trackings sind im Abschnitt Pen-Tracking
 aufgeführt.
 
\end_layout

\begin_layout Subsection
Visualisierung 
\end_layout

\begin_layout Standard
Ein erstes Problem bot sich uns, als wir versuchten, aus einer Library auf
 den Bildschirm zu zeichnen.
 Das wiederspricht eigentlich allen Architekturmodellen, jedoch ist es bei
 unserer Lösung nötig für die Kalibration.
 
\end_layout

\begin_layout Subsubsection
Probleme
\end_layout

\begin_layout Itemize
Wir wissen nicht, in welcher Umgebung (Anzahl Treads) unsere Library läuft.
 Gewisse Kameras erzeugen zudem verschiede Threads in denen die Frames übergeben
 werden.
 
\end_layout

\begin_layout Itemize
Jedes GUI muss in einem eigenen Thread laufen das ein spezielles ThreadSTA-Attri
but hat.
 
\end_layout

\begin_layout Itemize
Der Garbage-Collector räumt den GUI-Thread ab, selbst wenn er in Zukunft
 noch verwendet werden müsste.
 
\end_layout

\begin_layout Itemize
Wenn ein GUI gestartet wird, öffnet es sich sofort.
 Das ist in unseren Fall nicht erwünscht.
 Ein Hide, das gerade nach dem Start aufgerufen wird, hat keine Wirkung.
 Es muss erst der komplette Start und die Darstellung des GUIs(ca.
 10ms) abgewartet werden, bis es versteckt werden kann.
 
\end_layout

\begin_layout Subsubsection
Umsetzungen
\end_layout

\begin_layout Paragraph
WPF
\end_layout

\begin_layout Standard
Sämtliche Interaktionen müssen über den Dispatcher geschehen.
 Andernfalls wird sofort eine Exception geworfen.
 Dadurch kann die Concurrency vom aufrufenden Code wieder Sequenziell abgearbeit
et werden, wie es für ein GUI nötig ist.
 Eine Lösung zu entwickeln, die komplett Concurrency-Safe ist ziemlich aufwändig
 und zeitintensiv.
 
\end_layout

\begin_layout Paragraph
WinForms 
\end_layout

\begin_layout Standard
Mit dem AllowUnsafeThreadExecution Attribut kann die ganze Thread-security
 abgeschaltet werden.
 Dafür müssen alle Grafikelemente vor dem Bearbeiten gelockt werden und
 der aufrufende Code ist verantwortlich dafür, dass die Aufrufreihenfolge
 und der Ablauf stimmt.
 Durch Double-Buffering kann die Performance erhöht werden, wenn mehrere
 Objekte gezeichnet werden.
 Es ist uns klar, dass diese Umsetzung diverse Architekturprinzipien und
 Guidelines verletzt.
 
\end_layout

\begin_layout Standard

\series bold
In einem finalen Release darf diese Umsetzung nicht verwendet werden.

\series default
 
\end_layout

\begin_layout Subsection
Kalibrierung
\end_layout

\begin_layout Standard
Die Grundüberlegung jedes Ansatzes der Kalibration ist derselbe: Im ersten
 Schritt werden die Ecken des Bildschirms gefunden, in den weiteren Schritten
 werden zusätzliche Daten gesammelt um die Interpolation zu verbessern.
 
\end_layout

\begin_layout Standard
TODO: Übergang zu Erkenntnissen in der folgenden Liste:
\end_layout

\begin_layout Enumerate
Als erster Schritt ist es nötig, dass ein Frame einzulesen, um die Auflösung
 der Kamera zu erhalten.
 
\end_layout

\begin_layout Enumerate
Das erhaltene Bild ist weder Flächen- noch Winkeltreu.
 
\end_layout

\begin_layout Enumerate
Die Belichtungskorrektur der Kamera ist sehr gefährlich, um ein sinnvolles
 Differenzbild zu erhalten, muss darauf geachtet werden, dass auf beiden
 Bildern die gleiche Helligkeitsverteilung herrscht.
 Dies Verunmöglicht, ein universelles Bild zu speichern, mit dem man den
 Hintergrund entfernen könnte.
 
\end_layout

\begin_layout Enumerate
Die Belichtungskorrektur benötigt ca.
 1-2 Frames, bis sie reagiert.
 Aus Performance-Gründen lässt sich das leider nicht zu unserem Vorteil
 nutzen.
 
\end_layout

\begin_layout Enumerate
Von gewissen Webcams wird das Bild gespiegelt zurückgegeben, von anderen
 nicht.
 
\end_layout

\begin_layout Enumerate
Bis die Bilder der Kamera dem entsprechen, was man erwarten würde, muss
 man ca.
 100ms warten.
 Diese Dauer ist zudem vom gewählten Visualisierer abhängig.
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/Verzögerung1.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/Verzögerung2.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Verzögerung der Darstellung
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Die Linse der Kamera kann für eine zusätzliche Verzerrung sorgen.
 
\end_layout

\begin_layout Enumerate
Berechnungen mit C# Bitmaps sind extrem inperformant.
 
\end_layout

\begin_layout Enumerate
Eine sequentielle Bearbeitung der Daten führt dazu, dass man mit veralteten
 (und somit falschen) Daten arbeitet.
 
\end_layout

\begin_layout Enumerate
Eine parallele Bearbeitung der führt meistens zum unkontrollierten Spawnen
 von Tasks, die das System verlangsamen und schliesslich ein Ablaufen verunmögli
chen.
 Falls das Auftritt, hat man ebenfalls Probleme mit alten Daten.
 
\end_layout

\begin_layout Enumerate
Wenn ein Teil der Anzeige durch ein anderes Fenster oder einem Objekt verdeckt
 wird, ist das unmöglich automatisch zu detektieren.
 Daher muss die Erkennung noch durch den Nutzer verifiziert werden.
 
\end_layout

\begin_layout Paragraph
Allgemeine Massnahmen
\end_layout

\begin_layout Itemize
Der Ablauf wird von einer Semaphore geschützt.
 Wenn kein Lock akquiriert werden kann, wird das ankommende Bild verworfen
 und nicht behandelt.
 
\end_layout

\begin_layout Itemize
Nach jedem Zeichnen wird 100 ms gewartet bevor die Semaphore freigegeben
 wird, damit sichergegangen werden kann, dass das erwartete Bild von der
 Kamera ankommt.
 
\end_layout

\begin_layout Subsection
Umsetzung: Schachbrett-Differenzbilder
\end_layout

\begin_layout Standard
Um Differenzbilder nutzen zu können, aber sich nicht durch die Belichtungskorrek
tur beeinflussen zu lassen, muss darauf geachtet werden, dass jedes projizierte
 Bild eine identische Helligkeitsverteilung zum Referenzbild besitzt.
 Das bedeutet, dass für jedes Bild, das man analysieren möchte, zwei Bilder
 Projiziert werden müssen.
 Da diese Art der Erkennung viel genauer ist, nehmen wir diesen Overhead
 in Kauf und verzichten allenfalls auf ein paar Referenzbilder.
 „Lieber wenig gute Daten, als viel schlechte“ 
\end_layout

\begin_layout Paragraph
Ablauf
\end_layout

\begin_layout Enumerate
Es wird ein Schachbrett mit 
\begin_inset Formula $n\times m$
\end_inset

 Quadraten projiziert.
 Das Verhältnis von n zu m sollte dem Bildschirmverhältnis entsprechen und
 die Quadrate sollten noch gut auf dem Kamerabild sichtbar sein (15-30 Pixel
 Seitenlänge) 
\end_layout

\begin_layout Enumerate
Das Schachbrett wird erneut projiziert, diesmal mit invertierten Farben.
 Auf dem Differenzbild sollte jetzt die Leinwand klar zu erkennen sein.
 Da es an den Kanten der Quadrate Lücken haben wird (diejenigen Pixelreihen,
 die von der Kamera auf beiden Bildern als Beleuchtet erkannt hat), müssen
 wir diese z.B.
 mit einem Gaussfilter mit einer kleinen Kernel-Size eliminieren, da es
 sonst bei der Bloberkennung zu Fehlerkennungen kommt.
 Jetzt können die Ecken des Bildschirms sehr genau erkannt werden.
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/img01-0-0.jpg
	lyxscale 30
	width 40col%

\end_inset

 - 
\begin_inset Graphics
	filename Bilder/Calibration/img02-0-0.jpg
	lyxscale 30
	width 40col%

\end_inset

 = 
\begin_inset Graphics
	filename Bilder/Calibration/diff.png
	width 90col%

\end_inset


\end_layout

\begin_layout Plain Layout
Gaussfilter mit Radius 3, um die Erkennung zu verbessern:
\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/diffblur.png
	width 90col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Erkennung des Bildschirms
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Stifterkennung
\end_layout

\begin_layout Subsubsection
Verfahren
\end_layout

\begin_layout Standard
Wie oben beschrieben, haben wir uns auf den Ansatz beschränkt, dass der
 Stift das hellste sichtbare Licht auf dem Kamerabild darstellt.
 Der hellste Punkt sollte also die aktuelle Stiftposition sein.
 Es gibt zwei naheliegende Ansätze um diesen Punkt zu finden.
\end_layout

\begin_layout Itemize
Finde den hellsten Punkt auf dem Bild.
 Das hat Schwächen.
 Insbesondere wenn das Bild viel Rauschen beinhaltet.
\end_layout

\begin_layout Itemize
Finde den hellsten Punkt der sich bewegt.
\end_layout

\begin_layout Standard
In unserer Software verwenden wird für guten Input den Ansatz ohne Differenzbild
er und für schlechten Input (wenig Licht, viel Rauschen) den stabileren
 Ansatz mit Differenzbildern.
\end_layout

\begin_layout Paragraph
Beispiel
\end_layout

\begin_layout Standard
Im folgenden Beispiel wurde der automatische Weissabgleich der Kamera auf
 Rot konzentriert und die Überbeleuchtung drastisch reduziert.
 Resultierend sieht man die hellsten Punkte auf dem Beamerbild.
 Der alleinstehende Punkt im ersten Bild ist ein Laserpointer-Punkt.
 Im zweiten Bild befindet er sich im verrauschten Bereich.
 Den Punkt dort in einem einzelnen Bild per Software zu finden, kann Schwierigke
iten bereiten, da der Laserpunkt nicht der hellste sein muss.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/laser-standalone.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Der Laserpointer ist gut sichtbar
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/laser-rauschen.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Der Laserpointer ist im Rauschen kaum sichtbar
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Differenzbilder
\end_layout

\begin_layout Standard
Ein stabilerer Ansatz ist, den Lichtpunkt über Differenzbilder zu finden.
 Das Differenzbild filtert helles Rauschen und stehende helle Lichtquellen
 zuverlässiger raus als eine einfache Hell/Dunkel-Schranke.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/laser-diff.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Differenzbild zweier Frames mit Laserpunkten
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/laser-diffgray.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Nachdem die Rotanteile zu Graustufen übersetzt wurden, sieht man die gesuchten
 Laserpunkte besser.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/laser-diffthreshold.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Nun ergibt ein Hell/Dunkel-Filter (Threshold oder Binarize) gute Anhaltspunkte
 wo sich gesuchte Punkte befinden.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Kardinalität der gefundenen Punkte
\end_layout

\begin_layout Standard
Alle zusammenhängenden hellen Bereiche werden Blobs genannt.
 Diese Blobs repräsentieren Positionen wo sich der Stift im aktuellen und
 im vorherigen Frame befunden hat.
 Es gibt verschiedene Fälle die nach dem Finden der Blobs unterschieden
 werden müssen.
\end_layout

\begin_layout Itemize
Es wurde kein Blob gefunden:
\begin_inset Newline newline
\end_inset

Für die Software ist kein Stift sichtbar.
 Es wird kein Punkt gefunden.
 Dies kann der Fall sein, wenn die präsentierende Person nicht schreibt,
 vor dem Stift steht und der Kamera die Sicht verdeckt oder wenn die Lichtverhäl
tnisse nicht ideal sind und der Stift von der Kamera nicht hell genug wahrgenomm
en wird.
\end_layout

\begin_layout Itemize
Es wurde ein Blob gefunden:
\begin_inset Newline newline
\end_inset

Entweder hat sich der Stift nicht, oder zu wenig bewegt um zwei Blobs zu
 erzeugen oder es handelt sich um eine Fehlerkennung.
 
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-or-two-blobs/frame1.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-or-two-blobs/frame2.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-or-two-blobs/diff.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Frame x, Frame x+1, Differenz
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-blob/frame1.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-blob/frame2.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-blob/diff.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Frame x, Frame x+1, Differenz
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Es wurden zwei Blobs gefunden:
\begin_inset Newline newline
\end_inset

Das ist der gewünschte Fall.
 Beide Punkte bilden gültige Positionen des letzten und des momentanen Frames.
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs/frame1.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs/frame2.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs/diff.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Frame x, Frame x+1, Differenz - Die Punkte gehen 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Es wurden mehr als zwei Blobs gefunden:
\begin_inset Newline newline
\end_inset

Ungültig.
 Wird gemüllt.
 Optimierung: Man könnte den hellsten Punkt suche und als Resultat zurückgeben.
\end_layout

\begin_layout Standard
Generell wird angenommen, dass alle Blobs, falls deren Anzahl zwei oder
 kleiner ist, gültige Stiftpositionen bilden und dass Fehlerkennungen vorher
 gefiltert werden konnten.
 Gute Filter setzen die Eigenschaften eines gültigen Lichtpunktes gut um
 (s.u.).
 
\end_layout

\begin_layout Paragraph
Resultierende Punktposition
\end_layout

\begin_layout Standard
Der Einfachheit halber wird nun das euklidische Zentrum der zwei gefundenen
 Blobs berechnet und als Resultatposition genommen.
 Falls nur ein Punkt gefunden wurde, wird dieser als Resultat gewählt.
 Dieses Verfahren beschränkt den Kontext und damit die Komplexität des Algorithm
us auf das Vorhandensein von genau zwei Bildaufnahmen.
 Es werden weder Geschwindigkeit, noch Vorgängerpunkte vorausgesetzt.
 Ein Nachteil, der dabei in Kauf genommen wird, ist, dass die gefundene
 Punktposition von korrekter Zeit und korrektem Ort abweichen kann.
 Diese Abweichung wird stärker, je schneller sich der Punkt auf der Leinwand
 bewegt.
 Mit Überlegungen aus dem WKS-Abtasttheorem wird aber klar, dass sich dieser
 Effekt nicht sehr stark in der mittleren Erkennungsqualität niederschlägt.
 Die Abtastrate vor und nach der Interpolation ist die gleiche.
 Die Abbildung der zwei gemessenen Punkte auf den Mittelwert resultiert
 in einer Position, die höchstwahrscheinlich gemessen worden wäre, wenn
 mit der doppelten Rate abgetastet worden wäre.
 Diese Behauptung gilt für unbeschleunigte gerade Bewegungen genau und für
 das Schreiben an eine Leinwand bei hoher Abtastrate näherungsweise.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/Interpolation/interpolation-random.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Zufällig verteilte Punkte (blau) mit grossen Abständen.
 Die Interpolation (violett) taugt nichts.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/Interpolation/interpolation-smoothed.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Die Interpolation dient als Glättung
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/Interpolation/interpolation-curves.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Bei genug Punkten bleibt die Ursprungsfigur gut erhalten.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Zeitlich korrekte Punktposition
\end_layout

\begin_layout Standard
Es wäre möglich, die genaue Punktposition zu finden, indem auf dem aktuellen
 Differenzbild der Vorgänger bestimmt wird.
 Im folgenden werden zwei Ansätze diskutiert, wie dies bewerkstelligt werden
 könnte.
 Abbildung 15 zeigt die Situation: Es wurden drei Aufnahmen gemacht, davon
 wiederum zwei Differenzbilder.
 Die zeitliche Abfolge der gefundenen Punkte ist mit den Zahlen 1 bis 3
 gekennzeichnet.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/timed-position/frames1.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/timed-position/frames2.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Zeitliche Abfolge 
\begin_inset Formula $Differenz(Bild_{x},Bild_{x+1})$
\end_inset

 und 
\begin_inset Formula $Differenz(Bild_{x+1},Bild_{x+2})$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der erste Ansatz bezieht sich auf die im Differenzbild per Threshold gefundenen
 Blobs.
 Die gefundenen Positionen könnten mit dem im vorigen Differenzbild gefundenen
 Punkt verglichen werden.
 Der noch unbekannte Punkt ist der neue resultierende Punkt.
 Im Gegensatz zum oben genannten Interpolationsverfahren wird hier immer
 die aktuelle und richtige Position gefunden.
 Dieses Vorgehen erhöht jedoch die Komplexität des Algorithmus, da zusätzliche
 Fallunterscheidungen gemacht werden müssen.
 So muss separat unterschieden werden, was das Finden eines einzelnen Blobs
 nun bedeutet.
 Ansätze wären den Mittelpunkt oder Schwerpunkt zu berechnen oder genauere
 Analysen im Bild vorzunehmen.
 Man muss sich jedoch bewusst sein, dass Mischen von Interpolation mit Messung
 den Nachteil hat, dass Grössen wie Position und Geschwindigkeit verschwommen
 werden.
 Bei einem einzelnen grossen Blob wäre die Interpolation ungenau und korrelliert
 nicht mit den Messinformationen, die aus vorherigen zwei Blobs gewonnen
 wurde.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs-overlay/diff1.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs-overlay/diff2.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs-overlay/diff3.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Problematische Einzelfunde
\end_layout

\end_inset


\end_layout

\end_inset

Tests haben gezeigt, dass das aktuelle Interpolationsverfahren genügend
 genau ist.
 Bei stabilem Input wird ohne Differenzbilder direkt mit dem hellsten Punkt
 gearbeitet.
 Da hat die Interpolation keine negativen Auswirkungen.
\end_layout

\begin_layout Subparagraph
Genauere Punktposition
\end_layout

\begin_layout Subsubsection
Umsetzung
\end_layout

\begin_layout Standard
Die Umsetzung ist auf die Stabilität des Verfahrens mit Differenzbildern
 ausgerichtet.
 Sie funktioniert bei sehr schwachen Lichtpunkten wie Laserpointern und
 mit viel Rauschen.
 Nichtsdestotrotz wurde schlussendlich im Prototypen wieder auf die einfachere
 Version ohne Differenzbilder umgestellt.
 Bei guten Umgebungsbedingungen, wie guter Sichtbarkeit des Lichts und wenig
 Rauschen benötigt man die Stabilität nicht.
 Zudem wird so Rechenzeit gespart.
\end_layout

\begin_layout Paragraph
Laufzeit
\end_layout

\begin_layout Standard
Falls schon Punkte gefunden wurden, wird zuerst nur ein Bildausschnitt um
 den zuletzt gefundenen Punkt analysiert.
 Im Erfolgsfall spart das Rechenzeit.
 Falls man im Bildausschnitt kein Punkt findet, wird die Suche auf das ganze
 Bild ausgeweitet.
 Im Mittel benötigt man so auf einem Intel Core Duo mit 2Ghz ca 4ms pro
 gefundenem Lichtpunkt.
\end_layout

\begin_layout Paragraph
Eigenschaften eines Lichtpunktes
\end_layout

\begin_layout Standard
Ein von einem Stift erzeugter Lichtpunkt hat diverse Eigenschaften.
 Im Folgenden werden diese genauer ausgeführt.
\end_layout

\begin_layout Subsubsection
Einschränkungen
\end_layout

\begin_layout Standard
- Das Licht hat eine wichtige Rolle gespielt.
\begin_inset Newline newline
\end_inset

- Es wurde eine einfache Laptopkamera eines T430s verwendet (640x480px à
 40ms).
\begin_inset Newline newline
\end_inset

- Der Weissabgleich ist lästig.
\begin_inset Newline newline
\end_inset

- Die Einstellungen zum Weissabgleich können unter Windows nur per DirectShow
 Menu eingestellt werden.
 
\end_layout

\begin_layout Subsubsection
Wahl des Stiftes
\end_layout

\begin_layout Standard
Leuchtwerkzeug über optisches Licht für Proof Of Concept.
 Wahrscheinlich würde in einem Produkt Infrarot-Technologie eingesetzt.
\end_layout

\begin_layout Itemize
Glühbirne
\end_layout

\begin_layout Itemize
LED
\end_layout

\begin_layout Itemize
Laser Pointer, Frequenzband
\end_layout

\begin_layout Itemize
Infrarot Lambsa 1/4 Pass-Filter
\end_layout

\begin_layout Subsection
Input Emulation
\end_layout

\begin_layout Standard
Gemäss Aufgabenstellung war in unserem Fall lediglich eine PowerPoint-Integratio
n gefordert.
 Wir haben uns jedoch überlegt, dass wir mit einer Mausemulation weit mehr
 machen könnten.
 Ausserdem kann man auch PowerPoint mit einer emulierten Maus gut bedienen.
 Zudem haben wir schon Erfahrungen gesammelt, wie man mit C# Mausbefehle
 auf Driver-Level injizieren kann.
 Diesen Weg benutzten ebenfalls Devices anderer Hersteller, wie z.B.
 Logitec Presenter.
 Diese emulieren jedoch eine Tastatur, was für uns nicht sinnvoll, aber
 optional auch möglich ist.
 Unter Windows 8 ist es zudem möglich, Touch-Events zu generieren.
 Damit müssten wir uns nicht mehr um die Analyse der Gesten kümmern, da
 uns das vom Betriebssystem abgenommen wird.
 Da wir jedoch auch ältere Systeme unterstützen wollen, haben wir einen
 Teil der Windows 8 Touch-funktionalität nachgebildet, die wir mit Mausbefehlen
 nachbauen.
 Dies ist z.B.
 ein Rechtsklick durch warten an einem Ort.
\end_layout

\begin_layout Standard
Um die erkannten Pixel zu glätten, mitteln wir jeweils die letzten 6 Punkte,
 die wir interpoliert haben.
 So können wir einen grossen Teil des Rauschens ausgleichen und erhalten
 eine Genauigkeit, die höher ist, als wir überhaupt aus dem Kamerabild extrahier
en können.
 Die Verzögerung wird für den User erst ab einer Mittelung mit 15 Punkten
 bemerkbar.
\end_layout

\begin_layout Subsection
Erkenntnisse
\end_layout

\begin_layout Subsubsection*
Kamera
\end_layout

\begin_layout Standard
Wir müssen die Kamera noch mit einem eigenen Fenster konfigurieren.
 Das ist nicht ideal, aber immerhin können wir gewisse Werte einstellen.
\end_layout

\begin_layout Subsubsection*
Kalibration
\end_layout

\begin_layout Standard
Wir haben gesehen, dass man auch anhand von vier Referenzpunkten sehr genau
 interpolieren kann.
 Es gibt Möglichkeiten, um mehr Referenzpunkte zu erhalten, diese sind aber
 meist relativ kompliziert und Zeitintensiv.
 Wenn man eine stabile und sichere Kalibration möchte, sollte man sich auf
 die Eckpunkte beschränken.
\end_layout

\begin_layout Subsubsection*
Emulation
\end_layout

\begin_layout Standard
Unser Prototyp funktioniert sehr genau und ist sehr Fehlertolerant.
 Durch die Mittelung von Uneren Ergebnissen der Interpolation erhalten wir
 sehr gute Ergebnisse, die sehr feine Zeichnungen ermöglichen.
 Zudem gibt es durch die Mittelung keine Sprünge der Linien da solche Pixelgenau
 gezeichnet werden können.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Ausblick
\end_layout

\begin_layout Subsection
Kamera
\end_layout

\begin_layout Standard
Hier besteht noch viel Verbesserungspotenzial.
 Die Konfiguration müsste irgendwie Automatisiert werden.
 Zudem wäre eine Nutzung von Infrarot-Signalen sehr nützlich.
\end_layout

\begin_layout Standard
Auswahl???
\end_layout

\begin_layout Subsection
Kalibrierung
\end_layout

\begin_layout Standard
Hier gibt es zwei Ansätzte, die weiterverfolgt werden können um mehr Referenzpun
kte zu erhalten.
 Diese knn man nutzen um allfälliger Korrekturfaktoren einzuführen und die
 Genuigkeit zu verbessern.
\end_layout

\begin_layout Standard
Ein anderer Ansatz wäre, dass man die Kalibration nicht mehr automatisch
 durchführt, sondern durch den Nutzer machen lässt.
 Das ist aufwändiger für diesen, andernseits kann man so noch Störfaktoren
 korrigieren, die vom Stift und dem Winkel, mit dem dieser gehalten wird,
 korrigiert werden.
\end_layout

\begin_layout Paragraph
Kamera mit Infrarot-Kanal
\end_layout

\begin_layout Standard
Hierbei haben wir natürlich stark erweiterte Möglichkeiten
\end_layout

\begin_layout Itemize
Überprüfen, ob die Kalibration immer noch stimmt, während dem laufenden
 Betrieb
\end_layout

\begin_layout Itemize
In-Time anpassen der Korrekturfaktoren
\end_layout

\begin_layout Itemize
Verifizieren, ob sich der Pen dort befindet, wo er erwartet wird und allenfalls
 korrigieren.
\end_layout

\begin_layout Itemize
Nachkalibration auslösen, wenn die Webcam oder der Beamer bewegt wird.
\end_layout

\begin_layout Standard
Das kann sehr viel Verbesserungen bringen, erübrigt eine Kalibration der
 Kamera und verkürzt die Kalibrationszeit.
 Dies wird zusätzlichen Aufwand bedeuten, jedoch sollte sich das eigentlich
 gut in unsere Ansätze integrieren lassen.
 Durch diese Anpassung wird die Nutzerfreundlichkeit sehr stark verbessert.
 Dieser Schritt ist nötig, um dieses Produkt verschiedenen Kundensegmenten
 anzubieten, da eis die Benutzung ungemein vereinfacht.
\end_layout

\begin_layout Subsection
Pen Tracking
\end_layout

\begin_layout Standard
MultiPen für Multitouch?
\end_layout

\begin_layout Subsection
Handdetektion
\end_layout

\begin_layout Subsection
Input Emulation
\end_layout

\begin_layout Standard
Wenn weiterhin der ganze PC damit bedient werden soll, ist die injection
 in den Maustreiber die einzige gangbare Möglichkeit.
 Dabei sollte aber darauf geachtet werden, dass relative Mausbewegungen
 gesendet werden, da es sonst mit gewissen Programmen, die Mausinputs auf
 einem sehr tiefen Level verarbeiten, zu komplikationen kommen wird.
 Dies erfordert jedoch die Möglichkeit, die am PC eingestellte Mausbeschleunigun
g auslesen zu können und Positionen verifizieren zu können.
\end_layout

\begin_layout Paragraph
Touch
\end_layout

\begin_layout Standard
Mit der Touch-Emulation unter Windows 8 unterstützen wir schon alle implementier
ten Touch-Gesten.
 In kombination mit einem Pentracker, der mehrer Pens detektieren kann,
 wären auch Multitouch-Gesten möglich.
\end_layout

\begin_layout Standard
Diese Funktionalität sollte jedoch unter anderen Betriebssystemen nachgebildet
 werden, damit man zumindest eine ähnliche Funktionalität unter älteren
 Systemen gewährleistet werden kann.
\end_layout

\begin_layout Paragraph
API
\end_layout

\begin_layout Standard
Eine weitere Möglichkeit ist, eine API bereitzuistellen, die von anderen
 Softwareherstellern verwendet werden kann, und so unser Produkt in ihre
 Software einbinden können.
 Das kann auch zusätzlich zur Mausemulation gemacht werden.
 Dies wird zwar für unsere Software nicht unbedingt benötigt und ich erachte
 diesen Schritt im Moment als unnötig.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Anhang
\end_layout

\begin_layout Subsection
Kalibrierung: Bilderkennung
\end_layout

\begin_layout Subsubsection
Selber programmierte Eckdetecktion mit Differenzbildern und zufällig verteilten
 Rechtecken.
 
\end_layout

\begin_layout Standard
Hierbei werden kein zusätzlichen Libraries verwendet.
 Da die Bitmaps sehr inperformant sind verwenden wir zudem eine eigene Bitmapkla
sse, welche die Bitmaps zu Bytearrays umwandelt.
 Damit können nur Metrizenberechnungen und Analysen durchgeführt werden.
\end_layout

\begin_layout Subparagraph
Ablauf
\end_layout

\begin_layout Enumerate
Der Bildschirm wird Schwarz gemacht.
 Das entsprechende Bild wird gespeichert.
 
\end_layout

\begin_layout Enumerate
Der Bildschirm wird weiss gemacht und das Differenzbild gemacht.
 Mit 4 Scanlinien werden von jeder Ecke ausgehend unter 45° ein Punkt gesucht,
 dessen Nachbarn in Richtung der gegenüberliegenden Ecke Liegen eine bestimmte
 Deckung besitzen.
 Es wird ein Quadrat mit Seitenlänge 3-5 Pixel berücksichtigt.
 
\end_layout

\begin_layout Enumerate
Es werden 3 Rechtecke mit zufälligen Eckpunkten gezeichnet und die Eckpunkte
 gespeichert, eins pro Farbkanal.
 Auf dem Differenzbild zum Ersten werden mit dem geleichen Verfahren zu
 jedem Farbkanal die Ecken gesucht.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Scanlinien.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Sacnlinien
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Verwendung des AForge-Blob-Detctors
\end_layout

\begin_layout Standard
Diese wird in den kommenden Lösungen immer eingesetzt.
 Ich werde bei jeder Lösung nur auf geänderte und wichtige Aspekte erwähnen.
 Funktionierende Teile wurden jeweils übernommen.
 Die verschiedenen Kalibratoren die Im Code existieren sind keine 1 zu 1
 Umsetzungen der hier beschriebenen Ansätze, sondern Kombinationen davon.
 Der Code von verworfenen Umsetzungen wurde in anderen Umsetzungen teilweise
 Übernommen und aktualisiert.
 Diese Aktualisierungen wurden nicht Nachgepflegt aus dem Grund, dass ich
 diese Lösungen nicht als sinnvoll für ein Weiterverfolgen erachte.
 
\end_layout

\begin_layout Subsubsection
Einfacher Differenzbild-Kalibrator
\end_layout

\begin_layout Enumerate
Als erstes Bild wird der Bildschirm schwarz gefärbt.
 Dieses Bild dient als Grundbild für alle folgenden Differenzbilder 
\end_layout

\begin_layout Enumerate
Der Bildschirm wird komplett weiss gefärbt.
 Auf dem Differenzbild wird der grösste Blob gesucht.
 Das sind dann die Ecken des Bildschirms.
 
\end_layout

\begin_layout Enumerate
Es werden Grüne und blaue Quadrate jeweils versetzt auf den Bildschirm projizier
t, die bei jedem Frame leicht verschoben werden um mehr Referenzpunkte zu
 bekommen.
 Die Erkennung des roten Farbkanals ist am schlechtesten, deshalb verwenden
 wir blau und grün.
 Zwei Farben sind ausreichend, wenn sie mit einem Feld Abstand projiziert
 werden, dass es keine Nachbarschaftskonflikte gibt.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/bgSchachbrett.png
	width 45text%

\end_inset


\begin_inset Formula $\rightarrow$
\end_inset


\begin_inset Graphics
	filename Bilder/Calibration/Scahcbrett erkannt.png
	width 45text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Schachbrettmuster über zwei Farbkanäle
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Diese werden auf dem Differenzbild gesucht.
 Deren Zuordnung wird in einem Folgenden Abschnitt auf Seite ??? behandelt.
 
\end_layout

\begin_layout Standard
Probleme: 
\end_layout

\begin_layout Itemize
Durch die Belichtungskorrektur der Kamera wird ein universeller Hintergrund
 für ein Differenzbild verunmöglicht.
 Es gibt zu viele Fehlerkennungen auf dem Bild.
 
\end_layout

\begin_layout Subsubsection
Histogramm-analyse 
\end_layout

\begin_layout Standard
Hierbei werden keine Differenzbilder gebildet, sondern Helligkeitswerte
 des Bildes analysiert und so können überdurchschnittlich helle Flächen
 (Projektionen) gefunden werden.
 Die restlichen Bildinformationen werden entfernt um eine Blob-Erkennung
 zu ermöglichen.
 
\end_layout

\begin_layout Standard
Durch unterschiedliche Lichtverhältnisse in Bildbereichen ist dieser Ansatz
 anfällig auf Störungen.
 Die Lösung für dieses Problem ist ein aufteilen des Bildes.
 Dabei wird das Bild in verschiedene Regionen aufgeteilt, wo die Helligkeitswert
e weniger stark verteilt sind.
 Anschliesend werden die Flächen wieder zu einem Bild zusammengesetzt.
 
\end_layout

\begin_layout Paragraph
Ablauf
\end_layout

\begin_layout Enumerate
Es wird eine weisse Fläche projiziert.
 Das Bild wird in 2x2 Teile aufgeteilt und der grösste Blob gesucht.
 Das führt zu den Eckepunkten.
 
\end_layout

\begin_layout Enumerate
Es werden die grünen und blauen Quadrate aus dem Vorherigen Verfahren projiziert.
 Das Bild wird in 4 x 4 Teile aufgeteilt und der blaue oder grüne Farbkanal
 separat analysiert.
 In den zwei resultierenden Bildern werden Blobs erkannt und analysiert.
 
\end_layout

\begin_layout Paragraph
Erkenntnisse
\end_layout

\begin_layout Itemize
Die Erkennung der Blobs klappt relativ gut, jedoch sind die Kanten relativ
 unscharf was für eine genaue Erkennung ein Nachteil ist.
 
\end_layout

\begin_layout Itemize
Die automatische Belichtungskorrektur ist kein Problem mehr.
 
\end_layout

\begin_layout Itemize
An den Kanten bei denen das Bild aufgeteilt wurde entstehen häufig Einschnitte
 oder sonstige Ungenauigkeiten.
 Diese sind keine grossen Probleme für den Blob-Detector, jedoch sind sie
 eine weitere Quelle für Ungenauigkeiten.
 Durch eine Filterung nach Grösse erhält man ein gutes Resultat.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/img3.jpg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Erkannte grüne Quadrate
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Erweitertes Differenzbild
\end_layout

\begin_layout Enumerate
Anschliessend werden jeweils zwei Bilder projiziert, deren Differenz genau
 das bekannte Blau-Grüne Muster ergibt.
 Bild So können die Recktecke auf dem Bild ganz scharf und klar erkannt
 werden und identifiziert werden.
 Durch das Bilden eines weiteren Differenzbildes mit den beiden erwünschten
 Farbkanälen kann das meiste Bildrauschen und allfällige Unsicherheiten
 entfernt werden.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/img03-1-0.jpg
	width 45col%

\end_inset

- - 
\begin_inset Graphics
	filename Bilder/Calibration/img03-0-0.jpg
	width 45col%

\end_inset


\end_layout

\begin_layout Plain Layout
=
\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/Colordiff.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Farbmuster
\end_layout

\end_inset


\end_layout

\end_inset

Störungen wie sie hier in der oberen linken Ecke Vorhanden sind können entfernt
 werden, dadurch, dass sie nicht innerhalb der erkannten Bildschirmecken
 liegen.
 Die Grundkalibration ist durchch die Bedingung, dass alle Bildschirmecken
 mindestens 5 Pixel Abstand zu jedem Rand haben müssen.
\end_layout

\begin_layout Subsection
Kalibrierung: Zuordnung von Punkten
\end_layout

\begin_layout Standard
Vom AForge BlobCounter erhalten wir genau alle Blobs die auf dem Kamerabild
 gefunden wurden.
 
\end_layout

\begin_layout Standard
Diese Daten beinhalten: Schwerpunkt, Umfassungsrechteck, Fläche, Breite,
 Höhe.
 Eine Zuordnung zu machen, welcher Blob zu welchen pojizietem Quadrat gehört.
 Durch eine Filterung mit einer vordefinierten minimalen und maximalen Höhe/Brei
te können wir die Blobs filtern und rauschen entfernen.
 Da wir die Ecken des Bildschirms mit Sicherheit kennen, können wir anhand
 des konstruierten Vierecks bestimmen ob ein Blob innerhalb der Projektion
 liegt und andernfalls entfernen.
 Somit können wir jetzt 99% der Fehlerkennungen eliminieren.
 Die Schwerpunkte der Blobs sind jedoch mit Koordinaten des Kamerabildes
 beschrieben, was es für uns schwierig macht, deren Position auf dem Bildschirm
 zu bestimmen, da diese relativ komplex voneinander abhängen.
 So kann z.B.
 die kleinste X-Koordinate zuunterst liegen und die grösste Y-Koordinate
 rechts oben.
 Je nach Verzerrung ist es so schon sehr schwierig nur schon die obere linke
 Ecke zu finden.
 
\end_layout

\begin_layout Paragraph
Mögliche Ansätze
\end_layout

\begin_layout Subsubsection
Rekursiv: 
\end_layout

\begin_layout Standard
Hierbei nehmen wir an, dass die Nachbarn eines Blobs eindeutig bestimmt
 werden können.
 Dies ist möglich anhand der Distanz.
 
\end_layout

\begin_layout Paragraph
Ablauf
\end_layout

\begin_layout Enumerate
Der Algorithmus bestimmt auf jedem Farbkanal denjenigen Blob, der am nächsten
 bei der oberen linken Ecke liegt.
 Durch die Positionsangabe 0|0 für grün oder 1|1 ist bekannt, dass es sich
 um einen Eckpunkt handeln muss.
 Der Punkt wird markiert, dass er nicht nochmals bearbeitet werden muss.
 
\end_layout

\begin_layout Enumerate
Es werden also die zwei nächsten Nachbarn gesucht.
 Anhand der Differenz der der Koordinaten kann bestimmt werden, ob der Punkt
 oberhalb (Y-Differenz ist grösser als die Differenz der X-Achse und negativ),
 rechts (X-Differenz ist grösser und positiv), unten oder links liegt.
 
\end_layout

\begin_layout Enumerate
Die Funktion berechnet die Koordinaten die der gefundene Blob haben muss
 (zwei in die entsprechende Achse verschoben) und startet einen Rekursiven
 Aufruf auf jedem unmarkierten Nachbar, nachdem der Ausgangspunkt als erledigt
 markiert wurde.
 
\end_layout

\begin_layout Enumerate
Der rekursive Aufruf prüft zudem, ob die übergebenen Koordinaten plausibel
 erscheinen und bestimmt anhand deren, wie viele Nachbarn zu erwarten sind.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Rekursion.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Vorgehen Rekursion
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Erkenntnisse
\end_layout

\begin_layout Itemize
Dieser Algorithmus funktioniert perfekt unter synthetischen Umständen, d.h.
 mit generierten Bildern.
 
\end_layout

\begin_layout Itemize
Aufgrund des iterativen Vorgehens sollte dieser Algorithmus in der Lage
 sein, um Bereiche, in denen keine Blobs gefunden wurden, herumzugehen.
 
\end_layout

\begin_layout Itemize
Wenn ein Quadrat nicht erkannt wurde, wird meist die Diagonale als nächster
 Nachbar gefunden, das für die folgende Erkennung schwerwiegende Folgen
 hat.
 
\end_layout

\begin_layout Itemize
Häufig werden nicht alle Blobs erreicht.
 Somit werden nicht alle Blobs zugeordnet und Informationen verloren.
 
\end_layout

\begin_layout Itemize
Falsch zugeordnete Blobs können unmöglich identifiziert werden.
 Eine solche hat jedoch für die nachfolgende Interpolation schwerwiegende
 Folgen indem sie in einem Bildbereich das mapping komplett zerstört.
 
\end_layout

\begin_layout Paragraph
Verbesserungen
\end_layout

\begin_layout Itemize
Es wird nicht nur eine erwartete Position gespeichert, sondern mehrere.
 
\end_layout

\begin_layout Itemize
Die Position wird nicht bei der Iteration gespeichert, sondern jedes Mal,
 wenn der Blob als Nachbar gefunden wurde.
 
\end_layout

\begin_layout Itemize
Es wird nicht nur in der linken oberen Ecke gestartet, sondern in allen
 vier Ecken.
 
\end_layout

\begin_layout Itemize
Die finale Position wird festgelegt durch Auswahl der Position, die am häufigste
n bestimmt wurde.
 
\end_layout

\begin_layout Itemize
Man hat die Möglichkeit, die Position anhand eines folgenden ähnlichen Bildes
 zu verifizieren.
 Dabei werden zur Verifikation ausserdem die Daten desjenigen Blobs verwendet,
 der den ähnlichsten Schwerpunkt hat und die sich somit entsprechen sollten.
 
\end_layout

\begin_layout Itemize
Es werden nicht mehr die nächsten Nachbarn gesucht, sondern es wird analysiert,
 auf welcher Achse die Blobs liegen und gezielt dort der nächste Blob gesucht.
 So können Diagonal liegende Punkte nicht mehr die Erkennung stören.
 
\end_layout

\begin_layout Paragraph
Weitere Erkenntnisse
\end_layout

\begin_layout Itemize
Die Ergebnisse sind nur wenig besser geworden und genügen den Anforderungen
 noch nicht.
 
\end_layout

\begin_layout Itemize
Die Fehlerkennungen sind auf folgenden Bildern ähnlich, somit bringt die
 Verifikation praktisch nichts.
 
\end_layout

\begin_layout Itemize
Das Debugging, das schon vorher aufwendig und mühsam zurückzuverfolgen war,
 ist jetzt praktisch unmöglich.
 Man kann nicht mehr herausfinden woher gewisse Werte kommen oder den Ablauf
 rekonstruieren.
 
\end_layout

\begin_layout Subsubsection
Nutzung der Interpolation 
\end_layout

\begin_layout Standard
Hierbei wird ausgenutzt, dass man anhand der Interpolation mit den Eckpunkten
 die Bildschirmkoordinaten ungefähr voraussagen kann.
 Es gibt dazu mehrere Möglichkeiten, die im Abschnitt ??? beschrieben werden.
 
\end_layout

\begin_layout Paragraph
Ablauf: 
\end_layout

\begin_layout Enumerate
Man iteriert durch die Blobs und bestimmt zu jedem die Interpolation des
 Schwerpunkts.
 
\end_layout

\begin_layout Enumerate
Es wird überprüft, in welchem Quadrat der Schwerpunkt zu liegen kommt.
 Falls das Quadrat die gleiche Farbe hat, wird die Position als gültig angenomme
n.
 
\end_layout

\begin_layout Paragraph
Erkenntnisse
\end_layout

\begin_layout Itemize
Mit dieser Methode können Abweichungen von +- einem Quadrat erkannt werden.
 
\end_layout

\begin_layout Itemize
Es gibt praktisch keine Fehlerkennungen.
 
\end_layout

\begin_layout Itemize
Durch vergrössern der Quadrate kann die Erkennung verbessert werden.
 
\end_layout

\begin_layout Itemize
Dieses Verfahren ist viel performanter als andere.
 
\end_layout

\begin_layout Itemize
Dieses Verfahren ist von einer guten Interpolation abhängig.
 
\end_layout

\begin_layout Itemize
Wenn dieses jedoch gut ist, erübrigen sich weitere Kalibrationsschritte.
 
\end_layout

\begin_layout Itemize
Mit einem linearen Ansatz werden nur ein kleiner Teil der Blobs korrekt
 erkannt, die meisten bleiben ungültig.
\end_layout

\begin_layout Itemize
Durch Vergrösserung der Quadrate wird die Menge der nutzbaren Daten ebenfalls
 verkleinert.
\end_layout

\begin_layout Itemize
Vereinzelt kommt es mit dem linearen Ansatz zu Fehlerkennungen, die als
 gültig erkannt werden.
 Dies resultiert in schwerwiegenden Fehlern bei kommenden Schritten und
 kann nicht detektiert werden.
\end_layout

\begin_layout Subsubsection
Strahlensatz
\end_layout

\begin_layout Standard
Es wird ein physikalisches Modell mit einer Lochkamera erstellt.
 Durch Anwendung des Strahlensatzes kann ein mapping erstellt werden.
 
\end_layout

\begin_layout Standard
Eine zusätzliche Voraussetzung dafür ist dafür ist, dass die Projektion
 ein rechtwinkliges Dreieck ist.
 Das heisst, dass die Trapezkorrektur des Beamers immer zwingend ausgeführt
 werden muss.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Lochkamera.emf
	lyxscale 30
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Lochkamera Modell
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
K-Means Cluster-zuordnung mit steigender Genauigkeit
\end_layout

\begin_layout Paragraph
Ablauf
\end_layout

\begin_layout Enumerate
Es werden die Eckpunkte des Bildschirms erkannt.
 
\end_layout

\begin_layout Enumerate
Alle Kanten werden in der Mitte geteilt und deren Mittelpunkte visualisiert.
 
\end_layout

\begin_layout Enumerate
Die erkannten Punkte werden mit K-Means zu den erwarteten Werten zugeordnet.
 
\end_layout

\begin_layout Enumerate
Aus dem Ergebnis resultieren weitere Rechtecke, auf denen das Verfahren
 wieder angewandt werden kann.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Clustering.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Ablauf K-Means
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Erkenntnisse 
\end_layout

\begin_layout Itemize
Es ist schwierig die Punkte an den Rändern zu visualisieren und zu erkennen.
 Der Grund dafür liegt darin, dass man nicht über die Kanten des Beamers
 hinaus projizieren kann.
 Die Lösung dafür haben wir erreicht durch Analyse der Kanten der Blobs
 an den Rändern.
 
\end_layout

\begin_layout Itemize
Ein fehlender Punkt könnte aus den anderen interpoliert werden.
 
\end_layout

\begin_layout Itemize
Die Blobs müssen relativ klein projiziert werden, dass die folgenden Schritte
 funktionieren.
 Das erfordert eine genauere Erkennung.
 
\end_layout

\begin_layout Itemize
Fehlerkennungen führen dazu, dass die weiteren Schritte fehlschlagen werden.
 Das ermöglicht eine gute Fehlererkennung.
 
\end_layout

\begin_layout Itemize
Es gibt praktisch keine Fehlerkennungen.
 Stattdessen wird die Erkennung komplett fehlschlagen, auf was besser reagiert
 werden kann.
 
\end_layout

\begin_layout Subsubsection
Open CV Kamerakalibration
\end_layout

\begin_layout Standard
Das OpenCV Framework bietet die Möglichkeit, Webcambilder zu analysieren
 und Schachbrettmuster zu erkennen.
 Anhand von denen wird zu jedem erkannten Muster eine Transformationsmatrix
 erstellt.
 Mit mehreren Erkennungen kann so ein Teil des Bildraums dreidimensional
 erkannt werden.
 
\end_layout

\begin_layout Paragraph
Anwendung
\end_layout

\begin_layout Itemize
Anhand der verschiedenen erkannten Ebenen lassen sich 3d Transformationen
 durchzuführen.
 
\end_layout

\begin_layout Itemize
Die Erkennung klappt nur selten, das ist aber nicht störend, da auch dann
 noch genügend Ebenen vorhanden sind.
 
\end_layout

\begin_layout Itemize
Die Erkennung lässt sich anhand der Parameter nur wenig beeinflussen.
 
\end_layout

\begin_layout Paragraph
Erkenntnisse
\end_layout

\begin_layout Itemize
Die Erkennung hat in meinem Fall nie gekappt.
 
\end_layout

\begin_layout Itemize
Wir brauchen keine 3d Rekonstruktion, nur eine Ebene.
 Dabei nützt uns dieser Algorithmus nur wenig.
 
\end_layout

\begin_layout Itemize
Das Framework ist sehr schlecht dokumentiert.
 
\end_layout

\begin_layout Itemize
Ein umschreiben des Codes auf unsere Anwendung ist viel zu aufwändig aufgrund
 der Komplexität.
 
\end_layout

\begin_layout Itemize
Es gibt abgesehen von offiziellen Codesample praktisch keine Einsatzmöglickeiten.
 
\end_layout

\begin_layout Subsection
Interpolation
\end_layout

\begin_layout Standard
Hierbei geht es darum, wie man anhand der gefundenen Referenzpunkte die
 genauste Interpolation für ein mapping eines Kamerapixels auf eine Bildschirmko
ordinate erhält.
 Diese Verfahren haben wir testweise auch auf die Ecken des erkannten Bildschirm
s angewandt, um die Genauigkeit zu überprüfen.
 
\end_layout

\begin_layout Subsubsection
Lineare Interpolation
\end_layout

\begin_layout Standard
Skizze 
\end_layout

\begin_layout Standard
Hierbei wird ausgenutzt, dass die Verhältnisse der Strecken auf der Abbildung
 identisch bleiben.
 Dies ist in unserem Fall nicht ganz korrekt, da es die perspektivische
 Verzerrung nicht berücksichtigt, was sich nicht schwerwiegend auswirkt,
 jedoch zu einer gewissen Ungenauigkeit führt.
 Nachteile dieses Verfahrens sind zudem, dass in jedem Quadranten des gesuchten
 Punktes ein Punkt gefunden werden muss, die zusammen auf dem Bildschirm
 ein Rechteck bilden.
 Diese Voraussetzung ist für die Eckpunkte gegeben, jedoch ein erschwerender
 Faktor wenn eine unregelmässige Verteilung von Referenzpunkten gegeben
 ist.
 Ausserdem kann dieses Verfahren nur in eine Richtung angewandt werden,
 nämlich von Bildschirmkoordinaten zu Kamerapixeln.
 Dies ist für uns die falsche Richtung, sodass wir alle Werte vorberechnen
 und speichern müssen.
 
\end_layout

\begin_layout Standard
Formel: 
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Lineare Interpolation.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $Ratio_{X}=\frac{Q_{X}}{Screen_{X}}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $Ratio_{Y}=\frac{Q_{Y}}{Screen_{Y}}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $E=A+\overrightarrow{AB}*Ratio_{X}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $F=A+\overrightarrow{AC}*Ratio_{Y}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $G=B+\overrightarrow{BD}*Ratio_{Y}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $H=C+\overrightarrow{CD}*Ratio_{X}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $P=Schnittpunkt(\overrightarrow{EH},\overrightarrow{FG})\Rightarrow$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $A_{EH}x+B_{EH}=C_{EH}\Rightarrow$
\end_inset

 
\begin_inset Formula $A_{EH}=Y_{H}-Y_{E}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $B=X_{E}-X_{H}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $C_{EH}=A_{EH}*X_{E}+B_{EH}*Y_{E}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
Die Berechnung der anderen Koefizienten läuft identisch.
\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $Det=A_{EH}*B_{FG}-A_{FG}*B_{EH}$
\end_inset


\end_layout

\begin_layout Plain Layout
Wenn die Determinante gleich null ist, sind die Linien parallel.
 Diesen Fall können wir aber ausschliessen.
\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $X_{P}=\frac{(B_{FG}*C_{EH}-B_{EH}*C_{FG})}{Det}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $Y_{P}=\frac{(A_{EH}*C_{FG}-A_{FG}*C_{EH})}{Det}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $P=(X_{P}|Y_{P})$
\end_inset

, wenn 
\begin_inset Formula $Det\neq0$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Berechnung der linearen Interpolation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Baryzentrische Koordinaten
\end_layout

\begin_layout Paragraph
Funktionsweise
\end_layout

\begin_layout Standard
Baryzentrische Koordinaten beschreiben in jedem n-Eck n Faktoren, die das
 Flächenverhältnis zwischen den Flächen zwischen den Kanten und einem Punkt
 beschreiben.
 Deren Summe ist immer 1.
 Anhand dieser Faktoren lässt sich sehr einfach ein Rebasing durchführen.
 Das heisst, wenn man Die Punkte in einem anderen System hat, die den Eckpunkten
 im Ursprungssystem entsprechen, kann man die Position des Punktes im Zielsystem
 analysieren.
 Dies ist in unserem Fall bei allen Referenzpunkten gegeben.
 Ein Punkt kann sogar bestimmt werden, wenn er nicht innerhalb des Dreiecks
 liegt.
 Wir werden hier dieses Thema nicht weiter behandeln, es gibt viele andere
 Papers, die dieses Thema sehr ausführlich behandeln.
 
\end_layout

\begin_layout Paragraph
Unsere Anwendung
\end_layout

\begin_layout Standard
Byzantinische Koordinaten berücksichtigen leider keine perspektivischen
 Verzerrungen, wie sie bei uns vorkommen, was deren Funktionalität leider
 etwas einschränkt.
 Somit können wir sie nur verwenden, wenn ein Punkt innerhalb oder zumindest
 in der Nähe liegt.
 Andernfalls gibt es extreme Ungenauigkeiten, die ein Resultat unbrauchbar
 machen.
 Wir definieren die Nähe dadurch, dass alle Faktoren kleiner als 1.5 sein
 müssen.
 Wenn sie kleiner als 1 sind ist der Punkt innerhalb.
 Mit 1.5 darf er zu einer Kante eine Fläche gegen aussen aufspannen, die
 maximal der Hälfte der ganzen Fläche entspricht.
 Das entspricht einen maximalen Abstand der halben Dreieckshöhe zur Kante.
 Da die Nutzung von n-Ecken weder zusätzliche Genauigkeit noch sonstige
 Vorteile bringt, nutzen wir Baryzentrische Koordinaten nur in Dreiecken.
 Durch eine Mittelung der resultierenden Koordinaten anhand mehrerer Dreiecke
 können wir die Störungen der Verzerrung etwas minimieren.
 Wenn wir genügend Referenzpunkte haben, fällt das nicht mehr ins Gewicht.
 
\end_layout

\begin_layout Paragraph
Ergebnisse
\end_layout

\begin_layout Standard
Wenn der Beamer und das Notebook nebeneinander stehen, funktioniert die
 Interpolation anhand der Eckepunkte ziemlich gut.
 Wir haben jedoch hauptsächlich unter erschwerenden Umständen getestet.
 Hier gab es bei der linearen Interpolation gewisse Verschiebungen in horizontal
er Richtung.
 Es entspricht nicht unserer erwünschten Genauigkeit.
 Mit den baryzentrischen Koordinaten anhand der Eckpunkte hatten wir anfangs
 sehr viele Ungenauigkeiten.
 Zudem waren Knicke in den Linien sichtbar über die Diagonale.
 
\end_layout

\begin_layout Standard
Eine Mittelung der Ergebnisse aller vier Dreiecke hat jedoch geholfen, die
 Knicke zu eliminieren und die vertikalen Fehlerfaktoren zu eliminieren.
 Dafür haben wir damit Probleme an den Rändern, da dort unrealistische Werte
 entstehen.
 Zudem sieht man, wie stark sich die Perspektivische Verzerrung auswirkt.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
Y Werte:
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Soll
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
links
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mitte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rechts
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-62
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
86
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
125
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
200
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
150
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
193
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
212
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
264
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
289
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
297
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
400
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
368
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
390
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
391
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
505
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
495
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
479
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
600
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
632
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
594
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
574
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
700
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
761
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
689
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
662
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
768
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
838
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
756
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
700
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
X Werte: 
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="12">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Soll
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
200
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
400
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
600
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
700
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
800
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
900
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1000
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
oben
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
152
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
263
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
382
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
486
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
593
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
686
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
772
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
857
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
939
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1005
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mitte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
148
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
266
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
384
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
494
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
600
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
689
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
780
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
865
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
950
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1023
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unten
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
130
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
265
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
381
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
491
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
600
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
695
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
779
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
870
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
950
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1034
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Genauigkeit baryzentrische Interpolation
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die horizontale Verschiebung ist je nach Versuchsaufbau ähnlich zum linearen
 Ansatz.
 Mir mehr Referenzpunkten lässt sich dieses Problem aber sicher lösen.
 
\end_layout

\begin_layout Paragraph
Kompensation der Verzerrung
\end_layout

\begin_layout Standard
Wenn nur drei oder vier Referenzpunkte für eine Interpolation verwendet
 werden, ist das Resultat in der aufgespannten Fläche korrekt und sollte
 keine Störungen beinhalten.
 Wenn mit diesem Verfahren jedoch eine Linie über mehrere Dreiecke gezogen
 wird, hat diese an jedem Übergang eine neue Richtung.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Knicke in gezeichneten Linien
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das wird von einem Nutzer dadurch wahrgenommen, dass seine gezogene Linie
 nicht gerade ist, sondern Knicke enthält.
 Das wird als störend empfunden.
 
\end_layout

\begin_layout Paragraph
Lösung
\end_layout

\begin_layout Standard
Es wird nicht nur das Resultat eines Vierecks analysiert, sondern direkte
 Nachbarn werden ebenfalls berücksichtigt.
 Durch eine entsprechende Gewichtung sollte das Resultat nicht verfälscht
 werden, aber die Knicke soweit geglättet werden, dass sie den Nutzer nicht
 mehr auffallen.
 Da Baryzentrische Koordinaten leider keine Abstandsfunktion definieren,
 gewichten wir Resultate, die innerhalb liegen doppelt, solche in der Nähe(siehe
 Oben) einfach.
 Anschliessend werden die Werte linear gemittelt.
 So können wir dennoch eine leichte Gewichtung einfügen.
 Erkenntnisse: Interpolation anhand der Eckpunkte: Hierbei ist die Genauigkeit
 identisch mit dem linearen Ansatz, wenn man die vier möglichen Dreiecke
 berücksichtigt und entsprechend gewichtet.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/GewichtungCrop.pdf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Gewichtung der Vierecke
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Interpolation anhand eines feineren Gitters
\end_layout

\begin_layout Standard
Die Anzahl berücksichtigter Dreiecke ist hier sehr wichtig.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
Mittelung von 3 Resultaten:
\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/Cluster3.bmp
	width 70col%

\end_inset


\begin_inset Graphics
	filename Bilder/Calibration/Cluster3Detail.bmp
	width 30col%

\end_inset


\end_layout

\begin_layout Plain Layout
Mittelung von 15 Resultaten:
\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/Cluster15.bmp
	width 70col%

\end_inset


\begin_inset Graphics
	filename Bilder/Calibration/Cluster15Detail.bmp
	width 30col%

\end_inset


\end_layout

\begin_layout Plain Layout
Der Rotanteil der Pixel entspricht den interpolierten X-Werten, der Grünanteil
 den Y-Werten
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Interpolation anhand eines feinen Gitters mit baryzentrischen Dreiecken
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hier sieht man, dass man mit der Mittelung von mehreren Resultaten lokale
 unstimmigkeiten beheben kann.
 Es hat jedoch viele globale Unstimmigkeiten, die nicht korrigiert werden
 können.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/perfBarycentric.eps
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Benötigter Aufwand für baryzentrische Berechnung
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Ausblick: Interpolation anhand Vierecken 
\end_layout

\begin_layout Standard
Durch eine bestimmte Erweiterung der Baryzentrischen Koordinaten auf Vierecke,
 welche den Fakt berücksichtigen, dass die Vierecke nicht winkeltreu sind,
 können wir zudem die Verzerrung an den Übergängen korrigieren.
 
\end_layout

\begin_layout Standard
Formel 
\end_layout

\begin_layout Standard
Durch eine entsprechende Gewichtung kann man zu dem die Knicke so interpolieren,
 dass Knicke an den Kanten geglättet werden.
 Das ist gegeben durch die Möglichkeit, dass wir auch Punkte ausserhalb
 des Rechtecks bestimmen können.
 Diese korrigieren jedoch die perspektivische Verzerrung nicht.
 Diesen Faktor können jedoch mit einem feineren Raster kompensieren.
\end_layout

\begin_layout Subsection
Exkurs: Bewegter Lichtpunkt
\end_layout

\begin_layout Subsection
Versuche zur Umsetzung von Touch
\end_layout

\end_body
\end_document
