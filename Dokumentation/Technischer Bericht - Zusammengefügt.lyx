#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language german-ch
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 0
\use_esint 0
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Stichwortverzeichnis
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Presentation Writer
\end_layout

\begin_layout Author
Renato Bosshart, Josua Schmid
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/Setup/writing.jpg
	lyxscale 20
	width 85col%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Abstract
Es wird eine neue digitale Whiteboard-Technologie beschrieben.
 Während herkömmliche digitale Whiteboards viel Geld kosten, verspricht
 das in dieser Arbeit entwickelte System eine günstige Alternative.
 Es wird gezeigt, dass Standardhardware und einfache Algorithmen mit der
 Genauigkeit von herkömmlichen Produkten konkurrenzieren können.
 Mit einem selbst entwickelten günstigen Stift emuliert die Software 
\begin_inset Quotes gld
\end_inset

Presentation Writer
\begin_inset Quotes grd
\end_inset

 Mausklicks auf einer normalen Beamerleinwand - und das auf 4 Pixel genau.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty} 
\end_layout

\end_inset


\end_layout

\begin_layout Section*
\begin_inset Newpage newpage
\end_inset

Danksagungen
\end_layout

\begin_layout Standard
Die Autoren möchten sich bei Oliver Augenstein für die kompetente und wohlwollen
de Betreuung bedanken.
 Weiteren Dank geht an Benjamin Hug für seine kritischen Kommentare.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Einleitung
\end_layout

\begin_layout Standard
Die in dieser Arbeit entworfenen und in einem Prototyp eingesetzten Algorithmen
 sollen einer Person ermöglichen, interaktive Präsentationen in einem kleinen
 oder mittelgrossen Sitzungszimmer zu halten.
 Die Person kann ihren eigenen Laptop dafür verwenden.
 Der Laptop wird am lokal vorhandenen Beamer angeschlossen.
 Nach einer kurzen Kalibrierung kann die Person die Präsentation starten.
 Dabei schreibt sie falls gewünscht mit einem virtuellen Stift an die Leinwand.
 Das geschriebene wird aufgezeichnet und wieder auf das Beamerbild projiziert.
\end_layout

\begin_layout Paragraph
Aufbau
\end_layout

\begin_layout Standard
In einem normalen Sitzungszimmer soll ein Vortrag gehalten werden können.
 Dazu sollen Standardausstattung wie Laptop, integrierte Kamera und Beamer
 benutzt werden können.
 Als Addendum wird ein spezieller Stift mitgeliefert.
 Der Stift soll günstig sein.
 Der Aufbau unterliegt zu definierenden Beschränkungen wie Winkel und Raumbeleuc
htung.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Aufbau/rendered-perspective.png
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Beispiel eines Aufbaus in der Perspektive
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Kalibrierung
\end_layout

\begin_layout Standard
Bevor ein Stift auf der Leinwand gefunden werden kann, muss die Erkennungssoftwa
re kalibriert werden.
 Dazu werden folgende Schritte vorgenommen:
\end_layout

\begin_layout Itemize
Laptopkamera so ausrichten, dass der ganze Bereich der Leinwand gefilmt
 werden kann
\end_layout

\begin_layout Itemize
Lichtverhältnisse anpassen falls nötig
\end_layout

\begin_layout Itemize
Projiziertes Bild erkennen und ein Mapping von Kamerakoordinaten zu Bildschirmko
ordinaten berechnen
\end_layout

\begin_layout Paragraph
Präsentation
\end_layout

\begin_layout Standard
Nach der erfolgreichen Kalibrierung kann der Benutzer mit einem speziellen
 Stift an die Leinwand zeichnen.
 Vorläufig ist dieser Stift eine einfache weisse LED.
 Die Person muss darauf achten, dass der Stift für die Kamera sichtbar ist.
 Das erfordert Disziplin.
 Deshalb gilt abzuklären, ob und wie das Präsentationssystem akzeptiert
 wird.
 Es ist einem Benutzer vermutlich zumutbar, nur dann schreiben zu können,
 wenn ihn das Publikum sieht.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Problemstellung
\end_layout

\begin_layout Standard
Diese Arbeit stellt sich verschiedenen Herausforderungen.
 Es soll ein günstiger Stift von einer Standardkamera mittels eines Standardbeam
ers gefunden und erkannt werden können.
 Sowohl bei der dazu verwendeten Hardware als auch bei der Art und Weise
 wie die hier entwickelte Software benutzt werden kann, gibt es Einschränkungen.
 Obwohl das erarbeitete Präsentationssystem zum Ziel hat, einschneidende
 Beschränkungen zu vermeiden, gibt es doch verschiedene Grenzen, die von
 Anfang an definiert sind und als nicht überwindbar gelten.
 Grundsätzlich sind sie physischer und physikalischer Art.
 Im Folgenden werden die Probleme kurz diskutiert.
 Für einen besseren Überblick wird zum Teil kurz angeschnitten wie das jeweilige
 Problem gelöst werden soll.
\end_layout

\begin_layout Subsubsection
Aufnahmegerät
\end_layout

\begin_layout Standard
Das in dieser Arbeit verwendete Aufnahmegerät ist eine integrierte Laptopkamera
 eines Thinkpad T430s mit einer Auflösung von 640x480 Pixel à 30 Bilder
 pro Sekunde.
 Sie übertreibt es völlig mit dem automatischen Weissabgleich, hat aber
 einen in den Treiber integrierten Konfigurationsdialog, mit welchem sich
 das Problem manuell minimieren lässt.
 Allgemein formuliert ist an der verwendeten Kamera die Bildauflösung weniger
 wichtig als eine korrekte Belichtung.
 Das liegt daran, dass die präsentierende Person immer in Bewegung ist,
 mal mehr beleuchtet, mal weniger, und somit ein irritierendes Ungleichgewicht
 für die Kamera schafft.
 Übertriebene Änderungen der Beleuchtung seitens der Kamera übertönen den
 Stift.
 Folglich ist er nicht mehr der hellste Punkte der Aufnahme und wird nicht
 mehr erkannt, bzw.
 gefunden.
\end_layout

\begin_layout Paragraph
Beispiel:
\end_layout

\begin_layout Standard
Abbildung 2 zeigt eine Beamerprojektion einer weissen Fläche.
 Der Raum ist wenig abgedunkelt, damit die Kamera welche die Aufnahme gemacht
 hat, einen weniger starken automatischen Weissabgleich vornimmt.
 Nichtsdestotrotz beträgt die Anzahl völlig weisser Pixel in diesem Bild
 mehr als 11'000.
 Das macht es unmöglich, optisch einen hellen Punkt (Stift) zu finden.
 Eine stärker abgedunkelte Umgebung erhöht den Kontrast und somit auch das
 Problem.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Camera/whitebalance.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Überbelichtetes Kamerabild
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Fazit:
\end_layout

\begin_layout Standard
Der automatische Weissabgleich kann über den Hardwaretreiber abgestellt
 werden, erfordert aber einiges an Arbeit (bei Windows schwierig, bei Linux
 einfacher).
 Die verwendeten Geräte müssten genau bekannt sein, um ihre Treiber konfiguriere
n zu können.
 Wahrscheinlich stellt dieser Aufwand ein Hindernis dar, welches man eher
 durch Mitliefern einer eigenen Infrarot-Kamera lösen würde.
 Das hätte den Vorteil, dass sowohl Präsentator als auch Zuschauer nicht
 von sichtbarem Licht abgelenkt würden.
 In dieser Arbeit wird der Einfachheit halber lediglich auf das Finden einer
 von Menschen sichtbaren Lichtquelle eingegangen.
 Es wird angenommen, dass sich alle Konzepte auf nicht sichtbares Licht
 übertragen lassen.
\end_layout

\begin_layout Subsubsection
Präsentationsgerät
\end_layout

\begin_layout Standard
Ein weniger wichtige Rolle als die Kamera spielt der Beamer.
 Weder die Auflösung, noch die Bildwiederholrate spielen eine nennenswerte
 Rolle für die Qualität des Präsentationssystem.
 Die Helligkeitseinstellung ist jedoch wichtig.
 Der in dieser Arbeit verwendete Beamer beleuchtet die Leinwand sehr stark
 und verstärkt dadurch das Problem des automatischen Weissabgleiches der
 Kamera.
 Zur Minimierung des Problems wurde die Helligkeit auf ein schwächeres Niveau
 reduziert.
 Es wurde darauf geachtet, dass die Einstellung als 
\begin_inset Quotes gld
\end_inset

üblich für eine Präsentation
\begin_inset Quotes grd
\end_inset

 wahrgenommen wird.
\end_layout

\begin_layout Subsubsection
Positionierung
\end_layout

\begin_layout Standard
Der Laptop wird so aufgestellt, dass das Sichtfeld der integrierten Kamera
 den Projektionsbereich auf der Leinwand voll umfasst.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Aufbau/wireframe-top.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Beispiel eines Aufbaus von oben
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der Winkel zwischen Projektionsfläche und Laptopkamera hat Auswirkungen
 auf die Genauigkeit des Präsentationssystems.
 Je grösser der Winkel zwischen Kamera und Projektionsfläche ist, desto
 stärker verzerrt nimmt die Kamera das projizierte Bild wahr.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Aufbau/aufbau-verzerrung.png
	lyxscale 50
	width 100col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Leinwand aus drei verschiedenen Blickwinkeln
\begin_inset CommandInset label
LatexCommand label
name "fig:leinwand-verzerrungen"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:leinwand-verzerrungen"

\end_inset

 zeigt die Leinwand aus drei verschiedenen Winkel mit den daraus resultierenden
 einfachen perspektivischen Verzerrungen.
\end_layout

\begin_layout Itemize
Die linke Abbildung zeigt den angenäherten Normalfall: Beamerbild und Laptopkame
ra liegen auf zwei parallelen Ebenen.
 Es wird nur in X-Richtung verzerrt.
 Das Bild ist weder Winkel- noch Flächentreu.
\end_layout

\begin_layout Itemize
In der Mitte ist der Optimalfall dargestellt: Die Kamera sieht direkt von
 vorne auf das Beamerbild, d.h.
 die perspektivische Verzerrung ist minimal.
 Das Bild ist Winkel- und Flächentreu.
\end_layout

\begin_layout Itemize
Rechts ist das Bild in alle Richtungen verzerrt und stellt somit die grössten
 Anforderungen an die Kalibrierung.
 Hierbei ist weder Winkeltreue noch Fläche gegeben.
\end_layout

\begin_layout Standard
Die Kalibrierung kann die perspektivische Verzerrung nur begrenzt ausgleichen.
 Deshalb kann die Position eines Stiftes nicht immer gut oder in allen Bereichen
 der Leinwand gleich gut erfolgen.
 Zur Vereinfachung des zu lösenden Problems wird im Folgenden jeweils angenommen
, dass die perspektivische Verzerrung lediglich auf der Horizontalen (X-Achse)
 der aufgenommenen Bilder verläuft (linke Abbildung).
 Messungen zur Genauigkeit unseres verwendeten Abbildungsverfahrens (s.u.)
 zeigen, dass die Verzerrung auf der Vertikalen (Y-Achse) vernachlässigt
 werden kann.
\end_layout

\begin_layout Subsubsection
Leinwand
\end_layout

\begin_layout Standard
Es ergeben sich Beschränkungen aus dem Untergrund, auf welchen präsentiert
 wird.
 Unebene oder glänzende Texturen sind ungeeignete Projektionsflächen, da
 sowohl Kalibrierung als auch Stifterkennung darunter leiden können.
 Grosse Probleme können Reflexionen der Beamerlampe auf der Leinwand verursachen.
 Dies kann passieren, wenn Beamer und Laptop in einem ungünstigen Winkel
 zueinander stehen.
\end_layout

\begin_layout Subsubsection
Laptop
\end_layout

\begin_layout Standard
Bildverarbeitung braucht in der Regel viel Rechenleistung.
 Die in dieser Arbeit entwickelte Software berücksichtigt dies, indem zum
 Teil Kompromisse eingegangen werden um den Leistungsanforderungen gerecht
 zu werden.
 Um eine reibungslose Erkennung zu gewährleisten, sollten 2GHz Doppelkernprozess
oren oder ähnlich verwendet werden.
\end_layout

\begin_layout Subsubsection
Präsentationsweise
\end_layout

\begin_layout Standard
Da der Stift immer von der Laptopkamera gesehen werden muss, ist es am Präsentat
or, die richtige Haltung beim Schreiben anzunehmen.
 Eine gute Art zu präsentieren ist, wenn das Publikum sieht, wo der Präsentator
 hinzeigt.
 Dies hat den Vorteil hat, dass auch die Laptopkamera sieht, wo auf die
 Leinwand geschrieben werden soll.
 Falls sich der Präsentator zwischen Kamera und Leinwand stellt, kann nicht
 mehr geschrieben werden.
 Da in diesem Fall meist auch das Publikum nichts mehr sieht, wird diese
 Einschränkung ohne weiteren Diskurs in Kauf genommen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Setup/IMGP0366.JPG
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Gute Präsentationsweise - Die zeigende Hand ist von Laptopkamera (links)
 und Publikum aus (rechts) sichtbar.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Ergebnis
\end_layout

\begin_layout Standard
Das Resultat erstaunt.
 Die in dieser Arbeit entwickelte Software 
\begin_inset Quotes gld
\end_inset

Presentation Writer
\begin_inset Quotes grd
\end_inset

 kann gewinnbringend für Vorträge eingesetzt werden.
 Die tiefe Auflösung der Kamera von 640x480 Pixel und die schlechten Lichteigens
chaften haben wenig Einfluss auf die Güte des Resultates.
 Eine erfolgreiche Kalibrierung der Kamera, gute Einstellungen der Bildfilter
 und genügend gute Abbildungsalgorithmen mit Interpolation machen dies möglich.
 Optimierungen wie eine hochauflösende Kamera würden noch genauere und bessere
 Resultate liefern.
 Aus Zeitgründen wurde in der Software zum Teil auf Optimierungen verzichtet.
 Jene die erschlossen wurden, sind jedoch in der schriftlichen Arbeit jeweils
 kurz erwähnt.
\end_layout

\begin_layout Standard
Im Folgenden dieser Arbeit wird genauer darauf eingegangen, wie alle diese
 Zwischenschritte vom Kamerabild bis zum gezeichneten Bildpunkt auf dem
 Beamer analysiert und gelöst wurden.
 Zum einen werden Ideen zum Finden eines Stiftes in einem Kamerabild diskutiert
 zum anderen werden verschiedene Ansätze erarbeitet, die eine näherungsweise
 korrekte Abbildung von Kamera- zu Beamerkoordinaten ermöglichen.
 Im Anhang werden erweiterte oder fehlgeschlagene Ideen genauer erläutert.
 Zudem wird dort auch die Vision vom virtuellen Touchpanel ausgearbeitet,
 eine Idee, die eventuell auch mit einer optischen Kamera, aber ohne Stift
 lösbar ist.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Setup/writing.jpg
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Presentation Writer - Unterstützung bei Vorträgen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Setup/classic-painting.jpg
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Kleines Gekritzel macht Spass - Trotz der tiefen Tracking-Auflösung von
 640x480 Pixel.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Analyse
\end_layout

\begin_layout Standard
Im Folgenden werden Überlegungen zur Beziehung Beamer-Kamera und zu den
 konkreten Eigenschaften eines Stiftes gemacht.
 Es gilt zu analysieren, wie und ob die oben postulierten Probleme gelöst
 werden können.
 Es wird auf Kamerakalibrierung und Bildverarbeitungsschritte eingegangen.
 Dazu werden eigene Algorithmen beschrieben und analysiert.
 Zuerst werden die für die Kamerakalibrierung nötigen oder/und möglichen
 Schritte diskutiert.
 Danach folgt ein Abschnitt über das Finden eines Stiftes in einem Kamerabild.
\end_layout

\begin_layout Paragraph
Begriffe
\end_layout

\begin_layout Standard
Im folgenden wird jeweils von Beamerbild und Kamerabild gesprochen.
 Das Beamerbild beschreibt das ursprüngliche Bild, welches projiziert wird.
 Es besitzt die Auflösung des Beamers.
 Das Kamerabild ist das von der Kamera aufgenommene Bild.
 Es besitzt die Auflösung der Kamera.
 Auf dem Kamerabild ist die Projektion des Beamerbildes verzerrt sichtbar.
 Ein Stift soll auf diesem verzerrten Bild gefunden und auf das rücktransformier
te Beamerbild abgebildet werden.
 Diese Abbildung wird jeweils beschrieben durch 
\begin_inset Formula $\left(x_{Kamera},y_{Kamera}\right)\rightarrow\left(x_{Beamer},y_{Beamer}\right)$
\end_inset

 oder kürzer durch 
\begin_inset Formula $\left(x_{k},y_{k}\right)\rightarrow\left(x_{b},y_{b}\right)$
\end_inset

.
 Die X-Koordinate läuft im Bild von Links nach rechts.
 Die Y-Koordinate läuft von oben nach unten.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/Camera/Transformation/beamer-grid.jpg
	lyxscale 20
	width 85col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Zu projizierendes Beamerbild
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/Camera/Transformation/camera-grid.png
	lyxscale 20
	width 85col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Das Kamerabild enthält das verzerrte Beamerbild.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/Camera/Transformation/backtransformed-grid.png
	lyxscale 20
	width 85col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Das im Kamerabild gefundene und auf die Beamerauflösung rücktransformierte
 entzerrte Beamerbild
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Projizieren und Messen
\end_layout

\begin_layout Standard
Die Lichtverhältnisse sind entscheidend für eine erfolgreiche Messungen.
 Für die Kalibrierung projizierte Referenzbilder haben Einfluss auf den
 automatischen Weissabgleich der Kamera.
 Grosse Helligkeitswerte im projizierten Bild verursachen schnelles Abdunkeln
 des Kamerabildes, tiefe Helligkeitswerte das Gegenteil.
 Es kann nicht genau vorausgesagt werden, wie die Kamera auf Helligkeitsuntersch
iede reagiert.
 In jedem Fall hat dies Einfluss auf in der Kalibrierung verwendete Differenzbil
der.
 Der hier beschriebene Effekt kann minimiert werden, wenn nur Bilder mit
 im Mittel ähnlichen Helligkeitswerten verwendet werden.
 Die schlussendlich eingesetzte Lösung verwendet zwei Schachbrettmuster,
 deren Durchschnittshelligkeiten beinahe gleich sind.
 Die Kamera passt den Weissabgleich kaum an.
 Dies wird unter 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Schachbrett-Differenz"

\end_inset

 genauer beschrieben.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/WhitebalanceFail/frame1.jpg
	lyxscale 20
	width 49.25col%

\end_inset


\begin_inset space \enskip{}
\end_inset


\begin_inset Graphics
	filename Bilder/Calibration/WhitebalanceFail/frame2.jpg
	lyxscale 20
	width 49.25col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Zwei schlecht gewählte Referenzbilder.
 Sie haben zu grosse Helligkeitsunterschiede.
\begin_inset CommandInset label
LatexCommand label
name "fig:diff-fail-pictures"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/WhitebalanceFail/diff.jpg
	lyxscale 40
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Das aus Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:diff-fail-pictures"

\end_inset

 resultierende Differenzbild ist für die Leinwanddetektion kaum brauchbar.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Erkennen von Vierecken
\begin_inset CommandInset label
LatexCommand label
name "sub:Erkennen-von-Vierecken"

\end_inset


\end_layout

\begin_layout Standard
Im folgenden Abschnitt wird beschrieben wie projizierte Rechtecke auf dem
 Kamerabild wiedererkannt werden können.
 Die Grösse ist sehr unterschiedlich, je nach Verfahren von der ganzen Bildschir
mgrösse bis zu wenigen Pixeln auf dem Kamerabild.
 Die Hauptziele dieses Verfahrens sind einerseits Korrektheit als auch Genauigke
it, wobei verschiedene Interpolationsverfahren auch andere Ansprüche haben.
 Die Korrektheit beinhaltet, dass alle Rechtecke erkannt werden und gleichzeitig
 das Rauschen auf ein Mass gesenkt wird, sodass mit Filtern nach Grösse
 und Helligkeitswerte, dass diese klar unterschieden werden können.
 Zudem darf ein Rechteck keinesfalls so aufgeteilt werden, dass es doppelt
 erkannt wird.
 Die Korrektheit ist in diesem Fall die Genauigkeit der Kanten an den Ecken.
 Diese sind relativ wichtig für die genaue Erkennung der Eckpunkte.
 Wenn die Kanten an den Ecken nur leicht abgerundet sind, kann das den resultier
enden Eckpunkt relativ stark beeinflussen.
\end_layout

\begin_layout Subsubsection
Differenzbildansatz
\begin_inset CommandInset label
LatexCommand label
name "sub:Analyse-Differenzbild"

\end_inset


\end_layout

\begin_layout Standard
Bei einem Differenzbild wird auf zwei Bildern für jeden Pixel die Differenz
 gebildet.
 Somit entsteht ein Bild auf dem alle statischen Regionen entfernt sind.
 Dazu gehört zum Beispiel der Hintergrund eines Bildes.
 Er ist eine Region, die sich auf zwei Bilder nicht ändert und darum verschwinde
t.
\end_layout

\begin_layout Paragraph
Eckdetektion mit Differenzbildern
\begin_inset CommandInset label
LatexCommand label
name "par:Analyse-Eigenbau"

\end_inset


\end_layout

\begin_layout Standard
Bei diesem Verfahren werden auf Differenzbildern entlang von diagonalen
 Scanlinien Eckpunkte gesucht und so Rechtecke gefunden.
 Der detaillierte Ablauf ist im Anhang im Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Anhang-Eigenbau"

\end_inset

 genau beschrieben.
 Dieses Verfahren kann auch auf Farbkanäle erweitert werden.
 Es funktioniert relativ gut auf Bildern mit konstanter Belichtungskorrektur
 und stark unterschiedlichen Helligkeitsverteilungen.
 Diese zwei Faktoren sind in der Problemstellung dieser Arbeit nicht positiv
 zu beantworten.
 Deshalb wurde eine Weiterentwicklung dieser Lösung verworfen.
\end_layout

\begin_layout Paragraph
Einfacher Differenzbildansatz
\begin_inset CommandInset label
LatexCommand label
name "par:Analyse-Einfacher-Differenzbildansatz"

\end_inset


\end_layout

\begin_layout Standard
Bei diesen Verfahren wird ein universeller Differenzbild-Hintergrund verwendet.
 Damit kann der statische Hintergrund des Bildes gut entfernt werden und
 es muss nur ein zusätzliches Bild projiziert werden.
 Somit wird nur wenig zusätzliche Zeit für die Kalibrierung benötigt.
 Dieser Ansatz hat dafür Probleme, wenn die Kamera die Belichtungskorrektur
 ändert.
 Dies kommt leider sehr häufig vor, wenn sich die Projektion auf der Leinwand
 selbst ändert.
 Da die Änderung der Folie der Sinn jeder Präsentationssoftware ist, wurde
 dieser Ansatz verworfen.
 Der genaue Ablauf des Verfahrens ist im Anhang 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Anhang-Einfacher-Differenzbild-Kalibrat"

\end_inset

 beschrieben.
\end_layout

\begin_layout Paragraph
Individuelle Differenzbilder
\begin_inset CommandInset label
LatexCommand label
name "par:Individuelle-Differenzbilder"

\end_inset


\end_layout

\begin_layout Standard
Zu jedem Referenzbild, das mit der Kamera gemessen werden soll, werden zwei
 Bilder generiert, deren Differenzbild genau dem gesuchten Bild entspricht.
 Diese Teilbilder müssen eine ähnliche Helligkeitsverteilung aufweisen.
 Das verdoppelt die Kalibrierungszeit dadurch, dass die Zahl der anzuzeigenden
 Bilder verdoppelt wird.
 Das Resultat davon sind sehr gute Differenzbilder, deren Kanten sehr genau
 sind.
 Die Kalibrierungszeit liegt dabei immer noch im Rahmen des zumutbaren.
 Es entspricht insofern der Philosophie 
\begin_inset Quotes gld
\end_inset

Qualität vor Quantität
\begin_inset Quotes grd
\end_inset

 als dass eventuell zusätzlich noch nutzbare Information auf das Wesentliche
 reduziert wird.
\end_layout

\begin_layout Subsubsection
Histogramm-Analyse
\begin_inset CommandInset label
LatexCommand label
name "sub:Histogramm-Analyse"

\end_inset


\end_layout

\begin_layout Standard
Bei der Histogramm-Analyse werden keine Differenzbilder verwendet.
 Stattdessen wird mit den aktuellen Kamerabildern gearbeitet.
 Darauf wird die durchschnittliche Helligkeitsverteilung und die Standartabweich
ung analysiert.
 Alles was heller ist wird akzeptiert.
 Dadurch müssen bei der Kalibration keine zusätzlichen Bilder angezeigt
 werden.
 Analysen haben jedoch gezeigt, dass der Helligkeitsunterschied zwischen
 verschiedenen Bildteilen (z.B.
 oberer und unterer Bildhälfte) viel grösser ist als der Projektionsrand.
 Daraus ist die Idee entstanden, das Bild für die Analyse aufzuteilen.
\end_layout

\begin_layout Paragraph
Optimierung: Histogramm-Analyse auf Bildausschnitten
\end_layout

\begin_layout Standard
Wenn das Bild am Anfang in kleine Ausschnitte aufgeteilt wird, kann der
 Hauptnachteil des obigen Verfahrens eliminiert werden.
 Die Resultate sind relativ gut, mit dem Nachteil, dass keine klaren Kanten
 resultieren, wie dies bei Differenzbildern der Fall ist.
 Eine weitere Konsequenz sind uneinheitliche Übergänge an den Bildausschnitten,
 die jedoch für die Eckdetektion keine Rolle spielen.
 Das Rauschen, welches bei diesem Verfahren relativ stark ist, befindet
 sich zum grössten Teil ausserhalb der Leinwand und kann gut herausgefiltert
 werden.
 Dieses Verfahren funktioniert ziemlich gut, aber die Einschränkung der
 ungenauen Kanten stört relativ stark.
 Genaue Kanten wären wichtig für die Kalibrierung.
\end_layout

\begin_layout Subsection
Kalibrierung: Referenzpunkte
\begin_inset CommandInset label
LatexCommand label
name "sub:Kalibrierung:-Referenzpunkte"

\end_inset


\end_layout

\begin_layout Standard
Der Beginn der Kalibrierung bildet das Finden von Referenzpunkten.
 Diese Punkte bilden die Orientierung für darauf aufbauende Abbildungen.
 Je nach Güte der Abbildung sind mehr oder weniger gemessene Referenzpunkte
 nötig.
 Die Abbildung vom Kamerabild zum ursprünglich projizierten Beamerbild ist
 eine Transformation 
\begin_inset Formula $\left(x_{k},y_{k}\right)\rightarrow\left(x_{b},y_{b}\right)$
\end_inset

 und lässt sich durch eine Transformationsmatrix mit 11 Freiheitsgraden
 korrekt beschreiben
\begin_inset Foot
status open

\begin_layout Plain Layout
3 Translation, 3 Rotation, 2 Kameranullpunkt, 1 Brennweite, 2 Bildskalierung
 
\end_layout

\end_inset

.
 Falls die Brennweite ausser Acht gelassen und mit einer bekannten Bildskalierun
g gearbeitet wird, hat die Transformation lediglich 8 Freiheitsgrade, welche
 durch 4 Messpunkte gebunden werden können.
 Unsere Implementationen der Abbildungsberechnungen verlassen sich jeweils
 auf die vier gemessenen Eckpunkte der Projektion und lassen somit Linseneffekte
 ausser Acht.
 Messungen haben ergeben, dass auftretende Ungenauigkeiten regelmässig sind
 und sich grösstenteils auf die horizontale Achse beschränken.
 Durch eine einfache Korrekturfunktion lassen sich sichtbare Effekte vermeiden.
 4 Referenzpunkte reichen also für das zu entwickelnde Präsentationssystem.
 
\end_layout

\begin_layout Standard
TODO: Bei dieser Arbeit wurden folgende Möglichkeiten, Referenzpunkte zu
 erhalten evaluiert und getestet: Mehr Punkte mehr Interpolation.
 Trapezkorrektur (Algorithmus Beamer).
 Durch Interpolation werden alle ausser Acht gelassenen Verzerrungen und
 Fehler annähernd ausgeglichen.
\end_layout

\begin_layout Subsubsection
Erkennen der Bildschirmgrenze
\end_layout

\begin_layout Standard
Mit dem nachfolgend beschriebenen Verfahren werden lediglich die Ecken des
 Bildschirms erkannt.
 Dafür gibt es mehrere Verfahren, die im nächsten Punkt evaluiert werden.
 Anhand dieser vier Punkte kann die perspektivische Verzerrung schon korrigiert
 werden.
 Aufgrund der Einfachheit, ist dieses Verfahren sehr stabil aund fehlertolerant.
 Ein weiterer Vorteil besteht darin, dass der Benutzter selber verifizieren
 kann, anhand des Kamerabildes, ob die Ecken richtig erkannt wurden.
 Ein Nachteil dieses Verfahrens besteht darin, dass es keine zusätzlichen
 Referenzpunkte gibt, um die Erkennung zu verbessern.
 Dieses Verfahren wurde im Protoryp eingesetzt, da es gute Genauigkeit und
 Fehlertoleranz mitbringt.
 Weitere Refernzpunkte auszunutzen wäre denkbar.
 TODO: gibt es nun mehr Referenzpunkte oder nicht?
\end_layout

\begin_layout Subsubsection
Ordnung kleiner Vierecke
\end_layout

\begin_layout Standard
In den folgenden Algorithmen werden mehrfarbige Schachbrettmuster analysiert.
 Dies hat den Vorteil, dass die Farbkanäle getrennt sind, und so ein Gitter
 mit Quadraten resultiert, die nur einen direkten Nachbarn haben.
 Dieser Ansatz ist im Anhang bei 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Farbmuster"

\end_inset

 noch genauer beschrieben.
 Dieses Verfahren hat keine Gemeinsamkeiten mit dem Schachbrettmuster für
 die Bildschirmdetektion.
\end_layout

\begin_layout Paragraph
Rekursives Traversieren von Vierecken
\end_layout

\begin_layout Standard
Auf einem mehrfarbigen Schachbrettmuster werden Quadrate erkannt.
 Danach können alle Quadrate rekursiv iteriert werden.
 Die Iteration erhält die Struktur eines Baumes.
 Das Verfahren ist in der Theorie sehr stabil und und kann sehr weit angepasst
 werden.
 Der genaue Ablauf dieses Verfahrens ist im Anhang 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Anhang-Rekursiv"

\end_inset

 beschrieben.
 Bei fehlenden Erkennungen kann der Algortihmus sogar um eine Lücke herumgehen.
 Bei Versuchen haben wurde jedoch festgestellt, dass dieses Verfahren sehr
 fehleranfällig ist.
 Es sind nur 90% Korrektheit möglich.
 Verbesserungen lassen sich zwar umsetzten, jedoch führen diese zu einer
 stark erhöhten Komplexität und tragen nur sehr wenig zur Verbesserung bei.
 Weitere Probleme bereiten diesem Algorithmus nicht erkannte Quadrate, da
 dann die Diagolale als direkter Nachbar erkannt wird, was verheerende Folgen
 hat.
 Zudem ist keine Fehlerdetektion möglich.
 TODO: wieso ist keine Fehlerdetektion möglich?
\end_layout

\begin_layout Paragraph
Nutzung der Interpolation
\end_layout

\begin_layout Standard
Hierbei werden die Rechtecke anhand einer Interpolation zu den Eckpunkten
 zugeordnet.
 Dieses Verfahren ist sehr einfach
\begin_inset Foot
status open

\begin_layout Plain Layout
Detailierte Beschreibung im Anhang unter 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Anhang-Nutzung-der-Interpolation"

\end_inset


\end_layout

\end_inset

 und es können Fehler mit einer Abweichung einer halben Seitenlänge eines
 Rechtecks korrigiert und zusätzlich eine ganze Seitenlänge detektiert werden.
 Zudem ist dieser Algorithmus sehr performant.
 Er ist allerdings auch auch von einem guten Interpolationsverfahren abhängig,
 was wiederum Referenzpunkte erübrigt.
 Dieser Algorithmus kann durch eine Vergrösserung der Rechtecke stabilisiert
 werden, was wiederum zu weniger Referenzpunkten führt.
 Mit einem schlechten Interpolationsverfahren kann es zu gravierenden Fehlerkenn
ungen kommen.
 TODO: Wieso referenzpunkte erübrigt? wieso durch Vergrösserung der rechtecke
 stabilisiert?
\end_layout

\begin_layout Subsubsection
K-Means Clustering
\end_layout

\begin_layout Standard
Hiermit werden auf dem Bildschirm immer feiner aufgeteilte Cluster erstellt.
 Dieses Verfahren bietet gute Möglichkeiten zur Fehlerdetektion und liefert
 gute Ergebnisse.
 Bilder und eine detailierte Beschreibung ist im Anhang 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Anhang-K-Means-Cluster"

\end_inset

.
 Mit der Fehlerdetektion können alle üblichen Fehlerkennungen ausgeschlossen
 werden.
 Allerdings ist es ziemlich intolerant gegenüber Fehlerkennungen und stellt
 ziemlich hohe Anforderungen an das Kamerabild.
 Ebenso ist die Anzahl der nutzbaren Referenzpunkte von der Kameraauflösung
 abhängig.
 Dieses Verfahren ist sehr genau und stabil, jdoch stellt es erhöhte Anforderung
en, die dazu führen, dass die Kalibhration nicht immer klappt.
 TODO: Widersprüchlich: kann es jetzt Fehler erkennen oder nicht?!
\end_layout

\begin_layout Subsubsection
OpenCV
\end_layout

\begin_layout Standard
OpenCV bietet die Möglichkeit, anhand verschiedener Aufnahmen eines Referenzbild
es einen ganzen dreidimensionalen Raum zu rekonstruieren.
 Dafür wird für jede erkannte Ebene eine Transformationsmatrix erstellt.
 Jene werden anschliessend so kombiniert dass die resultierende Martix eine
 Rücktransformation auf den Raum erlaubt.
 Da Abbildungen sich in dieser Arbeit jeweils auf eine einzelne Ebene beziehen,
 hätte der OpenCV-Algorithmus stark angepasst werden müssen.
 Dies war uns jedoch aufgrund der enormen Komplexität dieses Codes nicht
 einfach möglich.
 In einem weiteren Versuch wurde mit verschieden Testbildern versucht, einzelne
 Transformationsmatrizen zu erhalten.
 OpenCV hat jedoch zu keinem einzigen Testbild ein Resultat geliefert, obwohl
 die spezifizierten Referenzbilder verwendet wurden.
 Zudem liefert OpenCV keine Fehlerbeschreibungen, die auf die Möglichkeit
 von Anpassungen hingewiesen hätten.
 Ein weiterer Nachteil besteht darin, dass das komplette 600 MB grosse Framework
 mitgeliefert werden müsste, auch wenn nur einen Teil davon verwendet wird.
\end_layout

\begin_layout Subsection
Kalibrierung: Abbildung & Interpolation
\begin_inset CommandInset label
LatexCommand label
name "sub:Analyse-Mapping"

\end_inset


\end_layout

\begin_layout Standard
Um einen Stift zu tracken ist es notwendig, dass im Kamerabild gefundene
 Punkte auf ursprüngliche Punkte im projizierten Bild (Beamerbild) abgebildet
 werden können (
\shape italic
Kamerakoordinaten
\begin_inset Formula $\rightarrow$
\end_inset

Beamerkoordinaten
\shape default
).
 In der Praxis wird dies aufgrund von Beschränkungen wie der tiefen Kameraauflös
ung und der Grösse des Stiftes nicht perfekt möglich sein.
 Es gilt eine Funktion zu finden, welche diese Abbildung möglichst gut annähert.
 Dazu wurden verschiedene Ansätze analysiert, welche im Folgenden beschrieben
 werden.
\end_layout

\begin_layout Subsubsection
Linear
\end_layout

\begin_layout Standard
Der lineare Ansatz berücksichtigt weder perspektivische Verzerrung noch
 Linseneffekte.
 Es wird davon ausgegangen, dass die Verhältnisse der Punkt zu den Ränden
 in beiden Abbildungen identisch sind.
 Wenn keine perspektivische Verzerrung vorhanden ist, funktioniert dieses
 Verfahren korrekt.
 Sonst werden keine Anforderungen an das Bild gestellt.
 Das heisst, dass die Genauigkeit dieses Verfahrens abhängig von der Distanz
 zwischen der Linse des Beamers und der Kamera ist.
 Wenn diese nebeneinanderstehen funktioniert dieses Verfahren sehr gut.
 Bei diesem Verfahren werden nur die Eckpunkte für die Berechnung benötigt.
 Da dieses Verfahren nur in eine Richtung funktioniert, müssen einmalig
 alle möglichen Werte Berechnet werden, dafür sind nacher keine Berechnungen
 mehr nötig, ein einfacher Lookup reicht dafür.
 Die komplette Formel finden sie im Anhang 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Anhang-Lineare-Interpolation"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Lineare Interpolation.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Lineare Interpolation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Problem
\end_layout

\begin_layout Standard
Der lineare Ansatz wird mathematisch durch eine Lochkamera und den Strahlensatz
 beschrieben.
 Der Strahlensatz funktioniert nur, wenn Kamerabild und Leinwand zueinander
 parallel sind.
 Einem üblichen Setup von Beamer und Laptop ist dies nicht der Fall.
 In Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:linear-lochkamera"

\end_inset

 dies ersichtlich.
 Falls Beamer und Kamera nah beieinander stehen, könnte die Genauigkeit
 des linearen Ansatzes reichen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagramme/Lochkamera.emf
	lyxscale 20
	width 70col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Lochkameramodell - Leinwand und Kamerabild sind nicht parallel.
\begin_inset CommandInset label
LatexCommand label
name "fig:linear-lochkamera"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Baryzentrische Koordinaten
\end_layout

\begin_layout Standard
Hierbei werden die Baryzentrischen Koordinaten
\begin_inset Foot
status open

\begin_layout Plain Layout
Baryzentrische Koordinaten sind unter 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Anhang-Baryzentrische-Koordinaten"

\end_inset

 kurz erklärt.
 Ausführliche Literatur zu diesem Thema findet man im Internet oder in einer
 mathematischen Bibliothek
\end_layout

\end_inset

 aus verschiedenen Dreiecken berechnet, zurückgerechnet und anschliessend
 alle Resultate gemittelt.
 Dadurch erhält man eine Genauigkeit, die proportional zur Anzahl Refernzpunkte
 steigt.
 Zuden ist der Algorithmus relativ einfach verständlich und gut testbar.
 Diese Berechnung brücksichtigt allerdings nicht, dass die Abbildung nicht
 Wikeltreu ist, was zu Fehlern führt und zu ungenauigkeiten fürht.
 Für die Mittelung ist leider nur eine begrenzte Gewichtung möglich, da
 keine Abstandsfunktion definiert ist.
 Durch übergänge und die mangelnde Gewichtung erhält man an den Übergängen
 unter Umständen Knicke in geraden Linien, was der4 Benutzer als störend
 empfindet.
 Wenn viele Dreiecke verwendet werden, führt dies zu einer besseren Korrektur
 von lokalen Ungenauigkeiten und etwas sanfteren Übergängen, allerdings
 wird dadurch auch der Rechenaufwand erhöht.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/ProblemBaryzentrisch.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Fehler bei nicht winkeltreuen Abbildungen
\begin_inset CommandInset label
LatexCommand label
name "fig:Fehler-Baryzentrisch"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Optimierung: Baryzentrische Vierecke
\end_layout

\begin_layout Standard
Durch eine eigene Erweiterung der baryzentrischen Koordinaten konnte berücksicht
igt werden, dass Vierecke nicht winkeltreu sind.
 Dies geschieht durch einen vierten Punkt im Koordinatensystem.
 Dies führt zu einer viel genaueren Interpolation.
 Der Algorithmus benötigt jedoch eine strukturierte Ordnung der Referenzpunkte,
 was ihn geringfügig konplizierter macht.
 Allerdings ist durch die Ordnung auch eine Gewichtung möglich.
 Dieser Algorithmus führt zu einem guten Resultat, allerdings stellt er
 hohe Anforderung an die Referenzpunkte.
 Diese Ansprüche können allerdings mithilfe des K-Means Clusterings erfüllt
 werden.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
Es wurde zu den bestehenden Gleichungen der Baryzentrischen Dreiekskoordinaten
 noch eine vierte Gleichung hinzugefügt.
 Diese hat das Ziel, nahe Eckpunkte stärker zu gewichten.
\end_layout

\begin_layout Plain Layout
TL := Obere linke Ecke, TR := obere rechte Ecke, BL := untere linke Ecke,
 BR := untere rechte Ecke
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $P_{X},P_{Y}$
\end_inset

 : zu bestimmender Punkt 
\begin_inset Formula $T_{X},T_{Y}$
\end_inset

: Provisorisches Resultat
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $T=TL*(1-P_{x})*(1-P_{Y})+BL*P_{Y}*(1-P_{X})+TR*(1-P_{Y})*P_{X}+BR*P_{X}*P_{Y}$
\end_inset


\end_layout

\begin_layout Plain Layout
Dies ist jedoch erst ein Zwischenresultat, welches eine Transformation vom
 Beamer zum Kamerabild ermöglicht.
 Um die Berechnung in Richtung Kamerabild → Beamer durchführen zu können,
 muss als weiterer Zwischenschritt die Determinante konstruiert werden:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{equation}
Det\left[\begin{array}{cc}
(1-X)*TL+X*TR-P & (1-X)*BL+X*BR-P\\
(1-Y)*TL+Y*TR-P & (1-Y)*BL+Y*BR-P
\end{array}\right]
\end{equation}

\end_inset


\end_layout

\begin_layout Plain Layout
Daraus resultieren zwei Gleichungen.
 Diese können an den Nullstellen nach X und Y aufgelöst werden:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{equation}
Solve\left(Det\left[\begin{array}{cc}
(1-X)*TL+X*TR-P & (1-X)*BL+X*BR-P\\
(1-Y)*TL+Y*TR-P & (1-Y)*BL+Y*BR-P
\end{array}\right]=0,\{x,y\}\right)
\end{equation}

\end_inset


\end_layout

\begin_layout Plain Layout
Daraus resultieren Gleichungen, anhand derer die Beamerkoordinaten aus Kamerakoo
rdinaten berechnet werden können.
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Erweiterte baryzentrische Koordinaten
\begin_inset CommandInset label
LatexCommand label
name "alg:Erweiterte-baryzentrische-Koordi"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

 Diese Gleichungen funktionieren auch ind er näheren Umgebung ausserhalb
 des Vierecks noch.
\end_layout

\begin_layout Subsubsection
Zweidimensional per Integration
\end_layout

\begin_layout Standard
Der schlussendlich in der Software verwendete Ansatz zur Punktabbildung
 berücksichtigt die perspektivische Verzerrung in X-Richtung.
 Dafür wird ein vereinfachtes zweidimensionales Lochkameramodel verwendet.
 Der leichtere Einstieg bietet die Abbildung von Beamer zu Kamera.
 Die mathematische Umkehrung wird erst nach der nun folgenden Herleitung
 gemacht.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagramme/Mathematik/2d-ansatz-lochkamera.emf
	lyxscale 20
	width 70col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Vereinfachtes Lochkameramodell - Es wird über die Strecke das Beamerbild
 in X-Richtung integriert.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Abbildungsfunktion 
\shape italic
Beamer
\begin_inset Formula $\rightarrow$
\end_inset

Kamera
\shape default
 benutzt die Tatsache, dass Strecken von Beamerbild zu Kamerabild verschieden
 aber herleitbar verschieden verzerrt sind.
 Konkret wird benutzt, dass eine Strecke links auf dem Beamerbild um einen
 Faktor 
\begin_inset Formula $a$
\end_inset

 gestreckt oder gestaucht auf das Kamerabild abgebildet wird.
 Auf der rechten Seite des Beamerbildes ist dies ein anderer Faktor 
\begin_inset Formula $b$
\end_inset

.
 Über die X-Koordinaten des Beamerbildes kann nun ein Integral definiert
 werden, welches diese Abbildung von links nach recht durchläuft und all
 diese Streckungen/Stauchungen indefinitdesimal aufsummiert bis zur Beamerpositi
on 
\begin_inset Formula $x_{b}$
\end_inset

, die gesucht ist.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
x_{k}\left(x_{b}\right)=\intop_{0}^{x}a\left(1-x_{b}\right)+bx_{b}\delta x_{b}=\frac{1}{2}\left(b-a\right)x_{b}^{2}+ax_{b}\label{eq:xk-aus-xb-quadratisch}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Die Mathematische Umkehrfunktion (
\shape italic
Kamera
\begin_inset Formula $\rightarrow$
\end_inset

Beamer
\shape default
) bildet jedes 
\begin_inset Formula $x_{k}$
\end_inset

 auf ein 
\begin_inset Formula $x_{b}$
\end_inset

 ab und ist durch das Lösen der quadratischen Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:xk-aus-xb-quadratisch"

\end_inset

 herleitbar.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
x_{b}\left(x_{k}\right)=\frac{\sqrt{a^{2}+2x_{k}(b-a)}-a}{b-a}\label{eq:xb-aus-xk-quadratisch}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Mathematik/xk-aus-xb-quadratisch.emf
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Graph der Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:xb-aus-xk-quadratisch"

\end_inset

 für 
\begin_inset Formula $a=2$
\end_inset

, 
\begin_inset Formula $b=1$
\end_inset

 (blau): In der Mitte weicht die perspektivische Verzerung in X-Richtung
 mehr vom linearen Ansatz (violett) ab als am Rand.
\begin_inset CommandInset label
LatexCommand label
name "fig:vergleich-persp-verzerr-linquad"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zu beachten gilt, dass der Ursprung des verzerrten Beamerbildes nicht unbedingt
 auf den Ursprung des Kamerabildes zu liegen kommt.
 
\begin_inset Formula $x_{b}$
\end_inset

 und 
\begin_inset Formula $x_{k}$
\end_inset

 müssen also um einen gemessenen Offset angepasst werden, bevor die jeweilige
 Abbildung ausgerechnet wird.
 In der hier beschriebenen Lösung wird nicht der korrekte Offset verwendet
 (Schnittpunkt der zwei zur Gerade verlängerten Abschnitte Kamerabild und
 Beamerbild).
 Es wird jeweils nur der Offset zum Kamerabildanfang verwendet.
 Dies hat zur Folge, dass resultierende X-Koordinaten gleichmässig zu lang
 oder zu kurz sind (je nach Abbildungsrichtung).
 Damit nicht der Schnittpunkt der zwei Ebenen Kamera und Beamer berechnet
 werden muss, wird in dieser Arbeit jeweils die berechnete X-Strecke auf
 die berechnete Maximalstrecke gegenüber der gemessenen Maximalstrecke normiert
 (Stauchung 
\begin_inset Formula $s$
\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
s=\frac{x_{maxmeasure}}{x_{maxcalc}}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Für die Abbildung der Y-Koordinaten wird ein von X abhängiger linearer Ansatz
 verwendet.
 Wieder spielt dabei der Gedanke eine Rolle, dass die rechte und die linke
 Seite des verzerrten Kamerabildes etwa parallel sind.
 
\begin_inset Formula $y_{k}$
\end_inset

 wird durch eine von 
\begin_inset Formula $y_{b}$
\end_inset

 abhängige Gerade definiert - sie wird mit 
\begin_inset Formula $x_{b}$
\end_inset

 durchlaufen.
 Die Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:yk-aus-yb-linear"

\end_inset

 beschreibt die Abbildung 
\shape italic
Beamer
\begin_inset Formula $\rightarrow$
\end_inset

Kamera.
 
\shape default
Dabei beschreibt 
\begin_inset Formula $y_{k0}$
\end_inset

 den vertikalen Offset zwischen linker und rechter Bildlinie.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
y_{k}\left(x_{b}\right)=\left(ay_{b}+y_{k0}\right)\left(1-x_{b}\right)+by_{b}x_{b}\label{eq:yk-aus-yb-linear}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Die Mathematische Umkehrfunktion (
\shape italic
Kamera
\begin_inset Formula $\rightarrow$
\end_inset

Beamer
\shape default
) bildet jedes 
\begin_inset Formula $y_{k}$
\end_inset

 auf ein 
\begin_inset Formula $y_{b}$
\end_inset

 ab und ist mit Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:yb-aus-yk-linear"

\end_inset

 beschrieben.
 Steigung und Offset der Geraden wird dabei durch 
\begin_inset Formula $x_{b}$
\end_inset

 kontrolliert.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
y_{b}\left(y_{k}\right)=\frac{x_{b}y_{k0}+y_{k}-y_{k0}}{a(-x_{b})+a+bx_{b}}\label{eq:yb-aus-yk-linear}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Mathematik/yk-aus-xb-linear.emf
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Sample der Gleichungen 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:yk-aus-yb-linear"

\end_inset

.
 Der gezeigte Ausschnitt bildet genau das verzerrte Beamerbild nach, wobei
 
\begin_inset Formula $x_{b}$
\end_inset

 auf einen Wert zwischen 0 und 1 normiert ist.
 
\begin_inset Formula $y_{k}$
\end_inset

 ist der Pixelwert ind Y-Richtung auf dem Kamerabild.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Mathematik/yb-aus-xk-linear.emf
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Sample der Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:yb-aus-yk-linear"

\end_inset

.
 Werte zwischen 0 und 400 werden auf das Beamerbild rückprojiziert.
 Das Beamerbild wird jedoch nur getroffen, wenn 
\begin_inset Formula $y_{b}$
\end_inset

 zwischen 0 und 1 resultiert.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Beispiel
\end_layout

\begin_layout Standard
Die Güte dieses Ansatzes wurde gemessen.
 Dazu wurde ein Bild an eine Leinwand projiziert und mit einer einfachen
 Laptopkamera aufgenommen.
 Die verzerrten projizierten Punkte des Beamerbildes wurden manuell auf
 dem Kamerabild gemessen und den ursprünglichen Punktpositionen auf dem
 Beamerbild zugewiesen.
 Die gemessenen Punkte des Kamerabildes wurden mit den in den Gleichungen
 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:xb-aus-xk-quadratisch"

\end_inset

 und 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:yb-aus-yk-linear"

\end_inset

 beschriebenen Ansätzen auf Beamerkoordinaten umgerechnet.
 In Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:kamera-messung-berechnung"

\end_inset

 ist das Resultat ersichtlich.
 Die Schräge im rechten Teil der Abbildung rührt davon, dass die linke und
 die rechte Seite des abgebildeten Beamerbildes nicht genau parallel sind.
 Die Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:beamer-rueckrechnung-quadratisch"

\end_inset

 zeigt die Rückberechnung der agebildeten auf die abzubildenden Koordinaten.
 Im Weiteren ist anzumerken, dass als linke und rechte Bildlinien jeweils
 genau senkrecht verlaufende gemittelte Geraden verwendet wurden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Mathematik/quadratische-berechnung-ohne-bary.emf
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Die gemessenen Punkte weichen von den geschätzen (berechneten) ab.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:kamera-messung-berechnung"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Mathematik/quadratische-rueckberechnung-ohne-bary.emf
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Vergleich zwischen Projektion und Berechnung.
 Die Schräge der linken und rechten Bildlinien ergibt Abweichungen.
\begin_inset CommandInset label
LatexCommand label
name "fig:beamer-rueckrechnung-quadratisch"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Baryzentrische Viereck-Korrektur
\end_layout

\begin_layout Standard
Die im Beispiel ersichtlichen Abweichungen lassen sich zumindest an den
 Ecken mit einer baryzentrischen Viereck-Korrektur beheben.
 Dieses Verfahren 
\begin_inset Quotes gld
\end_inset

zieht
\begin_inset Quotes grd
\end_inset

 alle Punkte in Richtung der Referenzpunkte eines vierdimensionalen baryzentrisc
hen Koordinatensystems.
 Das Resultat ist in Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:messung-projektion-mit-bary"

\end_inset

 blau markiert.
 Das Resultat wird an den meisten Orten besser.
 Sehr viel besser wird es an den Rändern.
 Dieses Verfahren kann auch bei der Rückabbildung (
\shape italic
Kamera
\begin_inset Formula $\rightarrow$
\end_inset

Beamer
\shape default
) angewendet werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Mathematik/quadratische-berechnung-mit-bary.emf
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Baryzentrische Korrektur gibt beinahe überall ein besseres Resultat.
\begin_inset CommandInset label
LatexCommand label
name "fig:messung-projektion-mit-bary"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die baryzentrische Vierecks-Korrektur gewichtet die Eckpunkte anhand der
 Position.
 Die genau Berechnung ist unter 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Erweiterte-baryzentrische-Koordi"

\end_inset

 beschrieben.
\end_layout

\begin_layout Paragraph
Pragmatische Korrektur
\end_layout

\begin_layout Standard
Tests in der Praxis haben ergeben, dass nicht nur die perspektivische Verzerrung
 eine Rolle spielt.
 Vorallem wenn der Winkel zwischen Kamera und Beamer vergrössert wird, sind
 systematisch stärkere Abweichungen sichtbar.
 Linseneffekte und Trapezkorrektur des Beamers wurden in dieser Arbeit nicht
 weiter modelliert.
 Stattdessen wird für alle zusätzlichen Abweichungen eine quadratische Korrektur
funktion über die X-Richtung gelegt.
 Sie soll nicht ausgearbeitete Abweichungen symmetrisch ausgleichen.
 Die Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:pragmatische-korrekturfunktion"

\end_inset

 beschreibt die zur Korrektur verwendete Funktion.
 Sie geht durch 0 und 1 und hat ein durch 
\begin_inset Formula $h$
\end_inset

 festgelegtes Maximum bei 0.5.
 Wie 
\begin_inset Formula $h$
\end_inset

 zu wählen ist, hängt von der bei 0.5 zu korrigierenden Abweichung ab.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
y_{corr}\left(x\right)=-4hx^{2}+4hx\label{eq:pragmatische-korrekturfunktion}
\end{equation}

\end_inset


\end_layout

\begin_layout Subsubsection
Homogene Transformation
\end_layout

\begin_layout Standard
Die Abbildung von Punkte zwischen Kamera und Beamer mittels homogener Transforma
tion wurde nur kurz angetestet.
 Eine sauber erarbeitete Transformationsmatrix verspricht sehr genaue Resultate.
 Die für das traditionelle Lochkameramodell benötigte Matrix wird durch
 11 Freiheitsgrade beschrieben
\begin_inset Foot
status open

\begin_layout Plain Layout
3 Translation, 3 Rotation, 2 Kameranullpunkt, 1 Brennweite, 2 Bildskalierung
 
\end_layout

\end_inset

.
 Es reichen also 5.5 gemessene Referenzpunktpaare.
 Da dieses Vorgehen erweiterte mathematische Kenntnisse voraussetzt, wurde
 es nicht genauer untersucht.
 Programmbibliotheken wie OpenCV unterstützen diese Art der Transformation
 nativ und schnell
\begin_inset Foot
status open

\begin_layout Plain Layout
Der interessierte Leser möge folgenden Artikel über die benötigten Transformatio
nsmatrizen konsultieren: http://de.wikipedia.org/wiki/Homogene_Koordinaten
\end_layout

\begin_layout Plain Layout
#Wichtige_elementare_homogene_Transformationsmatrizen
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph
Externe Bibliotheken
\end_layout

\begin_layout Standard
Es gibt die Möglichkeit, eine Kamerakalibration mit vollständiger Transformation
smatrix (11 Freiheitsgrade) mit OpenCV vollautomatisch vornehmen zu lassen.
 Diese Funktionalität konnte mit OpenCV nicht erfolgreich getestet werden.Aufgrun
d dessen wurde schliesslich vollständig auf OpenCV verzichtet.
\end_layout

\begin_layout Subsection
Stift Erkennen
\end_layout

\begin_layout Standard
Als Ziel dieser Arbeit soll ein Stift an einer Leinwand gefunden werden.
 Dies soll das virtuelle Schreiben auf diese Leinwand ermöglichen.
 Da Bildverarbeitung auch heute noch viel Rechenleistung benötigt, gilt
 es genau zu wissen, was man wann und wieso tut.
 Das Finden eines Stiftes besteht aus verschiedenen Teilproblemen, die verschied
en zu lösen sind.
 So sind zum Beispiel Präsenz- und Positionsaspekt des Stiftes zu unterscheiden.
 Es ist teilweise nicht unbedingt notwendig zu wissen, wo der Stift auf
 dem Bild ist.
 Falls es einfach ist, die Präsenz des Stiftes festzustellen, nicht aber
 die Position, kann erstere Information verwendet werden um komplizerte
 und rechenintensive Schritte erst anzustossen wenn nötig.
 Neben den verschiedenen vorzunehmenden Schritten, ist auch Kontextwissen
 wichtig.
 Ein Bild kann gezielter nach Präsenz und Position des Stiftes durchsucht
 werden, wenn bekannt ist, wie er sich zeitlich bewegt.
\end_layout

\begin_layout Subsubsection
Präsenz durch Helligkeit
\end_layout

\begin_layout Standard
Generell ist es nicht einfach, herauszufinden, ob sich ein Objekt in einem
 Bild befindet.
 Ansätze aus der digitalen Bildverarbeitung wie die Diskrete Fourier-Transformat
ion
\begin_inset Foot
status open

\begin_layout Plain Layout
Die Diskrete Fourier-Transformation erhält die Eigenschaften Verschiebung
 und Skalierung in Zeit und Frequenz.
\end_layout

\end_inset

 oder der Gradientenabstieg mittels dynamischer Bildskalierung
\begin_inset Foot
status open

\begin_layout Plain Layout
James MacLean in 
\begin_inset Quotes gld
\end_inset

Fast Pattern Recognition Using Gradient-Descent Search in an Image Pyramid
\begin_inset Quotes grd
\end_inset


\end_layout

\end_inset

 sind kompliziert und benötigen viel Rechenleistung.
 Die Komplexität des Problems wird immens reduziert, wenn die Eigenschaften
 des Stiftes klarer definiert sind.
 Es wäre möglich, Form, Farbe, Helligkeit, Farbtemperatur, Geschwindigkeit,
 Bewegung, Puls, etc.
 auf einem oder mehreren Kamerabilder zu analysieren.
 Der Einfachheit halber wird der Stift auf seine Helligkeit reduziert.
 Er ist der hellste Punkt in einem Bild.
 Zur Umsetzung könnte ein optisches Licht (ev.
 Infrarot) als Stift verwendet werden.
\end_layout

\begin_layout Subsubsection
Präsenz durch Kardinalität
\end_layout

\begin_layout Standard
Der hellste Punkt auf dem Kamerabild bildet den Stift ab.
 Es gibt verschiedene Möglichkeiten den Fall, dass mehrere Spot auftreten,
 zu behandeln.
 
\end_layout

\begin_layout Itemize
Es könnte lediglich der hellste Punkt gewertet werden.
\end_layout

\begin_layout Itemize
Es könnte eine genaue Anzahl Punkte aus dem Kontext gewählt werden.
\end_layout

\begin_layout Itemize
Es könnten alle Punkte verworfen werden.
\end_layout

\begin_layout Standard
Um Fehler zu vermeiden, scheint es sinnvoll, alle undefinierten Zustände
 zu verwerfen, Punkte also nur zu werten, wenn sie alleine in ihrem definierten
 Zustand auftreten.
 Es befindet sich also ein Stift auf dem Kamerabild, wenn ein gewisser Helligkei
tswert überschritten wird.
 Diese Entscheidung ist nur sinnvoll, wenn die Fehlerrate (zu viele Punkte
 erkannt) nicht zu hoch und die Framerate nicht zu tief ist.
\end_layout

\begin_layout Subsubsection
Position durch Schwerpunkt
\end_layout

\begin_layout Standard
Die Position des Stiftes hängt vorzugsweise von der Präsenz eines Stiftes
 ab.
 So muss die Position des Stiftes nur dann gesucht werden wenn er präsent
 ist.
 Dies spart Rechenzeit.
 Die oben beschriebenen Kriterien zur Präsenz ergeben jeweils eine Stiftpräsenz.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/theory/light-point.png
	scale 200

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Stehender Lichtpunkt in der Theorie
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die genaue Position des Stiftes befindet sich in der Mittel am hellsten
 Punkt.
 In der Theorie ist das der Mittelwert aller hellen umgebenden Pixel oder
 der Schwerpunkt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs/frame1.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs/frame2.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs/diff.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Frame x, Frame x+1, Differenz - Der Punkt bewegt sich nach rechts unten.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Messungen zeigen, dass ein bewegter Lichtpunkt in der Praxis nicht rund
 ist, sondern in der Bewegungsrichtung gestaucht.
 Die Stauchung wird durch die Belichtung verursacht.
 In der Bewegungsrichtung erfährt der CCD-Sensor der Kamera eine starke
 Intensitätsänderung, während sich die Intensität am Rand der Laufrichtung
 weniger stark ändert.
 Der CCD trägt der starken Änderung mehr Rechnung als der schwachen.
 Im Weiteren ist die Helligkeit des Lichtpunktes vom Zentrum her nicht weich
 abfallend, sonder eher scharfkantig.
 Dies rührt von Reflexionen auf der dahinter liegenden Leinwand.
\end_layout

\begin_layout Standard
Um der Stabilität Willen wird vorgeschlagen, die Position der Stiftposition
 nicht zu genau zu bestimmen.
 Für eine Anwendung, die lediglich auf eine Leinwand zeichnen kann, sollte
 die Mitte einer Umrandung der hellsten Werte mittels fixem Grenzwert reichen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/theory/light-point - thresholded.png
	scale 200

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Per Grenzwert wird der Lichtpunkt in das Zentrum eines Vierecks gelegt.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Performance durch gezieltes Suchen
\end_layout

\begin_layout Standard
Ein Algorithmus zum Finden der Stiftposition sollte den erarbeiteten Kontext
 berücksichtigen.
 In einem Bild kann zum Beispiel in der Nähe eines im vorherigen Bild gefundenen
 Punktes gesucht werden.
 So reduziert sich der Aufwand des Algorithmus von 
\begin_inset Formula $O\left(cn^{2}\right)$
\end_inset

auf 
\begin_inset Formula $O\left(c\left(\frac{n}{x}\right)^{2}\right)$
\end_inset

wobei 
\begin_inset Formula $x$
\end_inset

 die Seitenlänge 
\begin_inset Formula $n$
\end_inset

 des Kamerabildes in ein kleineres Suchfenster mit Seitenlänge 
\begin_inset Formula $\frac{n}{x}$
\end_inset

 teilt
\begin_inset Foot
status open

\begin_layout Plain Layout
Asymptotisch wird angenommen, dass das Kamerabild quadratisch ist.
\end_layout

\end_inset

.
 Im Fall, dass entweder keine oder keine brauchbaren Kontextinformationen
 vorhanden sind, kann die Suche auf ein grösseres oder das ganze Suchfenster
 ausgeweitet werden.
 Dies erhöht die Worstcase Laufzeit auf 
\begin_inset Formula $O\left(c\left(\frac{n}{x}\right)^{2}+c\left(y\frac{n}{x}\right)^{2}\right)$
\end_inset

, wobei 
\begin_inset Formula $y$
\end_inset

 der Faktor der Vergrösserung ist.
 Es sollte reichen, 
\begin_inset Formula $y:=x$
\end_inset

 zu setzen, wenn das erste Suchfenster gut gewählt ist, da die Wahrscheinlichkei
t gross ist, dass entweder gar kein Punkt gefunden wird oder dass sich der
 Punkte entgegen dem Kontext verhält
\begin_inset Foot
status open

\begin_layout Plain Layout
Dies würde den kontextabhängigen Algorithmus per se unbrauchbar machen.
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Stabilität durch Differenzbilder
\end_layout

\begin_layout Standard
Reduktion des Kontextes muss nicht unbedingt wie oben beschrieben zu Instabilitä
t und mehr Fallunterscheidungen führen.
 Zum Beispiel können relevante Informationen durch Differenzbilder hervorgehoben
 und Rauschen unterdrückt werden.
 Sogar Kriterien, die mit den Eigenschaften eines Stiftes konkurrieren,
 wie zum Beispiel helle statische Reflexionen auf der Leinwand können so
 unterdrückt werden.
 Falls Differenzbilder verwendet werden, müssen weitere Überlegungen zur
 Kardinalität der Lichtpunkte gemacht werden.
 Was nun ein oder zwei resultierende Punkte auf dem Bild bedeuten ist nicht
 ganz klar (s.u.).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/rauschen-small.png
	width 50col%

\end_inset


\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/rauschen-small-diff.png
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Auf dem Differenzbild (rechts) ist der Laserpointer Punkt viel besser sichtbar
 als auf dem Quellbild (links).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Umsetzung
\end_layout

\begin_layout Standard
Im diesem Artikel wird beschrieben, welche Verfahren zur Umsetzung der oben
 beschriebenen Analysen verwendet wurden.
 Zuerst wird auf technische Details wie den Aufbau des Programmes und verwendete
 Biliotheken eingegangen.
 Danach wird erläutert wie die oben beschriebenen Kalibrierungsverfahren
 eingesetzt wurde und wie das Finden eines Stiftes im Softwareprototyp vonstatte
n geht.
 Die Umsetzung der Punktabbildung von Kamera zu Beamer wurde gänzlich ausgelasse
n, da die oben beschriebene Theorie zum Integral-Ansatz genau nach Modell
 eingesetzt werden konnte.
\end_layout

\begin_layout Subsection
Technologien
\end_layout

\begin_layout Subsubsection
Programmiersprache
\end_layout

\begin_layout Standard
Für die Entwicklung der Software wurde die Programmiersprache C# eingesetzt.
 Dies wurde aufgrund der Erfahrung entschieden, dass das .NET-Framework sehr
 pragmatische Ansätze vertritt.
 Jene beschleunigen die Entwicklungszeit und ermöglichen das Nutzen von
 Systemfunktionen wie einer Mausemulation in einfacher Weise.
 In Java wäre das nicht so einfach möglich gewesen.
 C++ hätte die Einbindung von OpenCV zwar erleichtert, aber wesentlich mehr
 Zeit für das Erarbeiten einfachster Konzepte benötigt.
 Die getroffene Entscheidung für C# ist auch hinsichtlich der Portabilität
 des Codes interessant.
 Mit Mono steht auch für Linux eine Ausführungsplattform für die hier entwickelt
e Software zur Verfügung.
\end_layout

\begin_layout Subsubsection
Framework
\end_layout

\begin_layout Standard
Beim Framework für die Bildverarbeitungsroutinen wurde AForge eingesetzt.
 Es ist ein relativ neues Projekt, welches nativ in C# geschrieben und sehr
 gut dokumentiert ist.
 Wie OpenCV ist auch AForge OpenSource.
 Da die Schnelligkeit des Entwicklungsvorgangs im Vordergund stand, wurde
 bewusst auf OpenCV verzichtet.
 Es wurde in Kauf genommen, dass die mit AForge zur Verfügung stehenden
 Algorithmen nicht gleich vielfältig und nicht gleich performant sind.
 Da lediglich ein Prototyp mit den oben beschriebenen Algorithmen umgesetzt
 wurde, scheint dies akzeptabel.
 Für ein Produkt würde wahrscheinlich doch OpenCV benutzt.
\end_layout

\begin_layout Paragraph
OpenCV
\end_layout

\begin_layout Standard
OpenCV ist ein riesiges Produkt, das alle Möglichkeiten zur Bildanalyse
 bietet.
 Es gibt einen Wrapper für C#, jedoch hat sich dieser in Versuchen als nicht
 besonders einfach in der Benutzung herausgestellt.
 Die Dokumentation ist sehr spärlich gehalten.
 Nicht zu unterschätzen ist die grosse Community, die oft weiterhelfen kann.
 
\end_layout

\begin_layout Standard
Der Quellcode ist auf Leistung optimiert und aufgrund dessen wenig verständlich
 und das Anpassen an eigene Bedürfnisse schwierig.
 Ein weiterer Nachteil ist, dass man zur Nutzung das ganze Framework einbinden
 muss, was ca.
 600 MB gross ist.
 Da der Aufwand zur Einarbeitung für zu gross erschient, wurde OpenCV nur
 kurz angetestet und nicht für den Prototyp verwendet.
\end_layout

\begin_layout Paragraph
AForge
\begin_inset CommandInset label
LatexCommand label
name "par:Analyse-AForge"

\end_inset


\end_layout

\begin_layout Standard
AForge funktioniert weniger mathematisch als OpenCV.
 Der pragmatische und einfache Ansatz steht hier vor der akademischen und
 schnellen Lösung.
 AForge bietet leicht benutzbare Filter und eine stabile Blob-Detektion.
 Blobs sind zusammenhängende Pixelhaufen.
 Die Blob-Detektion kann diese über verschiedenen Kriterien in einem Bild
 finden.
 Ein häufig benutztes Kriterium ist die Maximalhelligkeit.
\end_layout

\begin_layout Standard
Die Konfiguration der verwendeten Module ist einfach gehalten und intuitiv.
 Performance und Möglichkeiten sind begrenzt.
 Für einen Prototypen ist die Nutzung von AForge jedoch ideal, da es einfach
 zu benutzen und gut dokumentiert ist.
 Der Code enthält leider immer noch einige Bugs, die jedoch aufgrund der
 guten Verständlichkeit selber behoben werden können.
\end_layout

\begin_layout Subsection
Architektur
\end_layout

\begin_layout Subsubsection
Domain
\end_layout

\begin_layout Standard
Es wurde darauf geachtet, dass alle Komponenten der Software möglichst gut
 austauschbar und erweiterbar sind.
 So werden die zwei Interfaces IPictureProvider und IVisualizer benutzt
 um eine beliebige Schnittstelle von aussen (Input) und nach aussen (Output)
 zu implementieren.
 Ein PictureProvider ist ein beliebiges Device, welches Bilder liefert.
 Dies kann zum Beispiel eine Videokamera oder ein Dateisystemordner sein.
 Ein Visualizer stellt Bilder dar.
 Wo und wie diese Darstellung stattfindet ist für Parsing- und Kalibrierungsalgo
rithmen nicht von Belang - auch nicht wo die Bilder herkommen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Software/PresWriterPackages.emf
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Die Organisation der Klassen berücksichtigt modulare Erweiterungen.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Hauptsequenz
\end_layout

\begin_layout Standard
Der Ablauf des Programmes orientiert sich stark am C# Eventmodell.
 Dabei benachrichtigen sich Komponenten gegenseitig über ihren aktuellen
 Status oder über Berechnungsresultate.
 In dieser Software werden Schnittstellen zwischen Input, Berechnung und
 Output immer über Events abgebildet.
 Dies hat den Vorteil, dass das GoF-Pattern Information Expert gut eingehalten
 werden kann.
 In Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:standardsequenz"

\end_inset

 wird die Kette der Informationsflüsse und Hierarchien als Sequenzdiagramm
 dargestellt.
 Dabei entspricht die Applikation der Hauptapplikation, welche dem Benutzer
 ein GUI bereitstellt und Zugriff auf Kamera und Visualisierung hat.
 Der Folgende Standardablauf wird zum besseren Verständnis der Funktionsweise
 der Software beschrieben:
\end_layout

\begin_layout Enumerate
Zuerst wählt der Benutzer im GUI die Kamera
\end_layout

\begin_deeper
\begin_layout Enumerate
Der Nutzer kriegt eine Auswahl aller gefundenen Kameras und entscheidet
 sich für eine.
 
\end_layout

\begin_layout Enumerate
Anhand der Auswahl wird die Kamera angelegt und gestartet.
\end_layout

\end_deeper
\begin_layout Enumerate
Das Programm sucht einen passenden Visualisierer (WPF, WinForms, Dateisystemabla
ge, etc.) und legt diesen an.
 
\end_layout

\begin_layout Enumerate
Ein DataParser wird angelegt.
 
\end_layout

\begin_layout Enumerate
Die Kalibrierung kann nun automatisch oder nach einer Interaktion des Benutzers
 gestartet werden.
\end_layout

\begin_layout Enumerate
Die Kalibrierung läuft durch und projiziert Messbilder über den Beamer an
 die Leinwand.
 Details dazu sind in Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:ablauf-kalibrierung"

\end_inset

 genauer erläutert.
\end_layout

\begin_layout Enumerate
Falls die Kalibrierung erfolgreich abgeschlossen wird, startet das Pen Tracking.
 Wenn ein Stift auf dem Inputbild gefunden wird, wird das an die Hauptapplikatio
n per Event zurückgemeldet.
 Details über das Finden eines Stiftes finden sich unter Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:umsetzung-stifterkennung"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Software/SSD.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Standardsequenz: Kalibrieren und Punkte auf Kamerabild finden
\begin_inset CommandInset label
LatexCommand label
name "fig:standardsequenz"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Visualisierung
\end_layout

\begin_layout Standard
Für die Kalibrierung ist es notwendig, dass Messmuster auf den Bildschirm
 gezeichnet und mit dem Beamer projiziert werden können.
 In dieser Software wird dies über einen sogenannten Visualisierer realisiert.
 Seine konkrete Implementation ist jeweils seht stark vom verwendeten Betriebsys
tem und dessen Anzeigekonzept abhängig.
 Es ist für die Portabilität sehr wichtig, dass die restliche Software unabhängi
g von der Anzeigemethode ist.
 Dies war zum Teil nicht ganz einfach umzusetzen.
 So ist z.B.
 nicht klar in welcher Umgebung die PenTracking-Library verwendet wird.
 Dies betrifft das Thread-Scheduling und die daraus entstehenden Zeitabstände
 für Kalibrierung und PenTracking.
 Mechanismen wie das Sicherstellen, dass Referenzbilder für die Kalibrierung
 auch wirklich von der Kamera abgefilmt wurden, sind in diesem Prototypen
 zurückgestellt worden und müssten noch beschrieben werden.
\end_layout

\begin_layout Standard
Ebenfalls für die Visualisierung wichtig ist, dass jeweils ein eigenes vom
 restlichen Programm unabhängiges GUI gestartet werden muss.
 Die Verwendung eines Visualisierers soll nicht an das Anzeigekonzept des
 Hauptprogrammes gebunden sein.
 So soll es möglich sein, in einer WPF Applikation einen WinForms-Visualisierer
 einzusetzen und umgekehrt.
 Dies führt aber zu Problemen, wie dass jedes GUI in einem eigenen Thread
 mit ThreadSTA-Attribut laufen muss, oder dass der Garbage Collector den
 zusätzlichen GUI Thread abräumt, obwohl er in Zukunkt noch vom Visualisierer
 verwendet werden müsste.
 
\end_layout

\begin_layout Standard
Im Folgenden wird konkret auf die Vor- und Nachteile der Verwendung von
 Windows Presentation Foundation (WPF) und WinForms eingegangen.
\end_layout

\begin_layout Subsubsection
Umsetzungen
\begin_inset CommandInset label
LatexCommand label
name "sub:Visualisier"

\end_inset


\end_layout

\begin_layout Paragraph
WPF
\end_layout

\begin_layout Standard
Sämtliche Interaktionen mit dem GUI müssen über einen Dispatcher geschehen.
 Andernfalls wird sofort eine Exception geworfen.
 Dadurch ist es möglich, dass parallele Vorgänge im aufrufenden Code sequentiell
 abgearbeitet werden.
 Dies ist unerwünscht aber für GUI-Interaktionen nötig.
 Das Verhalten des WPF-Visualisierers ist abhängig vom Kontext, aus welchem
 er gestartet wurde.
 Hierbei wurden folgende drei Hauptfälle abgedeckt:
\end_layout

\begin_layout Enumerate
Wenn die Hauptapplikation von WPF gestartet wird, ist bereits ein WPF-Applikatio
nsobjekt vorhanden.
 Gemäss Spezifikation darf in diesem Fall kein weiteres erstellt werden.
 Dafür haben alle Threads im Thread-Pool schon das STA-Attribut gesetzt.
 
\end_layout

\begin_layout Enumerate
Die Hauptapplikation wird von Win-Forms gestartet: Hierbei ist kein WPF-Applikat
ionsobjekt vorhanden und muss zwingend erstellt werden, damit ein Fenster
 angezeigt werden kann.
 Ein Teil der Threads hat u.
 U.
 das STA-Attribut.
 Für Threads aus anderen Thread-Pools müssen die Interaktionen in einen
 Thread ausgelagert werden bei welchem dieses Attribut gesetzt ist.
\end_layout

\begin_layout Enumerate
Beim Starten aus einer Konsolenapplikation ist kein WPF-Applikationsobjekt
 vorhanden und muss erstellt werden.
 Da kein Thread das STA-Attribut gesetzt hat, müssen zwingend alle Interaktionen
 in einem neuen Thread abgearbeitet werden bei welchem dieses Attribut gesetzt
 ist.
 Dies ist nötig, da zur Laufzeit keine Thread-Attribute geändert werden
 können.
\end_layout

\begin_layout Standard
Da so bei gewissen Fällen viele zusätzliche Threads erstellt werden müssen
 ist Implementation eines WPF-Visualisierers mit einem gewissen Overhead
 verbunden, der aus der reinen Applikationssicht nicht nötig wäre.
\end_layout

\begin_layout Paragraph
WinForms 
\end_layout

\begin_layout Standard
Mit dem 
\shape italic
AllowUnsafeThreadExecution
\shape default
 Attribut kann die ganze Thread-Security abgeschaltet werden.
 Dafür müssen alle Grafikelemente vor dem Bearbeiten gelockt werden.
 Der aufrufende Code ist verantwortlich dafür, dass die Aufrufreihenfolge
 und der Ablauf stimmt.
 Durch Double-Buffering kann die Performance erhöht werden, wenn mehrere
 Objekte gezeichnet werden.
 Diese Art mit dem GUI zu interagieren widerspricht gängigen Architekturprinzipi
en und sollte nicht in produktivem Code verwendet werden.
\end_layout

\begin_layout Subsection
Kalibrierung
\begin_inset CommandInset label
LatexCommand label
name "sub:ablauf-kalibrierung"

\end_inset


\end_layout

\begin_layout Standard
Für die Kalibrierung wird in dieser Umsetzung der Ansatz mit den individuellen
 Differenzbildern verwendet.
 Es werden damit nur die Ecken des Bildschirms detektiert, welche für den
 gewählten Interpolationsansatz reichen.
\end_layout

\begin_layout Paragraph
Ablauf
\end_layout

\begin_layout Enumerate
Im ersten Bild der Kamera wird die Auflösung erkannt.
 Damit lassen sich nun gewisse Komponenten initialisieren.
 Zudem wird ein Schachbrett mit 
\begin_inset Formula $n\times m$
\end_inset

 Quadraten projiziert.
 Das Verhältnis von 
\begin_inset Formula $n$
\end_inset

 zu 
\begin_inset Formula $m$
\end_inset

 sollte dem Bildschirmverhältnis entsprechen und die Quadrate sollten noch
 gut auf dem Kamerabild sichtbar sein (15-30 Pixel Seitenlänge).
 Diese Werte können problemlos statisch hinterlegt werden.
\end_layout

\begin_layout Enumerate
Das Schachbrett wird erneut projiziert, diesmal mit invertierten Farben.
 Auf dem Differenzbild sollte jetzt die Leinwand klar zu erkennen sein.
 Da an den Kanten der Quadrate Lücken resultieren (diejenigen Pixelreihen,
 die von der Kamera auf beiden Bildern als beleuchtet erkannt hat), müssen
 diese z.B.
 mit einem Gaussfilter mit einer kleinen Kernel-Size eliminiert werden,
 da es sonst bei der Bloberkennung zu Fehlerkennungen kommt.
 Jetzt können die Ecken des Bildschirms sehr genau erkannt werden.
 TODO: was für Lücken meinst du?
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/img01-0-0.jpg
	lyxscale 30
	width 40col%

\end_inset

 
\begin_inset Formula $-$
\end_inset

 
\begin_inset Graphics
	filename Bilder/Calibration/img02-0-0.jpg
	lyxscale 30
	width 40col%

\end_inset

 
\begin_inset Formula $=$
\end_inset

 
\begin_inset Graphics
	filename Bilder/Calibration/diff.png
	width 90col%

\end_inset


\end_layout

\begin_layout Plain Layout
Gaussfilter mit Radius 3, um die Erkennung zu verbessern:
\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/diffblur.png
	width 90col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Erkennung des Bildschirms
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Durch die Bedingung, dass alle Bildschirmecken mindestens 5 Pixel Abstand
 zu jedem Rand haben müssen, können zudem sehr viele Fehlerkennungen herausgefil
tert werden.
\end_layout

\begin_layout Paragraph
Einschränkungen
\end_layout

\begin_layout Standard
Damit die Kalibrierung erfolgreich abgeschlossen werden kann, müssen ein
 paar technische Limitationen eingehalten werden.
 Die Belichtungskorrektur der Kamera reagiert erst etwa ein bis zwei Frames
 später.
 Die zu messende Referenzbilder müssen also länger angezeigt werden.
 In diesem Ansatz wird 500ms
\begin_inset Foot
status open

\begin_layout Plain Layout
empirisch gewählter Wert - ist vom eingesetzten Visualisierer abhängig
\end_layout

\end_inset

 gewartet damit die Darstellung sicherlich gewährleistet ist.
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/Verzögerung1.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/Verzögerung2.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Verzögerung der Darstellung
\end_layout

\end_inset


\end_layout

\end_inset

Gewisse Webcams geben das Bild gespiegelt zurück.
 Deshalb muss dem User die Möglichkeit gegeben werden das Bild zurückzuspiegeln.
 Da Bitmaps in C# sehr inperformant sind, müssen diese am Anfang mit Hilfe
 von Lock-Bits ausgelesen werden und in eine performantere Datenstruktur
 überführt werden, wie z.B.
 Bytearrays.
 Falls sie nochmals benötigt werden, kann man diese mit dem gleichen Verfahren
 zurückschreiben.
 Da dieser Ablauf nicht erkennen kann, wenn ein Teil der Projektion verdeckt
 sein sollte, wird das Resultat dem Benutzer visualisiert, sodass er allenfalls
 die Kalibration nochmals starten könnte.
 TODO: zu zusammenhangslos formuliert.
\end_layout

\begin_layout Paragraph
Parallelität
\end_layout

\begin_layout Standard
Die Kamera produziert regelmässig alle 40ms ein Bild.
 Die Bildverarbeitung für die Kalibrierung benötigt unterschiedlich lange
 Rechenzeit.
 Dies kann zu grossen Problemen führen:
\end_layout

\begin_layout Itemize
Eine sequentielle Bearbeitung der Daten führt dazu, dass mit veralteten
 (und somit falschen) Daten gearbeitet wird.
\end_layout

\begin_layout Itemize
Eine parallele Bearbeitung der jeweils eingehenden Bilder kann zu unkontrolliert
em Spawnen von Tasks führen, die das System verlangsamen und schliesslich
 ein Ablaufen verunmöglichen.
 Falls das Auftritt, gibt es im besten Fall Probleme mit alten Daten, im
 Worst-Case reagiert das System nicht mehr.
\end_layout

\begin_layout Standard
Deshalb wurde entschieden, einen Supervisor einzusetzen, der die Arbeit
 überwacht.
 Dieser entscheidet bei jedem ankommenden Bild, ob ein Worker aus dem Pool
 frei ist.
 Da sich die Kalibrierung nicht parallelisieren lässt, ist in diesem Pool
 nur ein Worker vorhanden.
 Falls er keinen freien Worker findet, verwirft er das Bild.
 Somit ist sichergestellt dass alle Threads aktuelle Daten erhalten und
 das System nicht überlastet werden kann.
\end_layout

\begin_layout Subsubsection
Schachbrett-Differenzbilder
\begin_inset CommandInset label
LatexCommand label
name "sub:Schachbrett-Differenz"

\end_inset


\end_layout

\begin_layout Standard
Um Differenzbilder nutzen zu können, sich aber nicht durch die Belichtungskorrek
tur beeinflussen zu lassen, muss darauf geachtet werden, dass jedes projizierte
 Bild eine identische Helligkeitsverteilung zum Referenzbild besitzt.
 Das bedeutet, dass für jedes Bild, das analysiert werden soll, zwei Bilder
 projiziert werden müssen.
 Da diese Art der Erkennung viel genauer ist und nur ein Referenzbild benütigt
 wird, kann dieser Overhead sicher in Kauf genommen werden.
\end_layout

\begin_layout Subsection
Stifterkennung
\begin_inset CommandInset label
LatexCommand label
name "sub:umsetzung-stifterkennung"

\end_inset


\end_layout

\begin_layout Subsubsection
Verfahren
\end_layout

\begin_layout Standard
Wie oben beschrieben gilt der Ansatz, dass der Stift das hellste sichtbare
 Licht auf dem Kamerabild darstellt.
 Der hellste Punkt sollte also die aktuelle Stiftposition sein.
 Es gibt zwei naheliegende Ansätze um diesen Punkt zu finden.
\end_layout

\begin_layout Itemize
Finde den hellsten Punkt auf dem Bild.
 Das hat Schwächen.
 Insbesondere wenn das Bild viel Rauschen beinhaltet.
\end_layout

\begin_layout Itemize
Finde den hellsten Punkt der sich bewegt.
\end_layout

\begin_layout Standard
In der Software 
\begin_inset Quotes gld
\end_inset

Presentation Writer
\begin_inset Quotes grd
\end_inset

 wird für guten Input den Ansatz ohne Differenzbilder und für schlechten
 Input (wenig Licht, viel Rauschen) den stabileren Ansatz mit Differenzbildern
 verwendet.
\end_layout

\begin_layout Paragraph
Beispiel
\end_layout

\begin_layout Standard
Im folgenden Beispiel wurde der automatische Weissabgleich der Kamera auf
 Rot konzentriert und die Überbeleuchtung drastisch reduziert.
 Resultierend sieht man die hellsten Punkte auf dem Beamerbild.
 Der alleinstehende Punkt im ersten Bild ist ein Laserpointer-Punkt.
 Im zweiten Bild befindet er sich im verrauschten Bereich.
 Den Punkt dort in einem einzelnen Bild per Software zu finden, kann Schwierigke
iten bereiten, da der Laserpunkt nicht der hellste sein muss.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/laser-standalone.png
	lyxscale 50
	width 49.25col%
	BoundingBox 200bp 100bp 450bp 300bp
	clip

\end_inset


\begin_inset space \enskip{}
\end_inset


\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/laser-rauschen.png
	lyxscale 50
	width 49.25col%
	BoundingBox 200bp 100bp 450bp 300bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
1)
\begin_inset space ~
\end_inset

Frame 
\begin_inset Formula $x$
\end_inset

: Der Laserpoint ist gut sichtbar, 2)
\begin_inset space ~
\end_inset

Frame 
\begin_inset Formula $x+c$
\end_inset

: Der Laserpointer ist kaum sichtbar
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Differenzbilder
\end_layout

\begin_layout Standard
Ein stabilerer Ansatz ist, den Lichtpunkt über Differenzbilder zu finden.
 Das Differenzbild filtert helles Rauschen und stehende helle Lichtquellen
 zuverlässiger raus als eine einfache Hell/Dunkel-Schranke.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/laser-diff.png
	lyxscale 50
	width 49.25col%
	BoundingBox 200bp 100bp 450bp 300bp
	clip

\end_inset


\begin_inset space \enskip{}
\end_inset


\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/laser-diffgray.png
	lyxscale 50
	width 49.25col%
	BoundingBox 200bp 100bp 450bp 300bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
1) Differenzbild zweier Frames mit Laserpunkten 2) Nachdem die Rotanteile
 zu Graustufen übersetzt wurden, sieht man die gesuchten Laserpunkte besser.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/laser-diffthreshold.png
	lyxscale 50
	width 49.25col%
	BoundingBox 200bp 100bp 450bp 300bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Nun ergibt ein Hell/Dunkel-Filter (Threshold oder Binarize) gute Anhaltspunkte
 wo sich gesuchte Punkte befinden.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Kardinalität der gefundenen Punkte
\end_layout

\begin_layout Standard
Alle zusammenhängenden hellen Bereiche werden Blobs genannt.
 Diese Blobs repräsentieren Positionen wo sich der Stift im aktuellen und
 im vorherigen Frame befunden hat.
 Es gibt verschiedene Fälle die nach dem Finden der Blobs unterschieden
 werden müssen.
\end_layout

\begin_layout Itemize
Es wurde kein Blob gefunden:
\begin_inset Newline newline
\end_inset

Für die Software ist kein Stift sichtbar.
 Es wird kein Punkt gefunden.
 Dies kann der Fall sein, wenn die präsentierende Person nicht schreibt,
 vor dem Stift steht und der Kamera die Sicht verdeckt oder wenn die Lichtverhäl
tnisse nicht ideal sind und der Stift von der Kamera nicht hell genug wahrgenomm
en wird.
\end_layout

\begin_layout Itemize
Es wurde ein Blob gefunden:
\begin_inset Newline newline
\end_inset

Entweder hat sich der Stift nicht, oder zu wenig bewegt um zwei Blobs zu
 erzeugen oder es handelt sich um eine Fehlerkennung.
 
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-or-two-blobs/frame1.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-or-two-blobs/frame2.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-or-two-blobs/diff.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Frame x, Frame x+1, Differenz
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-blob/frame1.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-blob/frame2.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-blob/diff.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Frame x, Frame x+1, Differenz
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Es wurden zwei Blobs gefunden:
\begin_inset Newline newline
\end_inset

Das ist der gewünschte Fall.
 Beide Punkte bilden gültige Positionen des letzten und des momentanen Frames.
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs/frame1.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs/frame2.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs/diff.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Frame x, Frame x+1, Differenz - Die Punkte gehen 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Es wurden mehr als zwei Blobs gefunden:
\begin_inset Newline newline
\end_inset

TOO: Umformulieren, z.B.
 
\begin_inset Quotes gld
\end_inset

Es ist keine sichere Erkennung möglich und alle Resultate werden verworfen.
\begin_inset Quotes grd
\end_inset

 Ungültig.
 Wird gemüllt.
 Optimierung: Man könnte den hellsten Punkt suchen und als Resultat zurückgeben.
\end_layout

\begin_layout Standard
Generell wird angenommen, dass alle Blobs, falls deren Anzahl zwei oder
 kleiner ist, gültige Stiftpositionen bilden und dass Fehlerkennungen vorher
 gefiltert werden konnten.
 Gute Filter setzen die Eigenschaften eines gültigen Lichtpunktes gut um
 (s.u.).
 
\end_layout

\begin_layout Paragraph
Resultierende Punktposition
\end_layout

\begin_layout Standard
Der Einfachheit halber wird nun das euklidische Zentrum der zwei gefundenen
 Blobs berechnet und als Resultatposition genommen.
 Falls nur ein Punkt gefunden wurde, wird dieser als Resultat gewählt.
 Dieses Verfahren beschränkt den Kontext und damit die Komplexität des Algorithm
us auf das Vorhandensein von genau zwei Bildaufnahmen.
 Es werden weder Geschwindigkeit, noch Vorgängerpunkte vorausgesetzt.
 Ein Nachteil, der dabei in Kauf genommen wird, ist, dass die gefundene
 Punktposition von korrekter Zeit und korrektem Ort abweichen kann.
 Diese Abweichung wird stärker, je schneller sich der Punkt auf der Leinwand
 bewegt.
 Mit Überlegungen aus dem WKS-Abtasttheorem wird aber klar, dass sich dieser
 Effekt nicht sehr stark in der mittleren Erkennungsqualität niederschlägt.
 Die Abtastrate vor und nach der Interpolation ist die gleiche.
 Die Abbildung der zwei gemessenen Punkte auf den Mittelwert resultiert
 in einer Position, die höchstwahrscheinlich gemessen worden wäre, wenn
 mit der doppelten Rate abgetastet worden wäre.
 Diese Behauptung gilt für unbeschleunigte gerade Bewegungen genau und für
 das Schreiben an eine Leinwand bei hoher Abtastrate näherungsweise.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/PenTracking/Interpolation/interpolation-random.png
	width 70col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Zufällig verteilte Punkte (blau) mit grossen Abständen.
 Die Interpolation (violett) taugt nichts.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/PenTracking/Interpolation/interpolation-smoothed.png
	width 70col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Die Interpolation dient als Glättung
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/PenTracking/Interpolation/interpolation-curves.png
	width 70col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Bei genug Punkten bleibt die Ursprungsfigur gut erhalten.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Zeitlich korrekte Punktposition
\end_layout

\begin_layout Standard
Es wäre möglich, die genaue Punktposition zu finden, indem auf dem aktuellen
 Differenzbild der Vorgänger bestimmt wird.
 Im folgenden werden zwei Ansätze diskutiert, wie dies bewerkstelligt werden
 könnte.
 Abbildung 15 zeigt die Situation: Es wurden drei Aufnahmen gemacht, davon
 wiederum zwei Differenzbilder.
 Die zeitliche Abfolge der gefundenen Punkte ist mit den Zahlen 1 bis 3
 gekennzeichnet.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/timed-position/frames1.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/timed-position/frames2.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Zeitliche Abfolge 
\begin_inset Formula $Differenz(Bild_{x},Bild_{x+1})$
\end_inset

 und 
\begin_inset Formula $Differenz(Bild_{x+1},Bild_{x+2})$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der erste Ansatz bezieht sich auf die im Differenzbild per Threshold
\begin_inset Foot
status open

\begin_layout Plain Layout
Helligkeits-Grenzwert
\end_layout

\end_inset

 gefundenen Blobs.
 Die gefundenen Positionen könnten mit dem im vorigen Differenzbild gefundenen
 Punkt verglichen werden.
 Der noch unbekannte Punkt ist der neue resultierende Punkt.
 Im Gegensatz zum oben genannten Interpolationsverfahren wird hier immer
 die aktuelle und richtige Position gefunden.
 Dieses Vorgehen erhöht jedoch die Komplexität des Algorithmus, da zusätzliche
 Fallunterscheidungen gemacht werden müssen.
 So muss separat unterschieden werden, was das Finden eines einzelnen Blobs
 nun bedeutet.
 Ansätze wären den Mittelpunkt oder Schwerpunkt zu berechnen oder genauere
 Analysen im Bild vorzunehmen.
 Man muss sich jedoch bewusst sein, dass Mischen von Interpolation mit Messung
 den Nachteil hat, dass Grössen wie Position und Geschwindigkeit verschwommen
 werden.
 Bei einem einzelnen grossen Blob wäre die Interpolation ungenau und korreliert
 nicht mit den Messinformationen, die aus vorherigen zwei Blobs gewonnen
 wurde.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs-overlay/diff1.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs-overlay/diff2.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs-overlay/diff3.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Problematische Einzelfunde
\end_layout

\end_inset


\end_layout

\end_inset

Tests haben gezeigt, dass das aktuelle Interpolationsverfahren genügend
 genau ist.
 Bei stabilem Input wird ohne Differenzbilder direkt mit dem hellsten Punkt
 gearbeitet.
 Da hat die Interpolation keine negativen Auswirkungen.
\end_layout

\begin_layout Standard
Für gute Kamerabilder (wenig rauschen) wird der Differenzbildansansatz nicht
 verwendet.
 Automatisch sind dann Ort und Zeit eines gefundenen Punktes besser.
\end_layout

\begin_layout Subsubsection
Umsetzung
\end_layout

\begin_layout Standard
Die Umsetzung ist auf die Stabilität des Verfahrens mit Differenzbildern
 ausgerichtet.
 Sie funktioniert bei sehr schwachen Lichtpunkten wie Laserpointern und
 mit viel Rauschen.
 Nichtsdestotrotz wurde schlussendlich im Prototypen wieder auf die einfachere
 Version ohne Differenzbilder umgestellt.
 Bei guten Umgebungsbedingungen, wie guter Sichtbarkeit des Lichts und wenig
 Rauschen benötigt man die Stabilität nicht.
 Zudem wird so Rechenzeit gespart.
\end_layout

\begin_layout Paragraph
Laufzeit
\end_layout

\begin_layout Standard
Falls schon Punkte gefunden wurden, wird zuerst nur ein Bildausschnitt um
 den zuletzt gefundenen Punkt analysiert.
 Im Erfolgsfall spart das Rechenzeit.
 Falls man im Bildausschnitt kein Punkt findet, wird die Suche auf das ganze
 Bild ausgeweitet.
 Im Mittel benötigt man so auf einem Intel Core Duo mit 2Ghz ca.
 4ms pro gefundenem Lichtpunkt.
 Gerade falls die Software auf einem schwächeren Rechner läuft, sollte sicherges
tellt werden, dass der Kamerainput nicht verrauscht ist.
 Dann kann die Punkterkennung ohne Differenzbilder ablaufen und so Rechenleistun
g sparen.
\end_layout

\begin_layout Standard
Als weitere Laufzeitoptimierung wird immer nur ein neuer Thread für den
 Bildverarbeitungsprozess gestartet, wenn kein anderer mehr läuft.
 Dies reduziert zwar die Erkennungsrate auf langsameren Systemen, hat aber
 den Vorteil, dass sich keine Frames aufstauen.
\end_layout

\begin_layout Subsubsection
Einschränkungen
\end_layout

\begin_layout Standard
Die Lichtverhältnisse spielen eine wichtige Rolle.
 Bei jedem Setup müssen die Konfigurationsparameter wieder individuell angepasst
 werden - momentan manuell in einem Treiberdialog von DirectShow.
 Zudem ergeben starke Reflexionen Artefakte im Input, die den Tracking-Algorithm
en stören.
 Gerade in der Phase zwischen Kamerakalibrierung und Reduktion des automatischen
 Weissabgleichs gibt es momentan noch viele Fehlerkennungen.
 Dieses Problem wurde reduziert indem die Grösse des für einen Stift gültigen
 Blob eingeschränkt wurde.
 Die verbleibenden Fehlerkennungen könnten über Heuristiken eliminiert werden.
 So könnte gemessen werden, wie oft ein gefundener Stift in welcher Zeit
 im Bild umherspringt.
 Dafür existiert momentan noch keine Schranke.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/falsepositive.jpg
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Fehlerkennungen bei hellen Reflexionen nach dem Kalibrierungsvorgang
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Wahl des Stiftes
\end_layout

\begin_layout Standard
Die Software 
\begin_inset Quotes gld
\end_inset

Presentation Writer
\begin_inset Quotes grd
\end_inset

 ist schon imstande Laserpointer zu tracken.
 Da dies jedoch nur mit sehr genauer Anpassung der Konfiguration an die
 Helligkeitsbedingungen im Präsentationsraum geht, wurde schlussendlich
 eine LED verwendet.
 Es gibt noch diverse Alternativen, die stattdessen als Stift in Frage kämen.
 Der vielversprechendste ist eine Infrarotlampe.
 Sie könnte über einen 
\begin_inset Formula $\frac{\lambda}{4}$
\end_inset

-Passfilter vor der normalen Kamera oder direkt über ein Infrarotkamera
 getrackt werden.
 Eine Option wäre auch ein Bandpassfilter für eine optische Laserfrequenz.
 Dann könnten herkömmliche Laserpointer (mit der richtigen Farbfrequenz)
 für die Präsentation verwendet werden.
 Lediglich die Filterfolie müsste dann zur 
\begin_inset Quotes gld
\end_inset

Presentation Writer
\begin_inset Quotes grd
\end_inset

 Software mitgeliefert werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/Helium_neon_laser_spectrum.svg
	lyxscale 15
	width 70col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Spektrum eines Helium Neon Lasers.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Input Emulation
\end_layout

\begin_layout Standard
Gemäss Aufgabenstellung war lediglich eine PowerPoint-Integration gefordert.
 Eine komplette Mausemulation kann PowerPoint auch bedienen und bietet noch
 viel mehr Möglichkeiten.
 Zudem haben wurden schon Erfahrungen gesammelt, wie mit C# Mausbefehle
 auf Treiber-Level injiziert werden können.
 Diesen Weg benutzten ebenfalls Devices anderer Hersteller, wie z.B.
 Logitec Presenter.
 Diese emulieren jedoch eine Tastatur, was für diese Arbeit nicht sinnvoll,
 aber optional auch möglich wäre.
 Unter Windows 8 ist es zudem möglich, Touch-Events zu generieren.
 Damit müsste keine Gestenanalyse mehr gemacht werden, da dies dann vom
 Betriebssystem abgenommen wird.
 Da jedoch auch ältere Systeme unterstützt werden sollen, wurde ein Teil
 der Windows 8 Touch-Funktionalität mit Mausbefehlen nachgebildet.
 dazu gehört z.B.
 ein Rechtsklick durch Warten an einem Ort für eine gewisse Zeit.
\end_layout

\begin_layout Standard
Um den Mausinput zu glätten, wurde jeweils über die letzten 6 gefundenen
 Stiftpositionen gemittelt.
 So kann ein grosser Teil des niederfrequenten Rauschens (max.
 4 Pixel um die durchschnittliche Bildschirmposition) beseitigt werden.
 Die resultierende Genauigkeit wirkt dadurch höher als die im Kamerabild
 gemessene.
 Ein Verzögerung durch die Mittelwertbildung wird für den User erst ab einer
 Mittlung über 15 Punkte bemerkbar.
\end_layout

\begin_layout Subsection
Erkenntnisse
\end_layout

\begin_layout Subsubsection*
Kalibrierung
\end_layout

\begin_layout Standard
Die Kalibrierung geht ziemlich schnell vonstatten.
 Es wird ein Button gedrückt, dann werden zwei oder drei Bilder angezeigt
 und schliesslich kann das PenTracking und die Mausemulation aktiviert werden.
 Momentan läuft die Konfiguration der Kamera noch über einen vordefinierten
 Treiber-Dialog ab.
 Dies ist störend und sollte bei einem Produkt irgendwie umgangen werden.
\end_layout

\begin_layout Standard
Die Kalibrierung funktioniert gut bei allen in einem Präsentationsraum üblichen
 Helligkeitswerten und sogar bei unüblichen Abfilmungswinkel (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:schwieriger-abfilmwinkel"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/Genauigkeit/Genauigkeit-3.5m-55grad-source.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Bei einem zu grossen Winkel (hier 55°) wird die Kalibrierung schwieriger
\begin_inset CommandInset label
LatexCommand label
name "fig:schwieriger-abfilmwinkel"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Mapping
\end_layout

\begin_layout Standard
Das Abbilden von Kamerapunkten auf Beamer-punkte geht mit dem Integralansatz
 sehr gut wenn Kamera und Beamer gerade vor der Leinwand stehen.
 Mit zunehmender Schräge wird die Genauigkeit schlechter.
 Aus Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:messung-praxis-0grad"

\end_inset

 ist ersichtlich, dass dieser Ansatz durch die pragmatische Korrekturfunktion
 mehr Abweichung erzeugt als nötig.
 Dies liegt in erster Linie daran, dass diese quadratische Ausgleichsfunktion
 in der Praxis die Länge der seitlichen Bildlinien 
\begin_inset Formula $a$
\end_inset

 und 
\begin_inset Formula $b$
\end_inset

 benutzt anstatt wie in der Theorie beschrieben einen gemessenen Mittelpunkt
 des Bildes.
 Der Parameter 
\begin_inset Formula $h$
\end_inset

 der Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:pragmatische-korrekturfunktion"

\end_inset

 wird im Programmcode durch 
\begin_inset Formula $h=\left(\frac{a}{b}-1\right)\frac{1}{10}$
\end_inset

 umgesetzt.
 In Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:messung-praxis-30grad"

\end_inset

 ist dargestellt, wie gut die Korrekturfunktion bei einem Winkel von 30
 Grad greift.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Statistiken/Genauigkeit/foundpoints-integral-bary-30grad.emf
	lyxscale 20
	width 85col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Baryzentrisch geglätteter Integralansatz: Ausrichtung 0 Grad
\begin_inset CommandInset label
LatexCommand label
name "fig:messung-praxis-0grad"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Statistiken/Genauigkeit/foundpoints-integral-bary-0grad.emf
	lyxscale 20
	width 85col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Baryzentrisch geglätteter Integralansatz: Ausrichtung 30 Grad
\begin_inset CommandInset label
LatexCommand label
name "fig:messung-praxis-30grad"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Generell nicht untersucht wurde, wie sehr sich der Benutzer bewusst ist,
 dass das Lämpchen zur Kamera zeigen muss.
 Die Schräge der Lampe muss der Schräge des Laptops angepasst werden.
 Nur so zeigt die Verlängerung der Lampe in Richtung Leinwand auch auf den
 Punkt, der getroffen werden soll.
 Ab einem Winkel von 45 Grad wird dieser Effekt so stark, dass kaum mehr
 an die gewünschte Position gezeichnet werden kann.
\end_layout

\begin_layout Subsubsection*
Mausemulation
\end_layout

\begin_layout Standard
Der in dieser Arbeit entwickelte Prototyp emuliert eine Maus vollständig.
 Beim Klicken wurde auf eine Interpolation verzichtet.
 Falls geklickt und gezogen wird, greift eine Interpolation mit einer Mittelwert
bildung über die letzten 5 Werte.
 Bei Klicken und Halten wird ein Rechtsklick ausgeführt.
 So kann das ganze Betriebssystem bedient und pixelgenau gezeichnet werden.
 In Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:whiteboard-in-aktion"

\end_inset

 wird Microsoft PowerPoint 2010 mit einer LED-Lampe gesteuert.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Subsubsection*
\begin_inset Graphics
	filename Bilder/Setup/IMGP0387.JPG
	lyxscale 10
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Das Whiteboard in Aktion
\begin_inset CommandInset label
LatexCommand label
name "fig:whiteboard-in-aktion"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Ausblick
\end_layout

\begin_layout Subsection
Kamera & Stift
\end_layout

\begin_layout Standard
Die in dieser Arbeit verwendete Kamera hatte eine kleine Auflösung und einen
 störenden automatischen Weissabgleich.
 Durch Nutzung einer besseren Kamera könnte sowohl die Genauigkeit des Resultate
s als auch die Stabilität des Inputs verbessert werden.
 Es wäre damit möglich, die schon etwas ältere Wacom-Technologie
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.wacom.com/en
\end_layout

\end_inset


\end_layout

\end_inset

 sowohl in Genauigkeit als auch in Reaktionszeit zu übertreffen.
 
\end_layout

\begin_layout Standard
Die Diversität der in handelsüblich verfügbaren Laptops integrierten Kameras
 könnte umgangen werden, wenn eine eigene Kamera mitgeliefert würde.
 Eine Infrarotkamera (mit Infrarot-Stift) wäre dafür von Vorteil.
 Die vorliegenden Algorithmen funktionieren ohne Weiteres auch auf einem
 Infrarotbild - wahrscheinlich zuverlässiger.
 Zudem ist eine Infrarotkamera weniger anfällig auf Störeinflüsse.
 Im Weiteren wäre es nützlich, wenn die Aufnahmeeigenschaften einer eigenen
 Kamera per Software automatisch gesteuert werden könnten.
 
\end_layout

\begin_layout Standard
Weiter optimieren liesse sich die Lichtverteilung des Stiftes.
 Sie ist momentan ziemlich ungleich verteilt.
 Für bessere Resultate würde ein Stift entwickelt, der in alle Richtungen
 die identische Lichtmenge abgibt.
 So ist es nicht mehr von Belang, wie der Benutzter den Stift hält und neuen
 Benutzern wird die Bedienung erleichtert.
\end_layout

\begin_layout Subsection
Kalibrierung
\end_layout

\begin_layout Standard
Für die Kamerakalibrierung gibt es zwei Ansätze, die weiterverfolgt werden
 können um mehr Referenzpunkte zu erhalten.
 Beide können benutzt werden um allfällige Korrekturfaktoren einzuführen
 und die sehr gute Genauigkeit noch weiter zu verbessern.
 Mit einer Kamera, welche automatisch kalibriert werden kann oder einer
 Infrarotkamera mit Farbkanälen für sichtbares Licht könnte die Kalibrierung
 während dem Betrieb laufend überwacht und so ein verrücken der Kamera detektier
t werden.
 Eine komplette oder teilweise
\begin_inset Foot
status open

\begin_layout Plain Layout
Lediglich Anpassung von betroffenen Korrekturfaktoren
\end_layout

\end_inset

 Nachkalibrierung könnte dann in-time gestartet werden.
 Zur Optimierung des Kalibrierungsvorganges gehört auch der Umgang mit Fehlerken
nungen des Pen Tracking.
 Momentan gibt es viele falsch gefundene Stiftfunde direkt nach der Kalibrierung.
 Wenige Anpassungen im Code würden so die Nutzerfreundlichkeit verbessern
 und die Kalibrierungszeit verkürzen.
\end_layout

\begin_layout Standard
Ein Ansatz, der nicht weiter untersucht wurde, ist, dass der Benutzer die
 Kalibrierung komplett selbst vornimmt.
 Dies ist am Vorbild von herkömmlichen Touchpads orientiert.
 Der Benutzer tippt vorgegebene Position am Bildschirm (hier Leinwand) an
 und gibt so dem Kalibrierungssystem den benötigten Referenzinput.
 Der Hauptvorteil wäre die dadurch entfallende Kamerakalibrierung die in
 dieser Arbeit ziemlich aufwändig gestaltet ist.
\end_layout

\begin_layout Subsection
Input Emulation
\end_layout

\begin_layout Standard
Wenn weiterhin ein Betriebssystem mit dem hier entwickelten Präsentationsystem
 bedient werden soll, ist die Injektion von Punktpositionen in den Maustreiber
 die einzige gangbare Möglichkeit.
 Dabei sollte aber darauf geachtet werden, dass relative Mausbewegungen
 gesendet werden, da es sonst mit gewissen Programmen, die Mausinputs auf
 einem sehr tiefen Level verarbeiten, zu Komplikationen kommen kann.
 Dies erfordert jedoch die Möglichkeit, die am PC eingestellte Mausbeschleunigun
g auslesen und Positionen verifizieren zu können, was nur mit grösserem
 Aufwand erreicht werden kann.
\end_layout

\begin_layout Paragraph
Touch
\end_layout

\begin_layout Standard
Mit der Touch-Emulation unter Windows 8 unterstützt die in dieser Arbeit
 entwickelte Software alle von Microsoft implementierten Touch-Gesten.
 In Kombination mit einem Pen Tracker, der mehrere Pens detektieren kann,
 wären auch Multitouch-Gesten möglich.
 Somit könnten theoretisch mehrere Personen gleichzeitig einen PC bedienen.
 Das Nachbilden dieser Funktionalität unter anderen Betriebssystemen wäre
 zwar nicht trivial, aber aus Kompatibilitätsgründen wünschenswert.
 Was ebenfalls in Richtung Touch noch interessant zu untersuchen wäre, ist
 die Unterstützung für Multitouch.
 Es wäre vermutlich mit vertretbarem Aufwand zu realisieren, dass mehrere
 Stifte auf dem Kamerabild simultan erkennt werden können.
 Die native Unterstützung für Multitouch fehlt jedoch den meisten Betriebssystem
en noch.
 Dies würde die Umsetzung erschweren.
\end_layout

\begin_layout Paragraph
Handdetektion
\end_layout

\begin_layout Standard
In Richtung Touch geht auch die Vision, dass heutzutage moderne Systeme
 per Handgesten zu bedienen seien.
 In Anhang 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:touch-umsetzung"

\end_inset

 wird diskutiert, wie dies angegangen werden könnte.
 Dabei wird vor allem auf die noch offenen Probleme eingegangen.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Anhang
\end_layout

\begin_layout Subsection
Kalibrierung: Bilderkennung
\end_layout

\begin_layout Standard
In diesem Kapitel werden die Ansätze zur Bildererkennung, die unter 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Erkennen-von-Vierecken"

\end_inset

 evaluiert wurden, genauer beschrieben.
 Die Beschreibungen entsprechen jeweils den Testimplementierungen davon.
 Diese sind im Sandbox-Projekt zu finden.
 Dies sind alles Ansätze, die im finalen Prototypen nicht mehr vorhanden
 und deshalb nicht fertig ausgearbeitet und nicht gut dokumentiert sind.
 Im folgenden Text wird davon ausgegangen, dass es eine Möglichkeit gibt,
 Rechtecke pixelgenau auf den Bildschirm zu zeichnen, was unter 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Visualisier"

\end_inset

 beschrieben ist.
\end_layout

\begin_layout Paragraph
Allgemeiner Ablauf
\end_layout

\begin_layout Standard
Die Grundüberlegung jedes Ansatzes der Kalibrierung ist derselbe: Im ersten
 Schritt werden die Ecken des Bildschirms gefunden, in den weiteren Schritten
 werden zusätzliche Daten gesammelt die Grundlage für eine immer bessere
 Interpolation bilden zu können.
 Dafür können die im folgenden beschriebenen Ansätze beinahe beliebig kombiniert
 werden.
\end_layout

\begin_layout Subsubsection
Eckdetektion mit Differenzbildern und zufällig verteilten Rechtecken.
\begin_inset CommandInset label
LatexCommand label
name "sub:Anhang-Eigenbau"

\end_inset

 
\end_layout

\begin_layout Standard
In diesem Unterkapitel wird der Ansatz beschrieben, der unter 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:Analyse-Eigenbau"

\end_inset

 evaluiert wurde.
 Deshalb wird hier nicht mehr auf die Analyse eingegangen.
 Bei diesem Ansatz werden keine zusätzlichen Libraries verwendet.
 Da die zu verwendenden Bitmapoperationen nativ (C#) sehr inperformant sind
 wurde eine eigene Bitmapklasse verwendet, welche die Bitmaps zu Bytearrays
 umwandelt.
 Damit können nur Matrizenrechnung und -analysen durchgeführt werden.
\end_layout

\begin_layout Paragraph
Ablauf
\end_layout

\begin_layout Standard
Der genaue Ablauf der Testimplementation wird im Folgenden Schritt für Schritt
 beschrieben.
\end_layout

\begin_layout Enumerate
Der Bildschirm wird Schwarz gemacht.
 Das entsprechende Bild wird gespeichert.
 
\end_layout

\begin_layout Enumerate
Der Bildschirm wird weiss gemacht und das Differenzbild
\begin_inset Foot
status open

\begin_layout Plain Layout
Beschreibung eines Differenzbildes: siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Analyse-Differenzbild"

\end_inset


\end_layout

\end_inset

 gemacht.
 Mit 4 Scanlinien werden von jeder Ecke ausgehend unter 45° ein Punkt gesucht,
 dessen Nachbarn in Richtung der gegenüberliegenden Ecke Liegen eine bestimmte
 Deckung besitzen.
 Es wird ein Quadrat mit Seitenlänge 3-5 Pixel berücksichtigt.
 
\end_layout

\begin_layout Enumerate
Es werden 3 Rechtecke mit zufälligen Eckpunkten gezeichnet und die Eckpunkte
 gespeichert, je eines pro Farbkanal.
 Auf dem Differenzbild zum Ersten werden mit dem gleichen Verfahren zu jedem
 Farbkanal die Ecken gesucht.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Scanlinien.emf
	lyxscale 20
	width 85col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Diagonale Scanlinien finden Eckpunkte
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Verwendung des AForge-Blob-Detctors
\end_layout

\begin_layout Standard
Beim verwendeten Farmework handelt es sich um ein Open-Source Projekt, das
 nativ in C# geschrieben ist.
 Es bietet vile Möglichkeiten zur Bildebearbeitung.
 Eine genaue Analyse des Frameworks ist unter 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:Analyse-AForge"

\end_inset

 beschrieben.
 Das nun beschriebene Verfahren wird in den folgend beschriebenen Lösungen
 immer eingesetzt.
 Dabei werden bei jeder Lösung nur geänderte und wichtige Aspekte erwähnt.
 Funktionierende Teile wurden jeweils in die Hauptlösung übernommen.
 Die verschiedenen Kalibrierungsmethoden im Code sind keine 1:1 Umsetzungen
 der hier beschriebenen Ansätze, sondern Kombinationen davon.
 Der Code von verworfenen Umsetzungen wurde in anderen Umsetzungen teilweise
 übernommen und aktualisiert.
 Diese Aktualisierungen wurden nicht nachgepflegt aus dem Grund, da diese
 Lösungen nicht als sinnvoll für ein Weiterverfolgen erachtet wurden.
\end_layout

\begin_layout Paragraph
Gesuchtes Muster
\end_layout

\begin_layout Standard
Die folgenden Ansätze bilden ein mehrfarbiges Schachbrettmuster ab, das
 nach Farbkanälen aufgeschlüsselt werden kann und somit anhand deren Ecken
 der Rechtecke viele Referenzpunkte liefert.
\end_layout

\begin_layout Subsubsection
Einfache Differenzbild-Kalibration
\begin_inset CommandInset label
LatexCommand label
name "sub:Anhang-Einfacher-Differenzbild-Kalibrat"

\end_inset


\end_layout

\begin_layout Standard
Folgend wird der Ablauf des unter 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:Analyse-Einfacher-Differenzbildansatz"

\end_inset

 analysierten Ansatzes erläutert.
 In der Implementation wird AForge verwendet, jedoch kann dieser Ansatz
 mit jedem Framework implementiert werden.
\end_layout

\begin_layout Paragraph
Ablauf
\end_layout

\begin_layout Enumerate
Als erstes Bild wird der Bildschirm schwarz gefärbt.
 Dieses Bild dient als Grundbild für alle folgenden Differenzbilder.
\end_layout

\begin_layout Enumerate
Der Bildschirm wird komplett weiss gefärbt.
 Auf dem Differenzbild
\begin_inset Foot
status open

\begin_layout Plain Layout
Beschreibung eines Differenzbildes: siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Analyse-Differenzbild"

\end_inset


\end_layout

\end_inset

 wird der grösste Blob gesucht.
 Dieser umfasst dann genau die Ecken des Bildschirms.
 
\end_layout

\begin_layout Enumerate
Es werden grüne und blaue Quadrate jeweils versetzt auf den Bildschirm projizier
t, die bei jedem Frame leicht verschoben werden um mehr Referenzpunkte zu
 bekommen.
 Die Erkennung des roten Farbkanals ist am schlechtesten
\begin_inset Foot
status open

\begin_layout Plain Layout
Wurde empirisch gemessen.
 Wissenschaftliche Messungen über das Erkennen von Farben mit Webcams fehlen
 noch.
\end_layout

\end_inset

, deshalb wird blau und grün verwendet.
 Zwei Farben sind ausreichend, wenn sie mit einem Feld Abstand projiziert
 werden.
 So gibt es keine Nachbarschaftskonflikte bei ihrer Erkennung.
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/bgSchachbrett.png
	width 45text%

\end_inset


\begin_inset Formula $\rightarrow$
\end_inset


\begin_inset Graphics
	filename Bilder/Calibration/Scahcbrett erkannt.png
	width 45text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Schachbrettmuster über zwei Farbkanäle
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Diese Rechtecke werden anschliessend auf dem Kamerabild gesucht.
 Deren Zuordnung geschieht anschliessend mit einem unter 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Kalibrierung:-Referenzpunkte"

\end_inset

 evaluierten Verfahren um die Position zu erhalten.
\end_layout

\begin_layout Subsubsection
Histogrammanalyse
\end_layout

\begin_layout Standard
Im folgend beschriebenen Verfahren werden keine Differenzbilder generiert,
 sondern Helligkeitswerte des Bildes direkt analysiert.
 So können überdurchschnittlich helle Flächen (Projektionen) gefunden werden.
 Die restlichen Bildinformationen werden entfernt um eine Blob-Erkennung
 zu ermöglichen.
 Dieser Algorithmus enthält bereits die im Analyseteil erwähnte Optimierung
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Histogramm-Analyse"

\end_inset

, da er andernfalls ziemlich unbrauchbar ist.
\end_layout

\begin_layout Paragraph
Ablauf
\end_layout

\begin_layout Enumerate
Es wird eine weisse Fläche projiziert.
 Das Bild wird in 
\begin_inset Formula $2\times2$
\end_inset

 gleich grosse Teile aufgeteilt, die jeweils nach überdurchschnittlich hellen
 Regionen gefiltert werden und anschliesend wieder zusammengesetzt werden.
 Darauf wird nun der grösste Blob gesucht.
 Von diesem können nun die Eckpunkte bestimmt werden, welche den Bildschirmecken
 entsprechen.
 TODO: Gut so?
\end_layout

\begin_layout Enumerate
Es werden die grünen und blauen Quadrate aus dem vorherigen Verfahren projiziert.
 Das Bild wird in 
\begin_inset Formula $4\times4$
\end_inset

, oder mehr Teile aufgeteilt und der blaue oder grüne Farbkanal separat
 analysiert.
 Dabei wird alles, was nicht ausserordentlich hell ist, entfernt.
 Danach werden die Bildteile wieeder zusammengesetzt.
 In den zwei zusammengesetzten Bildern werden Blobs erkannt und analysiert.
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/img3.jpg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Erkannte grüne Quadrate
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Erweitertes Differenzbild
\end_layout

\begin_layout Standard
Das nun beschriebene Verfahren setzt das gesuchte Referenzbild aus zwei
 projizierten Bildern mit ähnlicher Helligkeitsverteilung zusammen.
 Seine Analyse wurde unter 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:Individuelle-Differenzbilder"

\end_inset

 beschrieben.
 Der unter 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Schachbrett-Differenz"

\end_inset

 beschriebene Ansatz ist ebenso eine Anwendung dieses Verfahrens.
\end_layout

\begin_layout Paragraph
Ablauf
\end_layout

\begin_layout Enumerate
Es werden jeweils zwei Bilder projiziert, deren Differenz genau das bekannte
 blau-grüne Muster ergibt.
 So können die Rechtecke auf dem Bild ganz scharf und klar erkannt und identifiz
iert werden.
 Durch das Bilden eines weiteren Differenzbildes mit den beiden erwünschten
 Farbkanälen kann das meiste Bildrauschen und allfällige Unsicherheiten
 entfernt werden.
 
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/img03-1-0.jpg
	width 45col%

\end_inset


\begin_inset Formula $-$
\end_inset

 
\begin_inset Graphics
	filename Bilder/Calibration/img03-0-0.jpg
	width 45col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula $=$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/Colordiff.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset Formula $Bild_{1}-Bild_{2}=Schachbrettmuster$
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:Farbmuster"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

Störungen wie sie hier in der oberen linken Ecke vorhanden sind (Kopf einer
 Person) können dadurch entfernt werden, dass sie nicht innerhalb der erkannten
 Bildschirmecken liegen.
\end_layout

\begin_layout Subsection
Kalibrierung: Zuordnung von Punkten
\end_layout

\begin_layout Standard
Der AForge BlobCounter gibt alle auf einem Kamerabild gefundenen Blobs zurück.
 Diese Daten beinhalten Schwerpunkt, Umfassungsrechteck, Fläche, Breite
 und Höhe.
 Diese Detektion könnte aber auch mit einem beliebigen anderen Framework
 durchgeführt werden.
 Anhand dieser gewonnen Positionsdaten wird die Zuordnung gemacht, welcher
 Blob zu welchem projizierten Quadrat gehört.
 Durch eine Filterung mit einer vordefinierten minimalen und maximalen Höhe/Brei
te können die Blobs gefiltert und Rauschen damit entfernt werden.
 Da die Ecken des Bildschirms bekannt sind, kann bestimmt werden, ob ein
 Blob im gültigen Bereich innerhalb liegt, und falls nicht entfernen.
 Somit können 99% der Fehlerkennungen eliminiert werden
\begin_inset Foot
status open

\begin_layout Plain Layout
Empirischer Wert - Eine wissenschaftliche Auswertung liegt nicht vor.
\end_layout

\end_inset

.
 Die Schwerpunkte der Blobs sind mit Koordinaten des Kamerabildes beschrieben,
 was es schwierig macht, deren Position auf dem ursprünglichen Beamerbild
 zu bestimmen.
 Die Verzerrung macht dies schwierig.
 So kann z.B.
 die kleinste X-Koordinate zuunterst liegen und die grösste Y-Koordinate
 rechts oben.
 Je nach Verzerrung ist es so schon sehr schwierig die obere linke Ecke
 zu finden.
 Im Folgenden werden verschiedene Ansätze beschrieben, wie dies trotzdem
 möglich wäre.
\end_layout

\begin_layout Subsubsection
Rekursiv
\begin_inset CommandInset label
LatexCommand label
name "sub:Anhang-Rekursiv"

\end_inset

 
\end_layout

\begin_layout Standard
Beim rekursiven Ansatz wird angenommen, dass die Nachbarn eines Blobs eindeutig
 bestimmt werden können.
 Dies ist möglich anhand ihrer Distanzen, bereitet aber Probleme, wenn gewisse
 Blobs fehlen, da sie nicht erkannt wurden.
 Folglich wird dann ein anderer Blob als Nachbar detektiert, der eigentlich
 keiner ist.
 
\end_layout

\begin_layout Paragraph
Ablauf
\end_layout

\begin_layout Standard
Nun wird der Grundalgorithmus beschrieben.
 Im Analyseteil wurde bereits auf Verbesserungen eingegangen, die auch weiter
 unten erwähnt sind.
\end_layout

\begin_layout Enumerate
Der Algorithmus bestimmt auf jedem Farbkanal denjenigen Blob, der am nächsten
 bei der oberen linken Ecke liegt.
 Durch die Positionsangabe 
\begin_inset Formula $\left(0,0\right)$
\end_inset

 für grün oder 
\begin_inset Formula $\left(1,1\right)$
\end_inset

 als Startwert
\begin_inset Foot
status open

\begin_layout Plain Layout
Der grüne Farbkanal beginnt in der oberen linken Ecke, der blaue ist eine
 Rechteckgrösse versetzt dazu.
\end_layout

\end_inset

 ist bekannt, dass es sich um einen Eckpunkt handelt.
 Der Punkt wird markiert, dass er nicht nochmals bearbeitet werden muss.
\end_layout

\begin_layout Enumerate
Es werden also die zwei nächsten Nachbarn gesucht.
 Anhand der Differenz der Koordinaten kann bestimmt werden, ob der Punkt
 oberhalb (Y-Differenz ist grösser als die Differenz der X-Achse und negativ),
 rechts (X-Differenz ist grösser und positiv), unten oder links liegt.
 
\end_layout

\begin_layout Enumerate
Eine Funktion berechnet die Position, die der gefundene Blob haben muss
 (zwei in die entsprechende Achse verschoben).
 Diese Position kann anhand der Nachbarn bestimmt werden.
 Danach wird ein rekursiver Aufruf auf jedem unmarkierten Nachbar gestartet,
 nachdem der Ausgangspunkt als erledigt markiert wurde.
\end_layout

\begin_layout Enumerate
Der rekursive Aufruf prüft zudem, ob die übergebenen Position plausibel
 erscheint (innerhalb der Projektion liegen kann), oder schon bestimmt wurde
 und bestimmt anhand dieser Position, wie viele Nachbarn zu erwarten sind.
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Rekursion.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Vorgehen beim rekursiven Ansatz
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Verbesserungen
\end_layout

\begin_layout Itemize
Es wird nicht nur eine erwartete Position gespeichert, sondern mehrere.
 
\end_layout

\begin_layout Itemize
Die Position wird nicht bei der Iteration gespeichert, sondern jedes Mal,
 wenn der Blob als Nachbar gefunden wurde.
 
\end_layout

\begin_layout Itemize
Es wird nicht nur in der linken oberen Ecke gestartet, sondern in allen
 vier Ecken.
 
\end_layout

\begin_layout Itemize
Die finale Position wird festgelegt durch Auswahl der Position, die am häufigste
n bestimmt wurde.
 
\end_layout

\begin_layout Itemize
Man hat die Möglichkeit, die Position eines Quadrates anhand eines folgenden
 ähnlichen Bildes zu verifizieren.
 Dabei werden zur Verifikation ausserdem die Daten desjenigen Blobs verwendet,
 der den ähnlichsten Schwerpunkt hat und somit am ehesten demjenigen des
 vorherigen Bildes entspricht.
 TODO: stimmt das so? 
\end_layout

\begin_layout Itemize
Es werden nicht mehr die nächsten Nachbarn gesucht, sondern es wird analysiert,
 auf welcher Achse die Blobs liegen und dort gezielt der nächste Blob gesucht.
 So können diagonal liegende Punkte die Erkennung nicht mehr stören.
 
\end_layout

\begin_layout Subsubsection
Nutzung der Interpolation
\begin_inset CommandInset label
LatexCommand label
name "sub:Anhang-Nutzung-der-Interpolation"

\end_inset

 
\end_layout

\begin_layout Standard
Mit einer Interpolation anhand der bereits gefundenen Eckpunkten des verzerrten
 Beamerbildes können die Positionen der Quadrate besser geschätzt werden.
 Es gibt dazu mehrere Möglichkeiten, die im Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Analyse-Mapping"

\end_inset

evaluiert wurden.
 
\end_layout

\begin_layout Paragraph
Ablauf: 
\end_layout

\begin_layout Enumerate
Man iteriert durch die Blobs und bestimmt zu jedem die Interpolation des
 Schwerpunkts.
 
\end_layout

\begin_layout Enumerate
Es wird überprüft, in welchem Quadrat der Schwerpunkt zu liegen kommt.
 Falls das Quadrat die gleiche Farbe hat, wird die Position als gültig angenomme
n.
 
\end_layout

\begin_layout Subsubsection
K-Means Cluster-Zuordnung mit steigender Genauigkeit
\begin_inset CommandInset label
LatexCommand label
name "sub:Anhang-K-Means-Cluster"

\end_inset


\end_layout

\begin_layout Standard
Bei dem nun folgenden Verfahren wird kein mehrfarbiges Schachbrettmuster
 projiziert, sondern nur diejenigen Rechtecke, welche im aktuellen Schritt
 für die Analyse benötigt werden.
\end_layout

\begin_layout Paragraph
Ablauf
\end_layout

\begin_layout Standard
Dieses Verfahren ist ein mehrstufiges Verfahren, das vom jeweils letzten
 Erkennungsschritt abhängt.
 Dies führt zu einer geringeren Fehlertoleranz.
\end_layout

\begin_layout Enumerate
Es werden die Eckpunkte des Bildschirms erkannt.
 
\end_layout

\begin_layout Enumerate
Alle Kanten werden in der Mitte geteilt und deren Mittelpunkte als Quadrat
 visualisiert.
 
\end_layout

\begin_layout Enumerate
Die erkannten Punkte werden mit K-Means zu den erwarteten Werten zugeordnet.
 
\end_layout

\begin_layout Enumerate
Aus dem Ergebnis resultieren weitere Rechtecke, auf denen das Verfahren
 wieder angewandt werden kann.
 
\end_layout

\begin_layout Standard
In der folgenden Abbildung sind die zwei ersten Schritte abgebildet, danach
 wird das Verfahren auf die erkannten Teilausschnitte wieder angewandt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Clustering.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Ablauf K-Means
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Interpolation
\end_layout

\begin_layout Standard
Interpolationsansätze beschreiben, wie anhand der gefundenen Referenzpunkte
 die genauste Interpolation für ein Mapping eines Kamerapixels auf eine
 Bildschirmkoordinate resultiert.
 Diese Verfahren wurden testweise auch auf die Ecken des erkannten Bildschirms
 angewandt, um die Genauigkeit zu überprüfen.
 
\end_layout

\begin_layout Subsubsection
Lineare Interpolation
\begin_inset CommandInset label
LatexCommand label
name "sub:Anhang-Lineare-Interpolation"

\end_inset


\end_layout

\begin_layout Standard
TODO: Skizze zum Strahlensatz Nicht hier.
\end_layout

\begin_layout Standard
Bei der Umsetzung mittels linearer Interpolation wird ausgenutzt, dass die
 Verhältnisse der Strecken in der Abbildung identisch bleiben.
 Dies ist in unserem Fall nicht ganz korrekt, da die perspektivische Verzerrung
 nicht berücksichtigt wird, was sich nicht schwerwiegend auswirkt, jedoch
 zu einer gewissen Ungenauigkeit führt.
 Nachteile dieses Verfahrens sind zudem, dass in jedem Quadranten des gesuchten
 Punktes ein Punkt gefunden werden muss, der mit anderen zusammen auf dem
 Bildschirm ein Rechteck bildet.
 Diese Voraussetzung ist für die Eckpunkte gegeben, jedoch ein erschwerender
 Faktor wenn eine unregelmässige Verteilung von Referenzpunkten gegeben
 ist.
 Ausserdem kann dieses Verfahren nur in eine Richtung angewandt werden,
 nämlich von Bildschirmkoordinaten zu Kamerapixeln.
 Dies ist die falsche Richtung.
 Bei diesem Vorgehen müssten alle Abbildungswerte vorberechnet und bei Bedarf
 nachgeschaut werden.
 In Algorithmus 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:linearer-ansatz"

\end_inset

 wird das mathematische Vorgehen beschrieben.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Lineare Interpolation.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $Ratio_{X}=\frac{Q_{X}}{Screen_{X}}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $Ratio_{Y}=\frac{Q_{Y}}{Screen_{Y}}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $E=A+\overrightarrow{AB}*Ratio_{X}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $F=A+\overrightarrow{AC}*Ratio_{Y}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $G=B+\overrightarrow{BD}*Ratio_{Y}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $H=C+\overrightarrow{CD}*Ratio_{X}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $P=Schnittpunkt(\overrightarrow{EH},\overrightarrow{FG})\Rightarrow$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $A_{EH}x+B_{EH}=C_{EH}\Rightarrow$
\end_inset

 
\begin_inset Formula $A_{EH}=Y_{H}-Y_{E}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $B=X_{E}-X_{H}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $C_{EH}=A_{EH}*X_{E}+B_{EH}*Y_{E}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
Die Berechnung der anderen Koeffizienten läuft identisch.
\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $Det=A_{EH}*B_{FG}-A_{FG}*B_{EH}$
\end_inset


\end_layout

\begin_layout Plain Layout
Wenn die Determinante gleich null ist, sind die Linien parallel.
 Dieser Fall kann ausgeschlossen werden.
\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $X_{P}=\frac{(B_{FG}*C_{EH}-B_{EH}*C_{FG})}{Det}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $Y_{P}=\frac{(A_{EH}*C_{FG}-A_{FG}*C_{EH})}{Det}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $P=(X_{P}|Y_{P})$
\end_inset

, wenn 
\begin_inset Formula $Det\neq0$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Berechnung der linearen Interpolation
\begin_inset CommandInset label
LatexCommand label
name "alg:linearer-ansatz"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Genauigkeit
\end_layout

\begin_layout Standard
Der lineare Ansatz wurde getestet und seine Genauigkeit gemessen.
 Dazu wurde ein Grid mit 
\begin_inset Formula $\frac{1}{8}$
\end_inset

 Unterteilungen auf die Leinwand projiziert.
 Danach wurden die Positionen am Rand und in der Mitte der X-Achse und der
 Y-Achse entlang mit der LED-Lampe beleuchtet.
 In Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:messung-linearer-ansatz-0grad"

\end_inset

 ist sichtbar, dass der lineare Ansatz ziemlich gut funktioniert, wenn Beamer
 und Laptop mit 0 Grad zueinander ausgerichtet sind.
 In Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:messung-linearer-ansatz-30grad"

\end_inset

 wurde der Winkel zwischen Beamer und Laptop auf 30 Grad erhöht.
 Hier macht sich die perspektivische Verzerrung in X-Richtung bemerkbar.
 Strecken werden zu lang abgebildet
\begin_inset Foot
status open

\begin_layout Plain Layout
Interessant ist, dass die oben in Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:vergleich-persp-verzerr-linquad"

\end_inset

 festgestellte Abweichung vom linearen Ansatz in dieser Messung sichtbar
 gut ist.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Die Umsetzung des Ansatzes bildet alle Punkte ausserhalb der Projektion
 auf den Punkt 
\begin_inset Formula $\left(0,0\right)$
\end_inset

 ab.
 Da alle am Rand unten gemessenen Punkte ein bisschen ausserhalb liegen,
 sind sie in den Messabbildungen nur als Häufung um 
\begin_inset Formula $\left(0,0\right)$
\end_inset

 sichtbar.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Statistiken/Genauigkeit/foundpoints-linear-0grad.emf
	lyxscale 20
	width 85col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Ausrichtung Beamer-Laptop: 0 Grad
\begin_inset CommandInset label
LatexCommand label
name "fig:messung-linearer-ansatz-0grad"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Statistiken/Genauigkeit/foundpoints-linear-30grad.emf
	lyxscale 20
	width 85col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Ausrichtung Beamer-Laptop: 30 Grad
\begin_inset CommandInset label
LatexCommand label
name "fig:messung-linearer-ansatz-30grad"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Baryzentrische Koordinaten
\begin_inset Foot
status open

\begin_layout Plain Layout
Für eine detailliertere Erklärung siehe 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://en.wikipedia.org/wiki/Barycentric_coordinate_system
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sub:Anhang-Baryzentrische-Koordinaten"

\end_inset


\end_layout

\begin_layout Paragraph
Funktionsweise
\end_layout

\begin_layout Standard
Baryzentrische Koordinaten beschreiben in jedem 
\begin_inset Formula $n$
\end_inset

-Eck 
\begin_inset Formula $n$
\end_inset

 Faktoren, die das Verhältnis zwischen den Flächen zwischen den Kanten und
 einem Punkt beschreiben.
 Deren Summe ist immer 1.
 Anhand dieser Faktoren lässt sich sehr einfach ein Rebasing durchführen.
 Das heisst, wenn die den Koordinatenursprüngen entsprechenden Eckpunkte
 in einem anderen System bekannt sind, kann die Position des Punktes ins
 Zielsystem übertragen werden.
 Dies ist in dieser Arbeit jeweils der Fall.
 Die gängigen Referenzpunkte sind jeweils die Beamerbild-Eckpunkte.
 Die Definition von baryzentrischen Koordinaten wird dem Leser hier nicht
 weiter eingeprügelt.
 TODO: Easteregg ok?
\end_layout

\begin_layout Paragraph
Anwendung
\end_layout

\begin_layout Standard
Baryzentrische Koordinaten berücksichtigen leider keine perspektivischen
 Verzerrungen, wie sie in dieser Arbeit vorkommen, was deren Funktionalität
 leider etwas einschränkt.
 Somit können sie nur direkt verwendet werden, wenn ein Punkt innerhalb
 oder zumindest in der Nähe eines schon perspektivisch korrigierten liegt.
 Andernfalls gibt es extreme Ungenauigkeiten, die ein Resultat unbrauchbar
 machen.
 Nähe wird dadurch definiert, dass alle Faktoren kleiner als 1.5 sein müssen.
 Wenn sie kleiner als 1 sind ist der Punkt innerhalb.
 Mit 1.5 darf er zu einer Kante eine Fläche gegen aussen aufspannen, die
 maximal der Hälfte der ganzen Fläche entspricht.
 Das entspricht einem maximalen Abstand der halben Dreieckshöhe zur Kante.
 Da die Nutzung von 
\begin_inset Formula $n$
\end_inset

-Ecken ohne zusätzlich Gleichungen weder zusätzliche Genauigkeit noch sonstige
 Vorteile bringt, werden baryzentrische Koordinaten bei diesem Schritt nur
 im Dreieck benutzt.
 
\end_layout

\begin_layout Standard
Durch eine Mittlung der resultierenden Koordinaten anhand mehrerer Dreiecke
 können die Störungen der Verzerrung etwas minimiert werden.
 Wenn genügend Referenzpunkte vorhanden sind, fällt das nicht mehr ins Gewicht.
 
\end_layout

\begin_layout Paragraph
Ergebnisse
\end_layout

\begin_layout Standard
Wenn der Beamer und das Notebook nebeneinander stehen, funktioniert die
 Interpolation anhand der Eckpunkte ziemlich gut.
 Die Implementation wurde jedoch meist unter erschwerten Umständen (flacheren
 Winkeln) getestet.
 Hier gab es bei der linearen Interpolation gewisse Verschiebungen in horizontal
er Richtung.
 Dies entspricht nicht der erwünschten Genauigkeit.
 Mit den baryzentrischen Koordinaten anhand der Eckpunkte hatten gab es
 anfangs sehr viele Ungenauigkeiten.
 Zudem waren Knicke in den Linien über die Diagonale sichtbar.
 
\end_layout

\begin_layout Standard
Eine Mittlung der Ergebnisse aller vier Dreiecke hat jedoch geholfen, die
 Knicke zu eliminieren und die vertikalen Fehlerfaktoren zu eliminieren.
 Dafür gab es damit Probleme an den Rändern, da dort unrealistische Werte
 entstehen.
 In Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:genauigkeit-bary-interpol"

\end_inset

 ist sichtbar, wie stark sich die Perspektivische Verzerrung auswirkt.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
Y Werte:
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Soll
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
links
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mitte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rechts
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-62
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
86
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
125
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
200
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
150
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
193
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
212
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
264
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
289
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
297
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
400
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
368
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
390
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
391
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
505
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
495
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
479
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
600
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
632
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
594
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
574
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
700
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
761
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
689
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
662
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
768
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
838
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
756
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
700
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
X Werte: 
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="12">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Soll
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
200
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
400
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
600
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
700
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
800
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
900
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1000
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
oben
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
152
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
263
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
382
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
486
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
593
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
686
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
772
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
857
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
939
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1005
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mitte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
148
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
266
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
384
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
494
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
600
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
689
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
780
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
865
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
950
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1023
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unten
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
130
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
265
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
381
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
491
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
600
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
695
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
779
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
870
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
950
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1034
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Genauigkeit baryzentrische Interpolation
\begin_inset CommandInset label
LatexCommand label
name "tab:genauigkeit-bary-interpol"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die horizontale Verschiebung ist je nach Versuchsaufbau ähnlich zum linearen
 Ansatz.
 Mir mehr Referenzpunkten lässt sich dieses Problem aber u.U.
 lösen.
 
\end_layout

\begin_layout Paragraph
Kompensation der Verzerrung
\end_layout

\begin_layout Standard
Wenn nur drei oder vier Referenzpunkte für eine Interpolation verwendet
 werden, ist das Resultat korrekt, wenn das Kamerabild winkeltreu ist.
 Doch auch in diesem Fall gibt es Probleme, wenn mit diesem Verfahren eine
 Linie über mehrere Dreiecke gezogen wird.
 Diese hat dann an jedem Übergang eine neue Richtung.
 Das wird von einem Nutzer dadurch wahrgenommen, dass eine über die Mitte
 gezogene Linie nicht gerade ist, sondern Knicke enthält.
 TODO: fehlt das Bild unten
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Knicke in gezeichneten Linien
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Interpolation anhand eines feineren Gitters
\end_layout

\begin_layout Standard
Die Anzahl berücksichtigter Dreiecke ist hier sehr wichtig.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
Mittlung von 3 Resultaten:
\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/Cluster3.bmp
	width 70col%

\end_inset


\begin_inset Graphics
	filename Bilder/Calibration/Cluster3Detail.bmp
	width 30col%

\end_inset


\end_layout

\begin_layout Plain Layout
Mittelung von 15 Resultaten:
\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/Cluster15.bmp
	width 70col%

\end_inset


\begin_inset Graphics
	filename Bilder/Calibration/Cluster15Detail.bmp
	width 30col%

\end_inset


\end_layout

\begin_layout Plain Layout
Der Rotanteil der Pixel entspricht den interpolierten X-Werten, der Grünanteil
 den Y-Werten
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Interpolation anhand eines feinen Gitters mit baryzentrischen Dreiecken
\begin_inset CommandInset label
LatexCommand label
name "fig:komisches-farbiges-bild-mit-farben"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:komisches-farbiges-bild-mit-farben"

\end_inset

 ist sichtbar, dass mit der Mittlung von mehreren Resultaten lokale Unstimmigkei
ten behoben werden Das benötigt jedoch auch einen höheren Rechenaufwand,
 wie man unter 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Benötigter-Aufwand-fürBary"

\end_inset

 sieht.
 In dieser Tabelle sind die nötigen Berechnungen für eine gewisse Anzahl
 Dreiecke aufgeführt.
 Es gibt jedoch viele globale Unstimmigkeiten, die nicht korrigiert werden
 können.
 Diese sieht man daran, dass alle Linien eigentlich gerade sein müssten.
 Dies ist jedoch an mehreren Stellen (überall wo es Wellen und Knicke hat)
 nicht gegeben.
 TODO: was bedeuten die Farben? Ist doch beschrieben? 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/perfBarycentric.eps
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Benötigter Aufwand für baryzentrische Berechnung
\begin_inset CommandInset label
LatexCommand label
name "tab:Benötigter-Aufwand-fürBary"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Gewichtung
\end_layout

\begin_layout Standard
Da baryzentrische Koordinaten leider keine Abstandsfunktion definieren,
 können wir keine Nachbarn erkennen und keine Gewichtung durchführen um
 das Problem der Knicke zu lösen.
 Zudem haben wir das Problem, dass gewisse Dreiecke falsche Daten liefern,
 wie unter 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Fehler-Baryzentrisch"

\end_inset

 dargestellt.
 Daher werden regelmässige Rechtecke verwendet.
 Dabei wird nicht nur das Resultat eines Rechtecks analysiert, sondern auch
 das der direkt benachbarten Rechtecke.
 Durch eine entsprechende Gewichtung der Nachbar-Vierecke sollte das Resultat
 nicht verfälscht werden, aber die Knicke soweit geglättet werden, dass
 sie dem Nutzer nicht mehr auffallen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/GewichtungCrop.pdf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Gewichtung der Vierecke
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hierbei entsprechen die Farben an den Übergängen der Gewichtung der Resultate.
\end_layout

\begin_layout Subsection
Versuche zur Umsetzung von Touch
\begin_inset CommandInset label
LatexCommand label
name "sub:touch-umsetzung"

\end_inset


\end_layout

\begin_layout Standard
Dieser Exkurs befasst sich mit der Vision, eine projizierte Beamerwand mittels
 Touch zu bedienen.
 Der Benutzer soll die projizierte Fläche mit der Hand antippen und so das
 System hinter der Projektion steuern können.
 Diese Aufgabenstellung lässt sich über verschiedene Fragestellungen analysieren.
\end_layout

\begin_layout Paragraph
Relevante Informationen finden
\end_layout

\begin_layout Standard
Zuerst muss klar werden, woraus die benötigten Informationen gewonnen werden.
 Es sind ein oder mehrere Kamerabilder denkbar
\begin_inset Foot
status open

\begin_layout Plain Layout
3D-Analysesysteme wurden vollständig ausser acht gelassen, da sie teurer
 sind als die in dieser Arbeit gesetzten Kostengrenze von Zusatzhardwarekosten
 (ca.
 20.-).
\end_layout

\end_inset

.
 Ebenfalls fragt sich, wie die Informationen aus diesem Kontext gewonnen
 werden können.
 Es ist möglich, die Person vor der Leinwand gegen ein Basisbild zu vergleichen
 oder bewegte Teile mittels Differenzbildanalyse über zwei oder mehr Bilder
 zu erkennen.
 Es könne der Person ein Handschuh angezogen werden, der eine eindeutige
 Farbe hat und so immer sogar in nur einem Kamerabild zu erkennen ist.
 Es wäre denkbar, eine Person mit komplizierteren Algorithmen über ein vorher
 konfiguriertes Pattern zu tracken.
 Die Mathematik birgt mit Fouriertransformation und Direct Linear Transformation
 viele Möglichkeiten Patternmatching zu betreiben.
 Die in dieser Arbeit untersuchten Ansätze sind einfacherer Art und beschränken
 sich darauf zu zeigen welche Aspekte betrachtet werden müssen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Handtracking/no-touch-basediff.png
	lyxscale 20
	width 49col%

\end_inset

 
\begin_inset Graphics
	filename Bilder/Handtracking/touch-basediff.png
	lyxscale 20
	width 49col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Finger in Ruhestellung (links) - Finger tippt auf Leinwand (rechts)
\begin_inset CommandInset label
LatexCommand label
name "fig:perspos-diffs"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Hand und Finger finden
\end_layout

\begin_layout Standard
Die Hand einer Person zu finden mit wenig Aufwand gut zu beschreiben.
 Über den unteren Rand des Kamerabildes wird die im Bild stehende Person
 mittels Differenzbilder gefunden.
 Die Position und das Ausmass des Körpers der Person ist mit wenig Spiel
 gut abschätzbar entlang zweier senkrechter Linien am Rand der Beine (siehe
 Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PersonPosition"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Handtracking/PersonPosition/pos-base.png
	lyxscale 20
	width 49.25col%

\end_inset


\begin_inset space \enskip{}
\end_inset


\begin_inset Graphics
	filename Bilder/Handtracking/PersonPosition/pos-frame.png
	lyxscale 20
	width 49.25col%

\end_inset


\begin_inset VSpace 0.5em
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Handtracking/PersonPosition/pos-diff.png
	lyxscale 20
	width 49.25col%

\end_inset


\begin_inset space \enskip{}
\end_inset


\begin_inset Graphics
	filename Bilder/Handtracking/PersonPosition/pos-median.png
	lyxscale 20
	width 49.25col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 0.5em
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Handtracking/PersonPosition/pos-final.png
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
1)
\begin_inset space ~
\end_inset

Basisbild, 2)
\begin_inset space ~
\end_inset

Frame, 3)
\begin_inset space ~
\end_inset

Differenz, 4)
\begin_inset space ~
\end_inset

entrauschtes Differenzbild, 5)
\begin_inset space ~
\end_inset

Personenposition
\begin_inset CommandInset label
LatexCommand label
name "fig:PersonPosition"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Handgesten erkennen
\end_layout

\begin_layout Standard
Handgesten wie Touch oder Greifen zu erkennen, ist nicht ganz trivial.
 Der hier vorgeschlagene Ansatz versucht den Körper der Person vom Hintergrund
 durch den Schatten zu trennen.
 Die Unterscheidung zwischen Schatten und Person geschieht auf der Differenz
 gegen das Basisbild.
 So bleiben alle nicht benötigten Informationen unbeachtet.
 In Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:farbanalyse-schatten"

\end_inset

 ist der Unterschied zwischen Schatten und Arm auf dem Differenzbild sichtbar.
 Im Diagramm wurde analysiert, welche durchschnittlichen Farbwerte das Differenz
bild in einem vertikalen Streifen besitzt.
 Der Streifen wurde von oben nach unten über 480 Pixel durchlaufen.
 Das Maximum bezeichnet den Schatten das lokale Minimum den Arm.
 Sobald klar ist, an welcher Position sich der Übergang von Schatten zu
 Arm befindet, kann die Schattenfarbe im Originalbild nachgeschaut werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Handtracking/Gestenanalyse/arm-shadow-stripe.png
	lyxscale 50
	width 100col%

\end_inset


\begin_inset VSpace 0.5em
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Handtracking/arm-colors.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Die Helligkeitsanalyse innerhalb des oben gekennzeichneten vertikalen Streifen
 des Differenzbildes ergibt im Schnitt diese Farbaufteilung (unten).
\begin_inset CommandInset label
LatexCommand label
name "fig:farbanalyse-schatten"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Schattenfarbe wird aus dem Originalbild als weiss markiert und vom eingeschr
änkten Differenzbild abgezogen.
 Dann bleibt der Arm übrig ohne Schatteninformation.
 Der Gesamtanteil an Schatteninformation sind die vom eingeschränkten Differenzb
ild abgezogenen Pixel.
 Unter Umständen könnte die Menge an Schattenpixel und deren Position für
 die Detektion verwendet werden ob die Person die Leinwand antippt oder
 nicht.
 Dies ist eine sehr vage Theorie und bedarf weiterer Untersuchungen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Handtracking/Gestenanalyse/arm-shadow-diff.png
	lyxscale 50
	width 23.5col%

\end_inset


\begin_inset space \enskip{}
\end_inset


\begin_inset Graphics
	filename Bilder/Handtracking/Gestenanalyse/arm-shadow-thres.png
	lyxscale 50
	width 23.5col%

\end_inset


\begin_inset space \enskip{}
\end_inset


\begin_inset Graphics
	filename Bilder/Handtracking/Gestenanalyse/shadow-base.png
	lyxscale 50
	width 23.5col%

\end_inset


\begin_inset space \enskip{}
\end_inset


\begin_inset Graphics
	filename Bilder/Handtracking/Gestenanalyse/just-the-arm.png
	lyxscale 50
	width 23.5col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
1)
\begin_inset space ~
\end_inset

Differenzbild gegen Basis, 2)
\begin_inset space ~
\end_inset

Helldunkel-Schranke über Differenzbild, 3)
\begin_inset space ~
\end_inset

Schattenfarbe weiss markiert aus dem Originalbild, 4)
\begin_inset space ~
\end_inset

zweites minus drittes Bild
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Da nun der Arm gefunden ist, könnte in diesem eingeschränkten Bereich ein
 Patternmatching durchgeführt werden.
 Ein Sample der Hand oder des Fingers könnte an Schlüsselpositionen gefunden
 werden.
 Die Information ob eine Geste wie Touch durchgeführt wurde, kann aus der
 streifenweisen Schattenanalyse geholt werden.
 Ist der Schatten in der richtigen Intensität am Richtigen Ort, so fand
 ein Touch statt, sonst nicht.
 Einfach dürfte dieses Vorgehen jedoch nicht sein.
 Es gibt zu viele Arten, wie die Schattenverteilung sein könnte.
 Hier wird vorgeschlagen, sich zuerst auf das genaue Finden der Hand festzulegen.
 Sobald die Hand getrackt werden kann, ist es möglich, weitere Schlüsse
 aus den sich daraus ergebenden Analysemöglichkeiten zu ziehen.
 
\end_layout

\begin_layout Standard
Eine Idee dazu ist, Bewegungen der Gelenke Schulter, Ellbogen und Hand aufzuzeic
hnen.
 Dies könnte über einen Ansatz mit Ausgleichsgeraden geschehen.
 Dazu wird von der Schulter mit einer radialen Scanline von unten über die
 Punktmenge des Armes gefahren.
 Sobald ein Punkt auftaucht, ist entweder die Hand oder der Ellbogen gefunden
 worden.
 Je nach Entfernung des Punktes von der Schulter lässt sich das einfach
 entscheiden.
 Am Ellbogen wird das Verfahren wiederholt bis der erste Punkt der Hand
 gefunden wurde.
 Das Fahren der Scanline kann mathematisch als Koordinatentransformation
 von euklidischen zu Polarkoordinaten beschrieben werden.
 Dies vereinfacht das Modellieren der Scanline.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/Handtracking/Gestenanalyse/polar-scan.emf
	lyxscale 10
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Scanline-Ansatz um Gelenke zu finden
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Ergebnisse
\end_layout

\begin_layout Standard
Es ist schwierig zu sagen, ob es sinnvoll ist, Touch auf der Leinwand weiter
 zu verfolgen.
 Einerseits wäre diese Funktionalität innovativ und wünschenswert.
 Sie ist an keine weitere Hardware gebunden und die zugehörige Software
 könnte mit dem Betriebssystem zusammen ausgeliefert werden.
 Andererseits ist es sehr schwierig zu erkennen, ob eine Person die Leinwand
 angetippt hat.
 Bei schlechten Lichtbedingungen und komplizierteren projizierten Bildern
 konnte die Hand bei schneller Bewegung nicht einmal mehr mit blossem Auge
 erkannt werden.
 Ob eine Webcam mit schlechter Auflösung, niedriger Framerate und schlechter
 Belichtung überhaupt den Input für eine zuverlässige Datenverarbeitung
 liefern kann ist fraglich.
 Es sollte möglich sein, die Hand zu tracken und bei einem geübten Benutzer
 die Finger.
 Dies allerdings nur bei optimalen Lichtbedingungen.
 Es ist hingegen nicht klar, wie dass mit hoher Trefferrate festgestellt
 werden kann, ob die Person die Leinwand angetippt hat.
 Das oben beschriebene Vorgehen für die Schattenanalyse befasst sich lediglich
 mit den Daten, welche in dieser Arbeit aufgenommen wurde.
 Es müsste systematischer untersucht werden, ob die dies für jeden Fall
 zuverlässig gelöst werden könnte.
\end_layout

\begin_layout Subsection
Quellenverzeichnis
\end_layout

\begin_layout Standard
TODO: blabliblablub
\end_layout

\end_body
\end_document
