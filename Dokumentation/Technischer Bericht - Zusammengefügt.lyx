#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language german-ch
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 0
\use_esint 0
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Stichwortverzeichnis
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Presentation Writer
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand include
filename "Abstract.lyx"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Einleitung
\end_layout

\begin_layout Standard
Die in dieser Arbeit entworfene Software soll einer Person ermöglichen,
 interaktive Präsentationen in einem kleinen oder mittelgrossen Sitzungszimmer
 zu halten.
 Die Person kann ihren eigenen Laptop dafür verwenden.
 Der Laptop wird am dort vorhandenen Beamer angeschlossen.
 Nach einer kurzen Kalibrierung kann die Person die Präsentation starten.
 Dabei schreibt sie falls gewünscht mit einem virtuellen Stift an die Leinwand.
 Das geschriebene wird aufgezeichnet und wieder auf das Beamerbild projiziert.
\end_layout

\begin_layout Paragraph
Aufbau
\end_layout

\begin_layout Standard
In einem normalen Sitzungszimmer soll ein Vortrag gehalten werden können.
 Dazu sollen Standardausstattung wie Laptop, integrierte Kamera und Beamer
 benutzt werden können.
 Als Addendum wird ein Stift mitgeliefert.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Aufbau/rendered-perspective.png
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Beispiel eines Aufbaus in der Perspektive
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Kalibrierung
\end_layout

\begin_layout Standard
Bevor ein Stift auf der Leinwand gefunden werden kann, muss die Erkennungssoftwa
re kalibriert werden:
\end_layout

\begin_layout Itemize
Laptopkamera so ausrichten, dass der ganze Bereich der Leinwand gefilmt
 werden kann
\end_layout

\begin_layout Itemize
Lichtverhältnisse anpassen falls nötig
\end_layout

\begin_layout Itemize
Projiziertes Bild erkennen und ein Mapping von Kamerakoordinaten zu Bildschirmko
ordinaten berechnen
\end_layout

\begin_layout Paragraph
Präsentation
\end_layout

\begin_layout Standard
Die Person soll mit einem Stift auf die das Beamerbild schreiben können.
 Sie benutzt dazu ein helles Licht.
 Die Person muss darauf achten, dass der Stift für die Kamera sichtbar ist.
 Das erfordert Disziplin.
 Deshalb gilt abzuklären, ob und wie das Präsentationssystem akzeptiert
 wird.
\end_layout

\begin_layout Section
Problemstellung
\end_layout

\begin_layout Subsection
Einschränkungen
\end_layout

\begin_layout Standard
Sowohl bei der verwendeten Hardware als auch bei der Art und Weise wie die
 Software benutzt werden kann, gibt es Einschränkungen.
 Obwohl das erarbeitete Präsentationssystem zum Ziel hat, einschneidende
 Beschränkungen zu vermeiden, gibt es doch verschiedene Grenzen, die von
 Anfang an definiert sind und als nicht überwindbar gelten.
 Grundsätzlich sind sie physischer und physikalischer Art.
\end_layout

\begin_layout Subsubsection
Aufnahmegerät
\end_layout

\begin_layout Standard
Das in dieser Arbeit verwendete Aufnahmegerät ist eine integrierte Laptopkamera
 eines Thinkpad T420s mit einer Auflösung von 640x480 Pixel à 30 Bilder
 pro Sekunde.
 Sie übertreibt es völlig mit dem automatischen Weissabgleich, hat aber
 einen in den Treiber integrierten Konfigurationsdialog, mit welchem sich
 das Problem manuell minimieren lässt.
 Allgemein formuliert ist an der verwendeten Kamera die Bildauflösung weniger
 wichtig als eine korrekte Belichtung.
 Das liegt daran, dass die präsentierende Person immer in Bewegung ist,
 mal mehr beleuchtet, mal weniger, und somit ein irritierendes Ungleichgewicht
 für die Kamera schafft.
 Übertriebene Änderungen der Beleuchtung seitens der Kamera übertönen den
 Stift.
 Folglich ist er nicht mehr der hellste Punkte der Aufnahme und wird nicht
 mehr erkannt, bzw.
 gefunden.
\end_layout

\begin_layout Paragraph
Beispiel:
\end_layout

\begin_layout Standard
Abbildung 2 zeigt eine Beamerprojektion einer weissen Fläche.
 Der Raum ist wenig abgedunkelt, damit die Kamera welche die Aufnahme gemacht
 hat, einen weniger starken automatischen Weissabgleich vornimmt.
 Nichtsdestotrotz beträgt die Anzahl völlig weisser Pixel in diesem Bild
 mehr als 11'000.
 Das macht es unmöglich, optisch einen hellen Punkt (Stift) zu finden.
 Eine stärker abgedunkelte Umgebung erhöht den Kontrast und somit auch das
 Problem.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Camera/whitebalance.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Überbeleuchtetes Kamerabild
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Fazit:
\end_layout

\begin_layout Standard
Der automatische Weissabgleich kann über den Hardwaretreiber abgestellt
 werden, erfordert aber einiges an Arbeit (bei Windows schwierig, bei Linux
 einfacher).
 Die verwendeten Geräte müssten genau bekannt sein, um ihre Treiber konfiguriere
n zu können.
 Wahrscheinlich stellt dieser Aufwand ein Hindernis dar, welches man eher
 durch Mitliefern einer eigenen Infrarot-Kamera lösen würde.
 Das hätte den Vorteil, dass sowohl Präsentator als auch Zuschauer nicht
 von sichtbarem Licht abgelenkt würden.
 In dieser Arbeit wird der Einfachheit halber lediglich auf das Finden einer
 von Menschen sichtbaren Lichtquelle eingegangen.
 Es wird angenommen, dass sich alle Konzepte auf nicht sichtbares Licht
 übertragen lassen.
\end_layout

\begin_layout Subsubsection
Präsentationsgerät
\end_layout

\begin_layout Standard
Ein weniger wichtige Rolle als die Kamera spielt der Beamer.
 Weder die Auflösung, noch die Bildwiederholrate spielen eine nennenswerte
 Rolle auf die Qualität des Präsentationssystem.
 Die Helligkeitseinstellung ist jedoch wichtig.
 Der in dieser Arbeit verwendete Beamer beleuchtet die Leinwand sehr stark
 und verstärkt dadurch das Problem des automatischen Weissabgleiches der
 Kamera.
 Zur Minimierung des Problems wurde die Helligkeit auf ein schwächeres Niveau
 reduziert.
 Es wurde darauf geachtet, dass die Einstellung als 
\begin_inset Quotes gld
\end_inset

üblich für eine Präsentation
\begin_inset Quotes grd
\end_inset

 wahrgenommen wird.
\end_layout

\begin_layout Subsubsection
Positionierung
\end_layout

\begin_layout Standard
Der Laptop wird so aufgestellt, dass das Sichtfeld der integrierten Kamera
 den Projektionsbereich auf der Leinwand voll umfasst.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Aufbau/wireframe-top.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Beispiel eines Aufbaus von oben
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der Winkel zwischen Projektionsfläche und Laptopkamera hat Auswirkungen
 auf die Genauigkeit des Präsentationssystems.
 Je grösser der Winkel zwischen Kamera und Projektionsfläche ist, desto
 stärker verzerrt nimmt die Kamera das projizierte Bild wahr.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Aufbau/aufbau-verzerrung.png
	lyxscale 50
	width 100col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Leinwand mit drei verschiedenen Verzerrungen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
So sieht die Kamera die Leinwand aus drei verschiedenen Winkeln.
 Die Kalibrierung kann die perspektivische Verzerrung nur begrenzt ausgleichen.
 Deshalb kann die Position eines Stiftes nicht immer gut oder in allen Bereichen
 der Leinwand gleich gut erfolgen.
\end_layout

\begin_layout Itemize
Links sieht man den üblichen Fall: Beamerbild und Laptopkamera liegen auf
 zwei parallelen Ebenen.
 
\end_layout

\begin_layout Itemize
In der Mitte ist der Optimalfall dargestellt: Die Kamera sieht direkt von
 vorne auf das Beamerbild, d.h.
 die perspektivische Verzerrung ist minimal
\end_layout

\begin_layout Itemize
Rechts ist das Bild in alle Richtungen verzerrt und stellt somit die grössten
 Anforderungen an die Kalibrierung.
\end_layout

\begin_layout Standard
Zur Vereinfachung des zu lösenden Problems wird im Folgenden jeweils angenommen,
 dass die perspektivische Verzerrung lediglich auf der Horizontalen (X-Achse)
 der aufgenommenen Bilder verläuft.
 Messungen zur Genauigkeit unseres verwendeten Abbildungsverfahrens (s.u.)
 zeigen, dass die Verzerrung auf der Vertikalen (Y-Achse) vernachlässigt
 werden kann.
\end_layout

\begin_layout Subsubsection
Leinwand
\end_layout

\begin_layout Standard
Es ergeben sich Beschränkungen aus dem Untergrund, auf welchen präsentiert
 wird.
 Unebene oder glänzende Texturen sind ungeeignete Präsentationsflächen,
 da sowohl Kalibrierung als auch Stifterkennung darunter leiden können.
 Grosse Probleme können Reflexionen der Beamerlampe auf der Leinwand verursachen.
 Dies kann passieren, wenn Beamer und Laptop in einem ungünstigen Winkel
 zueinander stehen.
\end_layout

\begin_layout Subsubsection
Laptop
\end_layout

\begin_layout Standard
Bildverarbeitung braucht in der Regel viel Rechenleistung.
 Die in dieser Arbeit entwickelte Software benötigt ...
 ??? Messung TODO.
\end_layout

\begin_layout Subsubsection
Präsentationsweise
\end_layout

\begin_layout Standard
Da der Stift immer von der Laptopkamera gesehen werden muss, ist es am Präsentat
or, die richtige Haltung beim Schreiben anzunehmen.
 Da dies jedoch den Vorteil hat, dass auch die Zuschauer sehen, wo der Präsentat
or auf die Leinwand schreibt, wird diese Einschränkung ohne weiteren Diskurs
 in Kauf genommen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TODO: Bild einer vorbildlich präsentierenden Person
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Analyse
\end_layout

\begin_layout Subsection
Kalibrierung
\end_layout

\begin_layout Subsection
Stift Erkennen
\end_layout

\begin_layout Subsection
Architektur
\end_layout

\begin_layout Subsubsection
Domain
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Domain.emf
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Das Domain Modell berücksichtigt modulare Erweiterungen.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Hauptsequenz
\end_layout

\begin_layout Standard
Unser Hauptprojekt wird eine ausführbare Datei, die alle unsere Subprojekte
 zusammenbringt.
 
\end_layout

\begin_layout Standard
\noindent
Grobablauf unseres Programms: 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/SSD.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
SSD
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Enumerate
Verbindung mit der Kamera 
\end_layout

\begin_deeper
\begin_layout Enumerate
Der Nutzer kriegt eine Auswahl aller gefundenen Kameras und entscheidet
 sich für eine.
 
\end_layout

\begin_layout Enumerate
Anhand der Auswahl wird die Kamera angelegt und gestartet.
 
\end_layout

\end_deeper
\begin_layout Enumerate
Das Programm sucht einen passenden Visualisierer und legt diesen an.
 
\end_layout

\begin_layout Enumerate
Ein DataParser wird angelegt.
 
\end_layout

\begin_layout Enumerate
Die Kalibration kann nun automatisch oder nach einer Interaktion des Benutzers
 gestartet werden.
 
\end_layout

\begin_layout Enumerate
Die Details über den Ablauf des Kalibrationsvorgang sind im Abschnitt Kalibratio
n aufgeführt.
 
\end_layout

\begin_layout Enumerate
Kalibration wird erfolgreich abgeschlossen und das Pentracking gestartet.
 Die Details über den Ablauf des Trackings sind im Abschnitt Pen-Tracking
 aufgeführt.
 
\end_layout

\begin_layout Section
Umsetzung
\end_layout

\begin_layout Subsection
Technologien
\end_layout

\begin_layout Subsubsection
Programmiersprache
\end_layout

\begin_layout Standard
Wir haben uns für die Programmiersprache C# entschieden, da uns diese besser
 liegt (TODO schnellere Entwicklungszeit...).
 Zudem war es einfacher auf Systemfunktionen wie z.B.
 Direct Show und Mausemulation zuzugreifen.
 In Java wäre das nicht möglich gewesen.
 Mit C++ hätten wir bei der Bildbearbeitung etwas weniger Performance benötigt,
 dafür hätten wir mehr Einarbeitungszeit benötigt.
 Aus unserer Sicht haben wir uns richtig entschieden.
\end_layout

\begin_layout Subsubsection
Framework
\end_layout

\begin_layout Standard
Beim grafischen Framework haben wir uns für AForge entschieden, da es nativ
 in C# geschrieben ist und gut dokumentiert ist.
 Im Gegensatz dazu hätten wir mit OpenCV etwas besser optimierte Algorithmen
 gehabt.
 Da wir nur einen Prototypen produzieren, ist Performance für uns nicht
 besonders wichtig, was unsere Wahl ebenfalls beeinflusst hat.
\end_layout

\begin_layout Subsection
Visualisierung 
\end_layout

\begin_layout Standard
Ein erstes Problem bot sich uns, als wir versuchten, aus einer Library auf
 den Bildschirm zu zeichnen.
 Das wiederspricht eigentlich allen Architekturmodellen, jedoch ist es bei
 unserer Lösung nötig für die Kalibration.
 
\end_layout

\begin_layout Subsubsection
Probleme
\end_layout

\begin_layout Itemize
Wir wissen nicht, in welcher Umgebung (Anzahl Treads) unsere Library läuft.
 Gewisse Kameras erzeugen zudem verschiede Threads in denen die Frames übergeben
 werden.
 
\end_layout

\begin_layout Itemize
Jedes GUI muss in einem eigenen Thread laufen das ein spezielles ThreadSTA-Attri
but hat.
 
\end_layout

\begin_layout Itemize
Der Garbage-Collector räumt den GUI-Thread ab, selbst wenn er in Zukunft
 noch verwendet werden müsste.
 
\end_layout

\begin_layout Itemize
Wenn ein GUI gestartet wird, öffnet es sich sofort.
 Das ist in unseren Fall nicht erwünscht.
 Ein Hide, das gerade nach dem Start aufgerufen wird, hat keine Wirkung.
 Es muss erst der komplette Start und die Darstellung des GUIs(ca.
 10ms) abgewartet werden, bis es versteckt werden kann.
 
\end_layout

\begin_layout Subsubsection
Umsetzungen
\end_layout

\begin_layout Paragraph
WPF
\end_layout

\begin_layout Standard
Sämtliche Interaktionen müssen über den Dispatcher geschehen.
 Andernfalls wird sofort eine Exception geworfen.
 Dadurch kann die Concurrency vom aufrufenden Code wieder Sequenziell abgearbeit
et werden, wie es für ein GUI nötig ist.
 Eine Lösung zu entwickeln, die komplett Concurrency-Safe ist ziemlich aufwändig
 und zeitintensiv.
 
\end_layout

\begin_layout Paragraph
WinForms 
\end_layout

\begin_layout Standard
Mit dem AllowUnsafeThreadExecution Attribut kann die ganze Thread-security
 abgeschaltet werden.
 Dafür müssen alle Grafikelemente vor dem Bearbeiten gelockt werden und
 der aufrufende Code ist verantwortlich dafür, dass die Aufrufreihenfolge
 und der Ablauf stimmt.
 Durch Double-Buffering kann die Performance erhöht werden, wenn mehrere
 Objekte gezeichnet werden.
 Es ist uns klar, dass diese Umsetzung diverse Architekturprinzipien und
 Guidelines verletzt.
 
\end_layout

\begin_layout Standard

\series bold
In einem finalen Release darf diese Umsetzung nicht verwendet werden.

\series default
 
\end_layout

\begin_layout Subsection
Kalibrierung
\end_layout

\begin_layout Standard
Die Grundüberlegung jedes Ansatzes der Kalibration ist derselbe: Im ersten
 Schritt werden die Ecken des Bildschirms gefunden, in den weiteren Schritten
 werden zusätzliche Daten gesammelt um die Interpolation zu verbessern.
 
\end_layout

\begin_layout Standard
TODO: Übergang zu Erkenntnissen in der folgenden Liste:
\end_layout

\begin_layout Enumerate
Als erster Schritt ist es nötig, dass ein Frame einzulesen, um die Auflösung
 der Kamera zu erhalten.
 
\end_layout

\begin_layout Enumerate
Das erhaltene Bild ist weder Flächen- noch Winkeltreu.
 
\end_layout

\begin_layout Enumerate
Die Belichtungskorrektur der Kamera ist sehr gefährlich, um ein sinnvolles
 Differenzbild zu erhalten, muss darauf geachtet werden, dass auf beiden
 Bildern die gleiche Helligkeitsverteilung herrscht.
 Dies Verunmöglicht, ein universelles Bild zu speichern, mit dem man den
 Hintergrund entfernen könnte.
 
\end_layout

\begin_layout Enumerate
Die Belichtungskorrektur benötigt ca.
 1-2 Frames, bis sie reagiert.
 Aus Performance-Gründen lässt sich das leider nicht zu unserem Vorteil
 nutzen.
 
\end_layout

\begin_layout Enumerate
Von gewissen Webcams wird das Bild gespiegelt zurückgegeben, von anderen
 nicht.
 
\end_layout

\begin_layout Enumerate
Bis die Bilder der Kamera dem entsprechen, was man erwarten würde, muss
 man ca.
 100ms warten.
 Diese Dauer ist zudem vom gewählten Visualisierer abhängig.
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/Verzögerung1.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/Verzögerung2.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Verzögerung der Darstellung
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Die Linse der Kamera kann für eine zusätzliche Verzerrung sorgen.
 
\end_layout

\begin_layout Enumerate
Berechnungen mit C# Bitmaps sind extrem inperformant.
 
\end_layout

\begin_layout Enumerate
Eine sequentielle Bearbeitung der Daten führt dazu, dass man mit veralteten
 (und somit falschen) Daten arbeitet.
 
\end_layout

\begin_layout Enumerate
Eine parallele Bearbeitung der führt meistens zum unkontrollierten Spawnen
 von Tasks, die das System verlangsamen und schliesslich ein Ablaufen verunmögli
chen.
 Falls das Auftritt, hat man ebenfalls Probleme mit alten Daten.
 
\end_layout

\begin_layout Enumerate
Wenn ein Teil der Anzeige durch ein anderes Fenster oder einem Objekt verdeckt
 wird, ist das unmöglich automatisch zu detektieren.
 Daher muss die Erkennung noch durch den Nutzer verifiziert werden.
 
\end_layout

\begin_layout Paragraph
Allgemeine Massnahmen
\end_layout

\begin_layout Itemize
Der Ablauf wird von einer Semaphore geschützt.
 Wenn kein Lock akquiriert werden kann, wird das ankommende Bild verworfen
 und nicht behandelt.
 
\end_layout

\begin_layout Itemize
Nach jedem Zeichnen wird 100 ms gewartet bevor die Semaphore freigegeben
 wird, damit sichergegangen werden kann, dass das erwartete Bild von der
 Kamera ankommt.
 
\end_layout

\begin_layout Subsection
Umsetzung: Schachbrett-Differenzbilder
\end_layout

\begin_layout Standard
Um Differenzbilder nutzen zu können, aber sich nicht durch die Belichtungskorrek
tur beeinflussen zu lassen, muss darauf geachtet werden, dass jedes projizierte
 Bild eine identische Helligkeitsverteilung zum Referenzbild besitzt.
 Das bedeutet, dass für jedes Bild, das man analysieren möchte, zwei Bilder
 Projiziert werden müssen.
 Da diese Art der Erkennung viel genauer ist, nehmen wir diesen Overhead
 in Kauf und verzichten allenfalls auf ein paar Referenzbilder.
 „Lieber wenig gute Daten, als viel schlechte“ 
\end_layout

\begin_layout Paragraph
Ablauf
\end_layout

\begin_layout Enumerate
Es wird ein Schachbrett mit 
\begin_inset Formula $n\times m$
\end_inset

 Quadraten projiziert.
 Das Verhältnis von n zu m sollte dem Bildschirmverhältnis entsprechen und
 die Quadrate sollten noch gut auf dem Kamerabild sichtbar sein (15-30 Pixel
 Seitenlänge) 
\end_layout

\begin_layout Enumerate
Das Schachbrett wird erneut projiziert, diesmal mit invertierten Farben.
 Auf dem Differenzbild sollte jetzt die Leinwand klar zu erkennen sein.
 Da es an den Kanten der Quadrate Lücken haben wird (diejenigen Pixelreihen,
 die von der Kamera auf beiden Bildern als Beleuchtet erkannt hat), müssen
 wir diese z.B.
 mit einem Gaussfilter mit einer kleinen Kernel-Size eliminieren, da es
 sonst bei der Bloberkennung zu Fehlerkennungen kommt.
 Jetzt können die Ecken des Bildschirms sehr genau erkannt werden.
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/img01-0-0.jpg
	width 45col%

\end_inset

- 
\begin_inset Graphics
	filename Bilder/Calibration/img02-0-0.jpg
	width 45col%

\end_inset

 = 
\begin_inset Graphics
	filename Bilder/Calibration/diff.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
Gaussfilter mit Rafius 3, um die Erkennung zu verbessern:
\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/diffblur.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Erkennung des Bildschirms
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Stifterkennung
\end_layout

\begin_layout Subsubsection
Verfahren
\end_layout

\begin_layout Standard
Das Erkennen des Stiftes beruht auf der optischen Eigenschaft, dass der
 Stift das hellste sichtbare Licht auf dem Kamerabild darstellt.
 Der hellste Punkt sollte also die aktuelle Stiftposition sein.
 Es gibt zwei naheliegende Ansätze um diesen Punkt zu finden.
\end_layout

\begin_layout Itemize
Finde den hellsten Punkt auf dem Bild.
 Das hat Schwächen.
 Insbesondere wenn das Bild viel Rauschen beinhaltet.
\end_layout

\begin_layout Itemize
Finde den hellsten Punkt der sich bewegt
\end_layout

\begin_layout Paragraph
Beispiel
\end_layout

\begin_layout Standard
Im folgenden Beispiel wurde der automatische weissabgleich der Kamera auf
 Rot konzentriert und die Überbeleuchtung drastisch reduziert.
 Resultierend sieht man die hellsten Punkte auf dem Beamerbild.
 Der alleinstehende Punkt im ersten Bild ist ein Laserpointer-Punkt.
 Im zweiten Bild befindet er sich im verrauschten Bereich.
 Den Punkt dort in einem einzelnen Bild per Software zu finden, kann Schwierigke
iten bereiten, da der Laserpunkt nicht der hellste sein muss.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/laser-standalone.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Der Laserpointer ist gut sichtbar
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/laser-rauschen.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Der Laserpointer ist im Rauschen kaum sichtbar
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Differenzbilder
\end_layout

\begin_layout Standard
Ein stabilerer Ansatz ist, den Lichtpunkt über Differenzbilder zu finden.
 Das Differenzbild filtert helles Rauschen und stehende helle Lichtquellen
 zuverlässiger raus als eine einfache Hell/Dunkel-Schranke.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/laser-diff.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Differenzbild zweier Frames mit Laserpunkten
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/laser-diffgray.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Nachdem die Rotanteile zu Graustufen übersetzt wurden, sieht man die gesuchten
 Laserpunkte besser.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/laser-diffthreshold.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Nun ergibt ein Hell/Dunkel-Filter (Threshold oder Binarize) gute Anhaltspunkte
 wo sich gesuchte Punkte befinden.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Kardinalität der gefundenen Punkte
\end_layout

\begin_layout Standard
Alle zusammenhängenden hellen Bereiche werden Blobs genannt.
 Diese Blobs repräsentieren Positionen wo sich der Stift im aktuellen und
 im vorherigen Frame befunden hat.
 Es gibt verschiedene Fälle die nach dem Finden der Blobs unterschieden
 werden müssen.
\end_layout

\begin_layout Itemize
Es wurde kein Blob gefunden:
\begin_inset Newline newline
\end_inset

Für die Software ist kein Stift sichtbar.
 Es wird kein Punkt gefunden.
 Dies kann der Fall sein, wenn die präsentierende Person nicht schreibt,
 vor dem Stift steht und der Kamera die Sicht verdeckt oder wenn die Lichtverhäl
tnisse nicht ideal sind und der Stift von der Kamera nicht hell genug wahrgenomm
en wird.
\end_layout

\begin_layout Itemize
Es wurde ein Blob gefunden:
\begin_inset Newline newline
\end_inset

Entweder hat sich der Stift nicht, oder zu wenig bewegt um zwei Blobs zu
 erzeugen oder es handelt sich um eine Fehlerkennung.
 
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-or-two-blobs/frame1.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-or-two-blobs/frame2.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-or-two-blobs/diff.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Frame x, Frame x+1, Differenz
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-blob/frame1.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-blob/frame2.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-blob/diff.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Frame x, Frame x+1, Differenz
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Es wurden zwei Blobs gefunden:
\begin_inset Newline newline
\end_inset

Das ist der gewünschte Fall.
 Beide Punkte bilden gültige Positionen des letzten und des momentanen Frames.
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs/frame1.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs/frame2.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs/diff.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Frame x, Frame x+1, Differenz - Die Punkte gehen 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Es wurden mehr als zwei Blobs gefunden:
\begin_inset Newline newline
\end_inset

Ungültig.
 Wird gemüllt.
\end_layout

\begin_layout Standard
Generell wird angenommen, dass alle Blobs, falls deren Anzahl zwei oder
 kleiner ist, gültige Stiftpositionen bilden und dass Fehlerkennungen vorher
 gefiltert werden konnten.
 Gute Filter setzen die Eigenschaften eines gültigen Lichtpunktes gut um
 (s.u.).
 
\end_layout

\begin_layout Paragraph
Resultierende Punktposition
\end_layout

\begin_layout Standard
Der Einfachheit halber wird nun das euklidische Zentrum der zwei gefundenen
 Blobs berechnet und als Resultatposition genommen.
 Falls nur ein Punkt gefunden wurde, wird dieser als Resultat gewählt.
 Dieses Verfahren beschränkt den Kontext und damit die Komplexität des Algorithm
us auf das Vorhandensein von genau zwei Bildaufnahmen.
 Es werden weder Geschwindigkeit, noch Vorgängerpunkte vorausgesetzt.
 Ein Nachteil, der dabei in Kauf genommen wird, ist, dass die gefundene
 Punktposition von korrekter Zeit und korrektem Ort abweichen kann.
 Diese Abweichung wird stärker, je schneller sich der Punkt auf der Leinwand
 bewegt.
 Mit Überlegungen aus dem WKS-Abtasttheorem wird aber klar, dass sich dieser
 Effekt nicht sehr stark in der mittleren Erkennungsqualität niederschlägt.
 Die Abtastrate vor und nach der Interpolation ist die gleiche.
 Die Abbildung der zwei gemessenen Punkte auf den Mittelwert resultiert
 in einer Position, die höchstwahrscheinlich gemessen worden wäre, wenn
 mit der doppelten Rate abgetastet worden wäre.
 Diese Behauptung gilt für unbeschleunigte gerade Bewegungen genau und für
 das Schreiben an eine Leinwand bei hoher Abtastrate näherungsweise.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/Interpolation/interpolation-random.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Zufällig verteilte Punkte (blau) mit grossen Abständen.
 Die Interpolation (violett) taugt nichts.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/Interpolation/interpolation-smoothed.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Die Interpolation dient als Glättung
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/Interpolation/interpolation-curves.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Bei genug Punkten bleibt die Ursprungsfigur gut erhalten.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Zeitlich korrekte Punktposition
\end_layout

\begin_layout Standard
Es wäre möglich, die genaue Punktposition zu finden, indem auf dem aktuellen
 Differenzbild der Vorgänger bestimmt wird.
 Im folgenden werden zwei Ansätze diskutiert, wie dies bewerkstelligt werden
 könnte.
 Abbildung 15 zeigt die Situation: Es wurden drei Aufnahmen gemacht, davon
 wiederum zwei Differenzbilder.
 Die zeitliche Abfolge der gefundenen Punkte ist mit den Zahlen 1 bis 3
 gekennzeichnet.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/timed-position/frames1.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/timed-position/frames2.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Zeitliche Abfolge 
\begin_inset Formula $Differenz(Bild_{x},Bild_{x+1})$
\end_inset

 und 
\begin_inset Formula $Differenz(Bild_{x+1},Bild_{x+2})$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der erste Ansatz bezieht sich auf die im Differenzbild per Threshold gefundenen
 Blobs.
 Die gefundenen Positionen könnten mit dem im vorigen Differenzbild gefundenen
 Punkt verglichen werden.
 Der noch unbekannte Punkt ist der neue resultierende Punkt.
 Im Gegensatz zum oben genannten Interpolationsverfahren wird hier immer
 die aktuelle und richtige Position gefunden.
 Dieses Vorgehen erhöht jedoch die Komplexität des Algorithmus, da zusätzliche
 Fallunterscheidungen gemacht werden müssen.
 So muss separat unterschieden werden, was das Finden eines einzelnen Blobs
 nun bedeutet.
 Ansätze wären den Mittelpunkt oder Schwerpunkt zu berechnen oder genauere
 Analysen im Bild vorzunehmen.
 Man muss sich jedoch bewusst sein, dass Mischen von Interpolation mit Messung
 den Nachteil hat, dass Grössen wie Position und Geschwindigkeit verschwommen
 werden.
 Bei einem einzelnen grossen Blob wäre die Interpolation ungenau und korrelliert
 nicht mit den Messinformationen, die aus vorherigen zwei Blobs gewonnen
 wurde.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs-overlay/diff1.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs-overlay/diff2.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs-overlay/diff3.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Problematische Einzelfunde
\end_layout

\end_inset


\end_layout

\end_inset

Der Vorteil, wenn man Tests haben gezeigt, dass das aktuelle Interpolationsverfa
hren genügend genau ist.
\end_layout

\begin_layout Subparagraph
Genauere Punktposition
\end_layout

\begin_layout Subparagraph
Position per Faltung
\end_layout

\begin_layout Subsubsection
Umsetzung
\end_layout

\begin_layout Paragraph
Laufzeit
\end_layout

\begin_layout Standard
Falls schon Punkte gefunden wurden, wird zuerst nur ein Bildausschnitt um
 den zuletzt gefundenen Punkt analysiert.
 Im Erfolgsfall spart das Rechenzeit.
 Falls man im Bildausschnitt kein Punkt findet, wird die Suche auf das ganze
 Bild ausgeweitet.
\end_layout

\begin_layout Paragraph
Eigenschaften eines Lichtpunktes
\end_layout

\begin_layout Standard
Ein von einem Stift erzeugter Lichtpunkt hat diverse Eigenschaften.
 Im Folgenden werden diese genauer ausgeführt.
\end_layout

\begin_layout Subsubsection
Einschränkungen
\end_layout

\begin_layout Standard
- Das Licht hat eine wichtige Rolle gespielt.
\begin_inset Newline newline
\end_inset

- Es wurde eine einfache Laptopkamera eines T430s verwendet (640x480px à
 40ms).
\begin_inset Newline newline
\end_inset

- Der Weissabgleich ist lästig.
\begin_inset Newline newline
\end_inset

- Die Einstellungen zum Weissabgleich können unter Windows nur per DirectShow
 Menu eingestellt werden.
 
\end_layout

\begin_layout Subsubsection
Wahl des Stiftes
\end_layout

\begin_layout Standard
Leuchtwerkzeug über optisches Licht für Proof Of Concept.
 Wahrscheinlich würde in einem Produkt Infrarot-Technologie eingesetzt.
\end_layout

\begin_layout Itemize
Glühbirne
\end_layout

\begin_layout Itemize
LED
\end_layout

\begin_layout Itemize
Laser Pointer, Frequenzband
\end_layout

\begin_layout Itemize
Infrarot Lambsa 1/4 Pass-Filter
\end_layout

\begin_layout Subsection
Input Emulation
\end_layout

\begin_layout Standard
Gemäss Aufgabenstellung war in unserem Fall lediglich eine PowerPoint-Integratio
n gefordert.
 Wir haben uns jedoch überlegt, dass wir mit einer Mausemulation weit mehr
 machen könnten.
 Ausserdem kann man auch PowerPoint mit einer emulierten Maus gut bedienen.
 Zudem haben wir schon Erfahrungen gesammelt, wie man mit C# Mausbefehle
 auf Driver-Level injizieren kann.
 Diesen Weg benutzten ebenfalls Devices anderer Hersteller, wie z.B.
 Logitec Presenter.
 Diese emulieren jedoch eine Tastatur, was für uns nicht sinnvoll, aber
 optional auch möglich ist.
 Unter Windows 8 ist es zudem möglich, Touch-Events zu generieren.
 Damit müssten wir uns nicht mehr um die Analyse der Gesten kümmern, da
 uns das vom Betriebssystem abgenommen wird.
 Da wir jedoch auch ältere Systeme unterstützen wollen, haben wir einen
 Teil der Windows 8 Touch-funktionalität nachgebildet, die wir mit Mausbefehlen
 nachbauen.
 Dies ist z.B.
 ein Rechtsklick durch warten an einem Ort.
\end_layout

\begin_layout Subsection
Erkenntnisse
\end_layout

\begin_layout Section
Ausblick
\end_layout

\begin_layout Section
Anhang
\end_layout

\begin_layout Subsection
Kalibrierung: Bilderkennung
\end_layout

\begin_layout Subsubsection
Selber programmierte Eckdetecktion mit Differenzbildern und zufällig verteilten
 Rechtecken.
 
\end_layout

\begin_layout Subparagraph
Ablauf
\end_layout

\begin_layout Enumerate
Der Bildschirm wird Schwarz gemacht.
 Das entsprechende Bild wird gespeichert.
 
\end_layout

\begin_layout Enumerate
Der Bildschirm wird weiss gemacht und das Differenzbild gemacht.
 Mit 4 Scanlinien werden von jeder Ecke ausgehend unter 45° ein Punkt gesucht,
 dessen Nachbarn in Richtung der gegenüberliegenden Ecke Liegen eine bestimmte
 Deckung besitzen.
 Es wird ein Quadrat mit Seitenlänge 3-5 Pixel berücksichtigt.
 
\end_layout

\begin_layout Enumerate
Es werden 3 Rechtecke mit zufälligen Eckpunkten gezeichnet und die Eckpunkte
 gespeichert, eins pro Farbkanal.
 Auf dem Differenzbild zum Ersten werden mit dem geleichen Verfahren zu
 jedem Farbkanal die Ecken gesucht.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Scanlinien.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Sacnlinien
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Erfolge
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
Ecken des Bildschirms wurden ungefähr erkannt, die meisten der dargestellten
 Rechtecken auch.
 
\end_layout

\begin_layout Subparagraph
Nachteile
\end_layout

\begin_layout Enumerate
Ich habe nur wenig Verbesserungspotenzial bei dieser Lösung gesehen, und
 dieses wäre teuer zu erkaufen gewesen.
 
\end_layout

\begin_layout Enumerate
Da grosse Teile des Bildschirms umgefärbt wurden, gab es Probleme mit der
 Belichtungskorrektur.
 
\end_layout

\begin_layout Enumerate
Die Farbkanäle waren schwierig sauber zu trennen und haben häufig Probleme
 verursacht.
 Überschneidungen waren sehr Problematisch.
 
\end_layout

\begin_layout Subsubsection
Verwendung des AForge-Blob-Detctors
\end_layout

\begin_layout Standard
Diese wird in den kommenden Lösungen immer eingesetzt.
 Ich werde bei jeder Lösung nur auf geänderte und wichtige Aspekte erwähnen.
 Funktionierende Teile wurden jeweils übernommen.
 Die verschiedenen Kalibratoren die Im Code existieren sind keine 1 zu 1
 Umsetzungen der hier beschriebenen Ansätze, sondern Kombinationen davon.
 Der Code von verworfenen Umsetzungen wurde in anderen Umsetzungen teilweise
 Übernommen und aktualisiert.
 Diese Aktualisierungen wurden nicht Nachgepflegt aus dem Grund, dass ich
 diese Lösungen nicht als sinnvoll für ein Weiterverfolgen erachte.
 
\end_layout

\begin_layout Subsubsection
Einfacher Differenzbild-Kalibrator
\end_layout

\begin_layout Enumerate
Als erstes Bild wird der Bildschirm schwarz gefärbt.
 Dieses Bild dient als Grundbild für alle folgenden Differenzbilder 
\end_layout

\begin_layout Enumerate
Der Bildschirm wird komplett weiss gefärbt.
 Auf dem Differenzbild wird der grösste Blob gesucht.
 Das sind dann die Ecken des Bildschirms.
 
\end_layout

\begin_layout Enumerate
Es werden Grüne und blaue Quadrate jeweils versetzt auf den Bildschirm projizier
t, die bei jedem Frame leicht verschoben werden um mehr Referenzpunkte zu
 bekommen.
 Die Erkennung des roten Farbkanals ist am schlechtesten, deshalb verwenden
 wir blau und grün.
 Zwei Farben sind ausreichend, wenn sie mit einem Feld Abstand projiziert
 werden, dass es keine Nachbarschaftskonflikte gibt.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/bgSchachbrett.png
	width 45text%

\end_inset


\begin_inset Formula $\rightarrow$
\end_inset


\begin_inset Graphics
	filename Bilder/Calibration/Scahcbrett erkannt.png
	width 45text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Schachbrettmuster über zwei Farbkanäle
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Diese werden auf dem Differenzbild gesucht.
 Deren Zuordnung wird in einem Folgenden Abschnitt auf Seite ??? behandelt.
 
\end_layout

\begin_layout Standard
Probleme: 
\end_layout

\begin_layout Itemize
Durch die Belichtungskorrektur der Kamera wird ein universeller Hintergrund
 für ein Differenzbild verunmöglicht.
 Es gibt zu viele Fehlerkennungen auf dem Bild.
 
\end_layout

\begin_layout Subsubsection
Histogramm-analyse 
\end_layout

\begin_layout Standard
Hierbei werden keine Differenzbilder gebildet, sondern Helligkeitswerte
 des Bildes analysiert und so können überdurchschnittlich helle Flächen
 (Projektionen) gefunden werden.
 Die restlichen Bildinformationen werden entfernt um eine Blob-Erkennung
 zu ermöglichen.
 
\end_layout

\begin_layout Standard
Durch unterschiedliche Lichtverhältnisse in Bildbereichen ist dieser Ansatz
 anfällig auf Störungen.
 Die Lösung für dieses Problem ist ein aufteilen des Bildes.
 Dabei wird das Bild in verschiedene Regionen aufgeteilt, wo die Helligkeitswert
e weniger stark verteilt sind.
 Anschliesend werden die Flächen wieder zu einem Bild zusammengesetzt.
 
\end_layout

\begin_layout Paragraph
Ablauf
\end_layout

\begin_layout Enumerate
Es wird eine weisse Fläche projiziert.
 Das Bild wird in 2x2 Teile aufgeteilt und der grösste Blob gesucht.
 Das führt zu den Eckepunkten.
 
\end_layout

\begin_layout Enumerate
Es werden die grünen und blauen Quadrate aus dem Vorherigen Verfahren projiziert.
 Das Bild wird in 4 x 4 Teile aufgeteilt und der blaue oder grüne Farbkanal
 separat analysiert.
 In den zwei resultierenden Bildern werden Blobs erkannt und analysiert.
 
\end_layout

\begin_layout Paragraph
Erkenntnisse
\end_layout

\begin_layout Itemize
Die Erkennung der Blobs klappt relativ gut, jedoch sind die Kanten relativ
 unscharf was für eine genaue Erkennung ein Nachteil ist.
 
\end_layout

\begin_layout Itemize
Die automatische Belichtungskorrektur ist kein Problem mehr.
 
\end_layout

\begin_layout Itemize
An den Kanten bei denen das Bild aufgeteilt wurde entstehen häufig Einschnitte
 oder sonstige Ungenauigkeiten.
 Diese sind keine grossen Probleme für den Blob-Detector, jedoch sind sie
 eine weitere Quelle für Ungenauigkeiten.
 Durch eine Filterung nach Grösse erhält man ein gutes Resultat.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/img3.jpg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Erkannte grüne Quadrate
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Erweitertes Differenzbild
\end_layout

\begin_layout Enumerate
Anschliessend werden jeweils zwei Bilder projiziert, deren Differenz genau
 das bekannte Blau-Grüne Muster ergibt.
 Bild So können die Recktecke auf dem Bild ganz scharf und klar erkannt
 werden und identifiziert werden.
 Durch das Bilden eines weiteren Differenzbildes mit den beiden erwünschten
 Farbkanälen kann das meiste Bildrauschen und allfällige Unsicherheiten
 entfernt werden.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/img03-1-0.jpg
	width 45col%

\end_inset

 - 
\begin_inset Graphics
	filename Bilder/Calibration/img03-0-0.jpg
	width 45col%

\end_inset


\end_layout

\begin_layout Plain Layout
=
\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/Colordiff.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Farbmuster
\end_layout

\end_inset


\end_layout

\end_inset

Störungen wie sie hier in der oberen linken Ecke Vorhanden sind können entfernt
 werden, dadurch, dass sie nicht innerhalb der erkannten Bildschirmecken
 liegen.
 Die Grundkalibration ist durchch die Bedingung, dass alle Bildschirmecken
 mindestens 5 Pixel Abstand zu jedem Rand haben müssen.
\end_layout

\begin_layout Subsection
Kalibrierung: Zuordnung von Punkten
\end_layout

\begin_layout Standard
Vom AForge BlobCounter erhalten wir genau alle Blobs die auf dem Kamerabild
 gefunden wurden.
 
\end_layout

\begin_layout Standard
Diese Daten beinhalten: Schwerpunkt, Umfassungsrechteck, Fläche, Breite,
 Höhe.
 Eine Zuordnung zu machen, welcher Blob zu welchen pojizietem Quadrat gehört.
 Durch eine Filterung mit einer vordefinierten minimalen und maximalen Höhe/Brei
te können wir die Blobs filtern und rauschen entfernen.
 Da wir die Ecken des Bildschirms mit Sicherheit kennen, können wir anhand
 des konstruierten Vierecks bestimmen ob ein Blob innerhalb der Projektion
 liegt und andernfalls entfernen.
 Somit können wir jetzt 99% der Fehlerkennungen eliminieren.
 Die Schwerpunkte der Blobs sind jedoch mit Koordinaten des Kamerabildes
 beschrieben, was es für uns schwierig macht, deren Position auf dem Bildschirm
 zu bestimmen, da diese relativ komplex voneinander abhängen.
 So kann z.B.
 die kleinste X-Koordinate zuunterst liegen und die grösste Y-Koordinate
 rechts oben.
 Je nach Verzerrung ist es so schon sehr schwierig nur schon die obere linke
 Ecke zu finden.
 
\end_layout

\begin_layout Paragraph
Mögliche Ansätze
\end_layout

\begin_layout Subsubsection
Rekursiv: 
\end_layout

\begin_layout Standard
Hierbei nehmen wir an, dass die Nachbarn eines Blobs eindeutig bestimmt
 werden können.
 Dies ist möglich anhand der Distanz.
 
\end_layout

\begin_layout Paragraph
Ablauf
\end_layout

\begin_layout Enumerate
Der Algorithmus bestimmt auf jedem Farbkanal denjenigen Blob, der am nächsten
 bei der oberen linken Ecke liegt.
 Durch die Positionsangabe 0|0 für grün oder 1|1 ist bekannt, dass es sich
 um einen Eckpunkt handeln muss.
 Der Punkt wird markiert, dass er nicht nochmals bearbeitet werden muss.
 
\end_layout

\begin_layout Enumerate
Es werden also die zwei nächsten Nachbarn gesucht.
 Anhand der Differenz der der Koordinaten kann bestimmt werden, ob der Punkt
 oberhalb (Y-Differenz ist grösser als die Differenz der X-Achse und negativ),
 rechts (X-Differenz ist grösser und positiv), unten oder links liegt.
 
\end_layout

\begin_layout Enumerate
Die Funktion berechnet die Koordinaten die der gefundene Blob haben muss
 (zwei in die entsprechende Achse verschoben) und startet einen Rekursiven
 Aufruf auf jedem unmarkierten Nachbar, nachdem der Ausgangspunkt als erledigt
 markiert wurde.
 
\end_layout

\begin_layout Enumerate
Der rekursive Aufruf prüft zudem, ob die übergebenen Koordinaten plausibel
 erscheinen und bestimmt anhand deren, wie viele Nachbarn zu erwarten sind.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Rekursion.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Vorgehen Rekursion
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Erkenntnisse
\end_layout

\begin_layout Itemize
Dieser Algorithmus funktioniert perfekt unter synthetischen Umständen, d.h.
 mit generierten Bildern.
 
\end_layout

\begin_layout Itemize
Aufgrund des iterativen Vorgehens sollte dieser Algorithmus in der Lage
 sein, um Bereiche, in denen keine Blobs gefunden wurden, herumzugehen.
 
\end_layout

\begin_layout Itemize
Wenn ein Quadrat nicht erkannt wurde, wird meist die Diagonale als nächster
 Nachbar gefunden, das für die folgende Erkennung schwerwiegende Folgen
 hat.
 
\end_layout

\begin_layout Itemize
Häufig werden nicht alle Blobs erreicht.
 Somit werden nicht alle Blobs zugeordnet und Informationen verloren.
 
\end_layout

\begin_layout Itemize
Falsch zugeordnete Blobs können unmöglich identifiziert werden.
 Eine solche hat jedoch für die nachfolgende Interpolation schwerwiegende
 Folgen indem sie in einem Bildbereich das mapping komplett zerstört.
 
\end_layout

\begin_layout Paragraph
Verbesserungen
\end_layout

\begin_layout Itemize
Es wird nicht nur eine erwartete Position gespeichert, sondern mehrere.
 
\end_layout

\begin_layout Itemize
Die Position wird nicht bei der Iteration gespeichert, sondern jedes Mal,
 wenn der Blob als Nachbar gefunden wurde.
 
\end_layout

\begin_layout Itemize
Es wird nicht nur in der linken oberen Ecke gestartet, sondern in allen
 vier Ecken.
 
\end_layout

\begin_layout Itemize
Die finale Position wird festgelegt durch Auswahl der Position, die am häufigste
n bestimmt wurde.
 
\end_layout

\begin_layout Itemize
Man hat die Möglichkeit, die Position anhand eines folgenden ähnlichen Bildes
 zu verifizieren.
 Dabei werden zur Verifikation ausserdem die Daten desjenigen Blobs verwendet,
 der den ähnlichsten Schwerpunkt hat und die sich somit entsprechen sollten.
 
\end_layout

\begin_layout Itemize
Es werden nicht mehr die nächsten Nachbarn gesucht, sondern es wird analysiert,
 auf welcher Achse die Blobs liegen und gezielt dort der nächste Blob gesucht.
 So können Diagonal liegende Punkte nicht mehr die Erkennung stören.
 
\end_layout

\begin_layout Paragraph
Weitere Erkenntnisse
\end_layout

\begin_layout Itemize
Die Ergebnisse sind nur wenig besser geworden und genügen den Anforderungen
 noch nicht.
 
\end_layout

\begin_layout Itemize
Die Fehlerkennungen sind auf folgenden Bildern ähnlich, somit bringt die
 Verifikation praktisch nichts.
 
\end_layout

\begin_layout Itemize
Das Debugging, das schon vorher aufwendig und mühsam zurückzuverfolgen war,
 ist jetzt praktisch unmöglich.
 Man kann nicht mehr herausfinden woher gewisse Werte kommen oder den Ablauf
 rekonstruieren.
 
\end_layout

\begin_layout Subsubsection
Nutzung der Interpolation 
\end_layout

\begin_layout Standard
Hierbei wird ausgenutzt, dass man anhand der Interpolation mit den Eckpunkten
 die Bildschirmkoordinaten ungefähr voraussagen kann.
 Es gibt dazu mehrere Möglichkeiten, die im Abschnitt ??? beschrieben werden.
 
\end_layout

\begin_layout Paragraph
Ablauf: 
\end_layout

\begin_layout Enumerate
Man iteriert durch die Blobs und bestimmt zu jedem die Interpolation des
 Schwerpunkts.
 
\end_layout

\begin_layout Enumerate
Es wird überprüft, in welchem Quadrat der Schwerpunkt zu liegen kommt.
 Falls das Quadrat die gleiche Farbe hat, wird die Position als gültig angenomme
n.
 
\end_layout

\begin_layout Paragraph
Vorteile 
\end_layout

\begin_layout Itemize
Mit dieser Methode können Abweichungen von +- einem Quadrat erkannt werden.
 
\end_layout

\begin_layout Itemize
Es gibt praktisch keine Fehlerkennungen.
 
\end_layout

\begin_layout Itemize
Durch vergrössern der Quadrate kann die Erkennung verbessert werden.
 
\end_layout

\begin_layout Itemize
Dieses Verfahren ist viel performanter als andere.
 
\end_layout

\begin_layout Paragraph
Nachteile
\end_layout

\begin_layout Itemize
+ieses Verfahren ist von einer guten interpolation abhängig.
 
\end_layout

\begin_layout Itemize
Wenn dieses jedoch gut ist, erübrigen sich weitere Kalibrationsschritte.
 
\end_layout

\begin_layout Itemize
Mit einem linearen Ansatz werden nur ein kleiner Teil der Blobs korrekt
 erkannt, die meisten bleiben ungültig.
\end_layout

\begin_layout Itemize
Durch Vergrösserung der Quadrate wird die Menge der nutzbaren Daten ebenfalls
 verkleinert.
\end_layout

\begin_layout Itemize
Vereinzelt kommt es mit dem linearen Ansatz zu Fehlerkennungen, die als
 gültig erkannt werden.
 Dies resultiert in schwerwiegenden Fehlern bei kommenden Schritten und
 kann nicht detektiert werden.
\end_layout

\begin_layout Subsubsection
Strahlensatz
\end_layout

\begin_layout Standard
Es wird ein physikalisches Modell mit einer Lochkamera erstellt.
 Durch Anwendung des Strahlensatzes kann ein mapping erstellt werden.
 
\end_layout

\begin_layout Standard
Eine zusätzliche Voraussetzung dafür ist dafür ist, dass die Projektion
 ein rechtwinkliges Dreieck ist.
 Das heisst, dass die Trapezkorrektur des Beamers immer zwingend ausgeführt
 werden muss.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Lochkamera.emf
	lyxscale 30
	width 30col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Lochkamera Modell
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
K-Means Cluster-zuordnung mit steigender Genauigkeit
\end_layout

\begin_layout Paragraph
Ablauf
\end_layout

\begin_layout Enumerate
Es werden die Eckpunkte des Bildschirms erkannt.
 
\end_layout

\begin_layout Enumerate
Alle Kanten werden in der Mitte geteilt und deren Mittelpunkte visualisiert.
 
\end_layout

\begin_layout Enumerate
Die erkannten Punkte werden mit K-Means zu den erwarteten Werten zugeordnet.
 
\end_layout

\begin_layout Enumerate
Aus dem Ergebnis resultieren weitere Rechtecke, auf denen das Verfahren
 wieder angewandt werden kann.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Clustering.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Ablauf K-Means
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Erkenntnisse 
\end_layout

\begin_layout Itemize
Es ist schwierig die Punkte an den Rändern zu visualisieren und zu erkennen.
 Der Grund dafür liegt darin, dass man nicht über die Kanten des Beamers
 hinaus projizieren kann.
 Die Lösung dafür haben wir erreicht durch Analyse der Kanten der Blobs
 an den Rändern.
 
\end_layout

\begin_layout Itemize
Ein fehlender Punkt könnte aus den anderen interpoliert werden.
 
\end_layout

\begin_layout Itemize
Die Blobs müssen relativ klein projiziert werden, dass die folgenden Schritte
 funktionieren.
 Das erfordert eine genauere Erkennung.
 
\end_layout

\begin_layout Itemize
Fehlerkennungen führen dazu, dass die weiteren Schritte fehlschlagen werden.
 Das ermöglicht eine gute Fehlererkennung.
 
\end_layout

\begin_layout Itemize
Es gibt praktisch keine Fehlerkennungen.
 Stattdessen wird die Erkennung komplett fehlschlagen, auf was besser reagiert
 werden kann.
 
\end_layout

\begin_layout Itemize

\series bold
Diesen Ansatz lohnt es sich weiterzuverfolgen
\series default
.
 
\end_layout

\begin_layout Subsubsection
Open CV Kamerakalibration
\end_layout

\begin_layout Standard
Das OpenCV Framework bietet die Möglichkeit, Webcambilder zu analysieren
 und Schachbrettmuster zu erkennen.
 Anhand von denen wird zu jedem erkannten Muster eine Transformationsmatrix
 erstellt.
 Mit mehreren Erkennungen kann so ein Teil des Bildraums dreidimensional
 erkannt werden.
 
\end_layout

\begin_layout Paragraph
Anwendung
\end_layout

\begin_layout Itemize
Anhand der verschiedenen erkannten Ebenen lassen sich 3d Transformationen
 durchzuführen.
 
\end_layout

\begin_layout Itemize
Die Erkennung klappt nur selten, das ist aber nicht störend, da auch dann
 noch genügend Ebenen vorhanden sind.
 
\end_layout

\begin_layout Itemize
Die Erkennung lässt sich anhand der Parameter nur wenig beeinflussen.
 
\end_layout

\begin_layout Paragraph
Erkenntnisse
\end_layout

\begin_layout Itemize
Die Erkennung hat in meinem Fall nie gekappt.
 
\end_layout

\begin_layout Itemize
Wir brauchen keine 3d Rekonstruktion, nur eine Ebene.
 Dabei nützt uns dieser Algorithmus nur wenig.
 
\end_layout

\begin_layout Itemize
Das Framework ist sehr schlecht dokumentiert.
 
\end_layout

\begin_layout Itemize
Ein umschreiben des Codes auf unsere Anwendung ist viel zu aufwändig aufgrund
 der Komplexität.
 
\end_layout

\begin_layout Itemize
Es gibt abgesehen von offiziellen Codesample praktisch keine Einsatzmöglickeiten.
 
\end_layout

\begin_layout Subsection
Interpolation
\end_layout

\begin_layout Standard
Hierbei geht es darum, wie man anhand der gefundenen Referenzpunkte die
 genauste Interpolation für ein mapping eines Kamerapixels auf eine Bildschirmko
ordinate erhält.
 Diese Verfahren haben wir testweise auch auf die Ecken des erkannten Bildschirm
s angewandt, um die Genauigkeit zu überprüfen.
 
\end_layout

\begin_layout Subsubsection
Lineare Interpolation
\end_layout

\begin_layout Standard
Skizze 
\end_layout

\begin_layout Standard
Hierbei wird ausgenutzt, dass die Verhältnisse der Strecken auf der Abbildung
 identisch bleiben.
 Dies ist in unserem Fall nicht ganz korrekt, da es die perspektivische
 Verzerrung nicht berücksichtigt, was sich nicht schwerwiegend auswirkt,
 jedoch zu einer gewissen Ungenauigkeit führt.
 Nachteile dieses Verfahrens sind zudem, dass in jedem Quadranten des gesuchten
 Punktes ein Punkt gefunden werden muss, die zusammen auf dem Bildschirm
 ein Rechteck bilden.
 Diese Voraussetzung ist für die Eckpunkte gegeben, jedoch ein erschwerender
 Faktor wenn eine unregelmässige Verteilung von Referenzpunkten gegeben
 ist.
 Ausserdem kann dieses Verfahren nur in eine Richtung angewandt werden,
 nämlich von Bildschirmkoordinaten zu Kamerapixeln.
 Dies ist für uns die falsche Richtung, sodass wir alle Werte vorberechnen
 und speichern müssen.
 
\end_layout

\begin_layout Standard
Formel: 
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Lineare Interpolation.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula $Ratio_{X}=\frac{Q_{X}}{Screen_{X}}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula $Ratio_{Y}=\frac{Q_{Y}}{Screen_{Y}}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Berechnung der linearen Interpolation
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Baryzentrische Koordinaten
\end_layout

\begin_layout Paragraph
Funktionsweise
\end_layout

\begin_layout Standard
Baryzentrische Koordinaten beschreiben in jedem n-Eck n Faktoren, die das
 Flächenverhältnis zwischen den Flächen zwischen den Kanten und einem Punkt
 beschreiben.
 Deren Summe ist immer 1.
 Anhand dieser Faktoren lässt sich sehr einfach ein Rebasing durchführen.
 Das heisst, wenn man Die Punkte in einem anderen System hat, die den Eckpunkten
 im Ursprungssystem entsprechen, kann man die Position des Punktes im Zielsystem
 analysieren.
 Dies ist in unserem Fall bei allen Referenzpunkten gegeben.
 Ein Punkt kann sogar bestimmt werden, wenn er nicht innerhalb des Dreiecks
 liegt.
 Wir werden hier dieses Thema nicht weiter behandeln, es gibt viele andere
 Papers, die dieses Thema sehr ausführlich behandeln.
 
\end_layout

\begin_layout Paragraph
Unsere Anwendung
\end_layout

\begin_layout Standard
Byzantinische Koordinaten berücksichtigen leider keine perspektivischen
 Verzerrungen, wie sie bei uns vorkommen, was deren Funktionalität leider
 etwas einschränkt.
 Somit können wir sie nur verwenden, wenn ein Punkt innerhalb oder zumindest
 in der Nähe liegt.
 Andernfalls gibt es extreme Ungenauigkeiten, die ein Resultat unbrauchbar
 machen.
 Wir definieren die Nähe dadurch, dass alle Faktoren kleiner als 1.5 sein
 müssen.
 Wenn sie kleiner als 1 sind ist der Punkt innerhalb.
 Mit 1.5 darf er zu einer Kante eine Fläche gegen aussen aufspannen, die
 maximal der Hälfte der ganzen Fläche entspricht.
 Das entspricht einen maximalen Abstand der halben Dreieckshöhe zur Kante.
 Da die Nutzung von n-Ecken weder zusätzliche Genauigkeit noch sonstige
 Vorteile bringt, nutzen wir Baryzentrische Koordinaten nur in Dreiecken.
 Durch eine Mittelung der resultierenden Koordinaten anhand mehrerer Dreiecke
 können wir die Störungen der Verzerrung etwas minimieren.
 Wenn wir genügend Referenzpunkte haben, fällt das nicht mehr ins Gewicht.
 
\end_layout

\begin_layout Paragraph
Ergebnisse
\end_layout

\begin_layout Standard
Wenn der Beamer und das Notebook nebeneinander stehen, funktioniert die
 Interpolation anhand der Eckepunkte ziemlich gut.
 Wir haben jedoch hauptsächlich unter erschwerenden Umständen getestet.
 Hier gab es bei der linearen Interpolation gewisse Verschiebungen in horizontal
er Richtung.
 Es entspricht nicht unserer erwünschten Genauigkeit.
 Mit den baryzentrischen Koordinaten anhand der Eckpunkte hatten wir anfangs
 sehr viele Ungenauigkeiten.
 Zudem waren Knicke in den Linien sichtbar über die Diagonale.
 
\end_layout

\begin_layout Standard
Eine Mittelung der Ergebnisse aller vier Dreiecke hat jedoch geholfen, die
 Knicke zu eliminieren und die vertikalen Fehlerfaktoren zu eliminieren.
 Dafür haben wir damit Probleme an den Rändern, da dort unrealistische Werte
 entstehen.
 
\end_layout

\begin_layout Standard
Tabelle.
 
\end_layout

\begin_layout Standard
Die horizontale Verschiebung ist je nach Versuchsaufbau ähnlich zum linearen
 Ansatz.
 Mir mehr Referenzpunkten lässt sich dieses Problem aber sicher lösen.
 
\end_layout

\begin_layout Paragraph
Kompensation der Verzerrung
\end_layout

\begin_layout Standard
Wenn nur drei oder vier Referenzpunkte für eine Interpolation verwendet
 werden, ist das Resultat in der aufgespannten Fläche korrekt und sollte
 keine Störungen beinhalten.
 Wenn mit diesem Verfahren jedoch eine Linie über mehrere Dreiecke gezogen
 wird, hat diese an jedem Übergang eine neue Richtung.
 
\end_layout

\begin_layout Standard
Bild.
 
\end_layout

\begin_layout Standard
Das wird von einem Nutzer dadurch wahrgenommen, dass seine gezogene Linie
 nicht gerade ist, sondern Knicke enthält.
 Das wird als störend empfunden.
 
\end_layout

\begin_layout Paragraph
Lösung
\end_layout

\begin_layout Standard
Es wird nicht nur das Resultat eines Vierecks analysiert, sondern direkte
 Nachbarn werden ebenfalls berücksichtigt.
 Durch eine entsprechende Gewichtung sollte das Resultat nicht verfälscht
 werden, aber die Knicke soweit geglättet werden, dass sie den Nutzer nicht
 mehr auffallen.
 Da Baryzentrische Koordinaten leider keine Abstandsfunktion definieren,
 gewichten wir Resultate, die innerhalb liegen doppelt, solche in der Nähe(siehe
 Oben) einfach.
 Anschliessend werden die Werte linear gemittelt.
 So können wir dennoch eine leichte Gewichtung einfügen.
 Erkenntnisse: Interpolation anhand der Eckpunkte: Hierbei ist die Genauigkeit
 identisch mit dem linearen Ansatz, wenn man die vier möglichen Dreiecke
 berücksichtigt und entsprechend gewichtet.
 
\end_layout

\begin_layout Paragraph
Interpolation anhand eines feineren Gitters
\end_layout

\begin_layout Standard
Die Anzahl berücksichtigter Dreiecke ist hier sehr wichtig.
 
\end_layout

\begin_layout Standard
Bilder 
\end_layout

\begin_layout Standard
Gewisse Ungenauigkeiten können jedoch nicht eliminiert werden.
 
\end_layout

\begin_layout Paragraph
Ausblick: Interpolation anhand Vierecken 
\end_layout

\begin_layout Standard
Durch eine bestimmte Erweiterung der Baryzentrischen Koordinaten auf Vierecke,
 welche den Fakt berücksichtigen, dass die Vierecke nicht winkeltreu sind,
 können wir zudem die Verzerrung an den Übergängen korrigieren.
 
\end_layout

\begin_layout Standard
Formel 
\end_layout

\begin_layout Standard
Durch eine entsprechende Gewichtung kann man zu dem die Knicke so interpolieren,
 dass Knicke an den Kanten geglättet werden.
 Das ist gegeben durch die Möglichkeit, dass wir auch Punkte ausserhalb
 des Rechtecks bestimmen können.
 Diese korrigieren jedoch die perspektivische Verzerrung nicht.
 Diesen Faktor können jedoch mit einem feineren Raster kompensieren.
\end_layout

\begin_layout Subsection
Versuche zur Umsetzung von Touch
\end_layout

\end_body
\end_document
