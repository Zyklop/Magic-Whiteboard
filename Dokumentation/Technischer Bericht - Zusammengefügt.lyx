#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language german-ch
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 0
\use_esint 0
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Stichwortverzeichnis
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Presentation Writer
\end_layout

\begin_layout Author
Renato Bosshart, Josua Schmid
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/Setup/writing.jpg
	lyxscale 20
	width 85col%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Abstract
Es wird eine neue digitale Whiteboard-Technologie beschrieben.
 Während herkömmliche digitale Whiteboards viel Geld kosten, verspricht
 das in dieser Arbeit entwickelte System eine günstige Alternative.
 Es wird gezeigt, dass Standardhardware und einfache Algorithmen mit der
 Genauigkeit von herkömmlichen Produkten konkurrenzieren können.
 Mit einem selbst entwickelten günstigen Stift emuliert die Software 
\begin_inset Quotes gld
\end_inset

Presentation Writer
\begin_inset Quotes grd
\end_inset

 Mausklicks auf einer normalen Beamerleinwand - und das auf 4 Pixel genau.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Einleitung
\end_layout

\begin_layout Standard
Die in dieser Arbeit entworfenen und in einem Prototyp eingesetzten Algorithmen
 sollen einer Person ermöglichen, interaktive Präsentationen in einem kleinen
 oder mittelgrossen Sitzungszimmer zu halten.
 Die Person kann ihren eigenen Laptop dafür verwenden.
 Der Laptop wird am lokal vorhandenen Beamer angeschlossen.
 Nach einer kurzen Kalibrierung kann die Person die Präsentation starten.
 Dabei schreibt sie falls gewünscht mit einem virtuellen Stift an die Leinwand.
 Das geschriebene wird aufgezeichnet und wieder auf das Beamerbild projiziert.
\end_layout

\begin_layout Paragraph
Aufbau
\end_layout

\begin_layout Standard
In einem normalen Sitzungszimmer soll ein Vortrag gehalten werden können.
 Dazu sollen Standardausstattung wie Laptop, integrierte Kamera und Beamer
 benutzt werden können.
 Als Addendum wird ein spezieller Stift mitgeliefert.
 Der Stift soll günstig sein.
 Der Aufbau unterliegt zu definierenden Beschränkungen wie Winkel und Raumbeleuc
htung.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Aufbau/rendered-perspective.png
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Beispiel eines Aufbaus in der Perspektive
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Kalibrierung
\end_layout

\begin_layout Standard
Bevor ein Stift auf der Leinwand gefunden werden kann, muss die Erkennungssoftwa
re kalibriert werden.
 Dazu werden folgende Schritte vorgenommen:
\end_layout

\begin_layout Itemize
Laptopkamera so ausrichten, dass der ganze Bereich der Leinwand gefilmt
 werden kann
\end_layout

\begin_layout Itemize
Lichtverhältnisse anpassen falls nötig
\end_layout

\begin_layout Itemize
Projiziertes Bild erkennen und ein Mapping von Kamerakoordinaten zu Bildschirmko
ordinaten berechnen
\end_layout

\begin_layout Paragraph
Präsentation
\end_layout

\begin_layout Standard
Nach der erfolgreichen Kalibrierung kann der Benutzer mit einem speziellen
 Stift an die Leinwand zeichnen.
 Vorläufig ist dieser Stift eine einfache weisse LED.
 Die Person muss darauf achten, dass der Stift für die Kamera sichtbar ist.
 Das erfordert Disziplin.
 Deshalb gilt abzuklären, ob und wie das Präsentationssystem akzeptiert
 wird.
 Es ist einem Benutzer vermutlich zumutbar, nur dann schreiben zu können,
 wenn ihn das Publikum sieht.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Problemstellung
\end_layout

\begin_layout Standard
Diese Arbeit stellt sich verschiedenen Herausforderungen.
 Es soll ein günstiger Stift von einer Standardkamera mittels eines Standardbeam
ers gefunden und erkannt werden können.
 Sowohl bei der dazu verwendeten Hardware als auch bei der Art und Weise
 wie die hier entwickelte Software benutzt werden kann, gibt es Einschränkungen.
 Obwohl das erarbeitete Präsentationssystem zum Ziel hat, einschneidende
 Beschränkungen zu vermeiden, gibt es doch verschiedene Grenzen, die von
 Anfang an definiert sind und als nicht überwindbar gelten.
 Grundsätzlich sind sie physischer und physikalischer Art.
 Im Folgenden werden die Probleme kurz diskutiert.
 Für einen besseren Überblick wird zum Teil kurz angeschnitten wie das jeweilige
 Problem gelöst werden soll.
\end_layout

\begin_layout Subsubsection
Aufnahmegerät
\end_layout

\begin_layout Standard
Das in dieser Arbeit verwendete Aufnahmegerät ist eine integrierte Laptopkamera
 eines Thinkpad T430s mit einer Auflösung von 640x480 Pixel à 30 Bilder
 pro Sekunde.
 Sie übertreibt es völlig mit dem automatischen Weissabgleich, hat aber
 einen in den Treiber integrierten Konfigurationsdialog, mit welchem sich
 das Problem manuell minimieren lässt.
 Allgemein formuliert ist an der verwendeten Kamera die Bildauflösung weniger
 wichtig als eine korrekte Belichtung.
 Das liegt daran, dass die präsentierende Person immer in Bewegung ist,
 mal mehr beleuchtet, mal weniger, und somit ein irritierendes Ungleichgewicht
 für die Kamera schafft.
 Übertriebene Änderungen der Beleuchtung seitens der Kamera übertönen den
 Stift.
 Folglich ist er nicht mehr der hellste Punkte der Aufnahme und wird nicht
 mehr erkannt, bzw.
 gefunden.
\end_layout

\begin_layout Paragraph
Beispiel:
\end_layout

\begin_layout Standard
Abbildung 2 zeigt eine Beamerprojektion einer weissen Fläche.
 Der Raum ist wenig abgedunkelt, damit die Kamera welche die Aufnahme gemacht
 hat, einen weniger starken automatischen Weissabgleich vornimmt.
 Nichtsdestotrotz beträgt die Anzahl völlig weisser Pixel in diesem Bild
 mehr als 11'000.
 Das macht es unmöglich, optisch einen hellen Punkt (Stift) zu finden.
 Eine stärker abgedunkelte Umgebung erhöht den Kontrast und somit auch das
 Problem.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Camera/whitebalance.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Überbeleuchtetes Kamerabild
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Fazit:
\end_layout

\begin_layout Standard
Der automatische Weissabgleich kann über den Hardwaretreiber abgestellt
 werden, erfordert aber einiges an Arbeit (bei Windows schwierig, bei Linux
 einfacher).
 Die verwendeten Geräte müssten genau bekannt sein, um ihre Treiber konfiguriere
n zu können.
 Wahrscheinlich stellt dieser Aufwand ein Hindernis dar, welches man eher
 durch Mitliefern einer eigenen Infrarot-Kamera lösen würde.
 Das hätte den Vorteil, dass sowohl Präsentator als auch Zuschauer nicht
 von sichtbarem Licht abgelenkt würden.
 In dieser Arbeit wird der Einfachheit halber lediglich auf das Finden einer
 von Menschen sichtbaren Lichtquelle eingegangen.
 Es wird angenommen, dass sich alle Konzepte auf nicht sichtbares Licht
 übertragen lassen.
\end_layout

\begin_layout Subsubsection
Präsentationsgerät
\end_layout

\begin_layout Standard
Ein weniger wichtige Rolle als die Kamera spielt der Beamer.
 Weder die Auflösung, noch die Bildwiederholrate spielen eine nennenswerte
 Rolle für die Qualität des Präsentationssystem.
 Die Helligkeitseinstellung ist jedoch wichtig.
 Der in dieser Arbeit verwendete Beamer beleuchtet die Leinwand sehr stark
 und verstärkt dadurch das Problem des automatischen Weissabgleiches der
 Kamera.
 Zur Minimierung des Problems wurde die Helligkeit auf ein schwächeres Niveau
 reduziert.
 Es wurde darauf geachtet, dass die Einstellung als 
\begin_inset Quotes gld
\end_inset

üblich für eine Präsentation
\begin_inset Quotes grd
\end_inset

 wahrgenommen wird.
\end_layout

\begin_layout Subsubsection
Positionierung
\end_layout

\begin_layout Standard
Der Laptop wird so aufgestellt, dass das Sichtfeld der integrierten Kamera
 den Projektionsbereich auf der Leinwand voll umfasst.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Aufbau/wireframe-top.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Beispiel eines Aufbaus von oben
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der Winkel zwischen Projektionsfläche und Laptopkamera hat Auswirkungen
 auf die Genauigkeit des Präsentationssystems.
 Je grösser der Winkel zwischen Kamera und Projektionsfläche ist, desto
 stärker verzerrt nimmt die Kamera das projizierte Bild wahr.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Aufbau/aufbau-verzerrung.png
	lyxscale 50
	width 100col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Leinwand aus drei verschiedenen Blickwinkeln
\begin_inset CommandInset label
LatexCommand label
name "fig:leinwand-verzerrungen"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:leinwand-verzerrungen"

\end_inset

 zeigt die Leinwand aus drei verschiedenen Winkel mit den daraus resultierenden
 einfachen perspektivischen Verzerrungen.
\end_layout

\begin_layout Itemize
Die linke Abbildung zeigt den angenäherten Normalfall: Beamerbild und Laptopkame
ra liegen auf zwei parallelen Ebenen.
 Es wird nur in X-Richtung verzerrt.
\end_layout

\begin_layout Itemize
In der Mitte ist der Optimalfall dargestellt: Die Kamera sieht direkt von
 vorne auf das Beamerbild, d.h.
 die perspektivische Verzerrung ist minimal
\end_layout

\begin_layout Itemize
Rechts ist das Bild in alle Richtungen verzerrt und stellt somit die grössten
 Anforderungen an die Kalibrierung.
\end_layout

\begin_layout Standard
Die Kalibrierung kann die perspektivische Verzerrung nur begrenzt ausgleichen.
 Deshalb kann die Position eines Stiftes nicht immer gut oder in allen Bereichen
 der Leinwand gleich gut erfolgen.
 Zur Vereinfachung des zu lösenden Problems wird im Folgenden jeweils angenommen
, dass die perspektivische Verzerrung lediglich auf der Horizontalen (X-Achse)
 der aufgenommenen Bilder verläuft (linke Abbildung).
 Messungen zur Genauigkeit unseres verwendeten Abbildungsverfahrens (s.u.)
 zeigen, dass die Verzerrung auf der Vertikalen (Y-Achse) vernachlässigt
 werden kann.
\end_layout

\begin_layout Subsubsection
Leinwand
\end_layout

\begin_layout Standard
Es ergeben sich Beschränkungen aus dem Untergrund, auf welchen präsentiert
 wird.
 Unebene oder glänzende Texturen sind ungeeignete Präsentationsflächen,
 da sowohl Kalibrierung als auch Stifterkennung darunter leiden können.
 Grosse Probleme können Reflexionen der Beamerlampe auf der Leinwand verursachen.
 Dies kann passieren, wenn Beamer und Laptop in einem ungünstigen Winkel
 zueinander stehen.
\end_layout

\begin_layout Subsubsection
Laptop
\end_layout

\begin_layout Standard
Bildverarbeitung braucht in der Regel viel Rechenleistung.
 Die in dieser Arbeit entwickelte Software berücksichtigt dies, indem zum
 Teil Kompromisse eingegangen werden um den Leistungsanforderungen gerecht
 zu werden.
 Um eine reibungslose Erkennung zu gewährleisten, sollten 2GHz Doppelkernprozess
oren oder ähnlich verwendet werden.
\end_layout

\begin_layout Subsubsection
Präsentationsweise
\end_layout

\begin_layout Standard
Da der Stift immer von der Laptopkamera gesehen werden muss, ist es am Präsentat
or, die richtige Haltung beim Schreiben anzunehmen.
 Eine gute Art zu präsentieren ist, wenn das Publikum sieht, wo der Präsentator
 hinzeigt.
 Dies hat den Vorteil hat, dass auch die Laptopkamera sieht, wo auf die
 Leinwand geschrieben werden soll.
 Falls sich der Präsentator zwischen Kamera und Leinwand stellt, kann nicht
 mehr geschrieben werden.
 Da in diesem Fall meist auch das Publikum nichts mehr sieht, wird diese
 Einschränkung ohne weiteren Diskurs in Kauf genommen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Setup/IMGP0366.JPG
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Gute Präsentationsweise - Die zeigende Hand ist von Laptopkamera (links)
 und Publikum aus (rechts) sichtbar.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Ergebnis
\end_layout

\begin_layout Standard
Das Resultat erstaunt.
 Die in dieser Arbeit entwickelte Software 
\begin_inset Quotes gld
\end_inset

Presentation Writer
\begin_inset Quotes grd
\end_inset

 kann gewinnbringend für Vorträge eingesetzt werden.
 Die tiefe Auflösung der Kamera von 640x480 Pixel und die schlechten Lichteigens
chaften haben wenig Einfluss auf die Güte des Resultates.
 Eine erfolgreiche Kalibrierung der Kamera, gute Einstellungen der Bildfilter
 und genügend gute Abbildungsalgorithmen mit Interpolation machen dies möglich.
 Optimierungen wie eine hochauflösendere Kamera würden noch genauere und
 bessere Resultate liefern.
 Aus Zeitgründen wurde in der Software zum Teil auf Optimierungen verzichtet.
 Jene die erschlossen wurden, sind jedoch in der schriftlichen Arbeit jeweils
 kurz erwähnt.
\end_layout

\begin_layout Standard
Im Folgenden dieser Arbeit wird genauer darauf eingegangen, wie alle diese
 Zwischenschritte vom Kamerabild bis zum gezeichneten Bildpunkt auf dem
 Beamer analysiert und gelöst wurden.
 Zum einen werden Ideen zum Finden eines Stiftes in einem Kamerabild diskutiert
 zum anderen werden verschiedene Ansätze erarbeitet, die eine näherungsweise
 korrekte Abbildung von Kamera- zu Beamerpunkten ermöglichen.
 Im Anhang werden erweiterte oder fehlgeschlagene Ideen genauer erläutert.
 Zudem wird dort auch die Vision vom virtuellen Touchpanel ausgearbeitet,
 eine Idee, die eventuell auch mit einer optischen Kamera, aber ohne Stift
 lösbar ist.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Setup/writing.jpg
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Presentation Writer - Unterstützung bei Vorträgen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Setup/classic-painting.jpg
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Kleines Gekritzel macht Spass - Trotz der tiefen Tracking-Auflösung von
 640x480 Pixel.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Analyse
\end_layout

\begin_layout Standard
Im Folgenden werden Überlegungen zur Beziehung Beamer-Kamera und zu den
 konkreten Eigenschaften eines Stiftes gemacht.
 Es gilt zu analysieren, wie und ob die oben postulierten Probleme gelöst
 werden können.
 Es wird auf Kamerakalibrierung und Bildverarbeitungsschritte eingegangen.
 Dazu werden eigene Algorithmen beschrieben und analysiert.
 Zuerst werden die für die Kamerakalibrierung nötigen oder/und möglichen
 Schritte diskutiert.
 Danach folgt ein Abschnitt über das Finden eines Stiftes in einem Kamerabild.
\end_layout

\begin_layout Paragraph
Begriffe
\end_layout

\begin_layout Standard
Im folgenden wird jeweils von Beamerbild und Kamerabild gesprochen.
 Das Beamerbild beschreibt das ursprüngliche Bild, welches projiziert wird.
 Es besitzt die Auflösung des Beamers.
 Das Kamerabild ist das von der Kamera aufgenommene Bild.
 Es besitzt die Auflösung der Kamera.
 Auf dem Kamerabild ist die Projektion des Beamerbilder verzerrt sichtbar.
 Ein Stift soll auf diesem verzerrten Bild gefunden und auf das rücktransformier
te Beamerbild abgebildet werden.
 Diese Abbildung wird jeweils beschrieben durch 
\begin_inset Formula $\left(x_{Kamera},y_{Kamera}\right)\rightarrow\left(x_{Beamer},y_{Beamer}\right)$
\end_inset

 oder kürzer durch 
\begin_inset Formula $\left(x_{k},y_{k}\right)\rightarrow\left(x_{b},y_{b}\right)$
\end_inset

.
 Die X-Koordinate läuft im Bild von Links nach rechts.
 Die Y-Koordinate läuft von oben nach unten.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/Camera/Transformation/beamer-grid.jpg
	lyxscale 20
	width 85col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Zu projizierendes Beamerbild
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/Camera/Transformation/camera-grid.png
	lyxscale 20
	width 85col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Das Kamerabild enthält das verzerrte Beamerbild.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/Camera/Transformation/backtransformed-grid.png
	lyxscale 20
	width 85col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Das im Kamerabild gefundene und auf die Beamerauflösung rücktransformierte
 entzerrte Beamerbild
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Generell: Erkennen von Vierecken
\end_layout

\begin_layout Standard
Tauschen mit mit Bilddetekionsalgorithmen!
\end_layout

\begin_layout Subsubsection
Eckpunkte erkennen
\end_layout

\begin_layout Standard
Mit diesem Verfahren werden lediglich die Ecken des Bildschirms erkannt.
 Dafür gibt es mehrere Verfahren, die im nächsten Punkt evaluiert werden.
 Anhand dieser vier Punkte können schon viele verschiede Berechnungen gemacht
 werden und auch die perspektivische Verzerrung kann schon korrigiert werden.
 Aufgrund der Einfachheit dieses Verfahren, ist es sehr stabil aund Fehlertolera
nt.
 Ein weiterer Vorteil esteht darin, dass der Benutzter selber verifizieren
 kann anhand des Kamerabildes, ob die Ecken richtig erkannt wurden.
 Der Nachteil dieses Verfahrens besteht darin, dass man keine zusätzlichen
 Refernezpunkte hat, um die Erkennung zu verbessern.
 Wir haben dieses Verfahren angewandt, da wir mit der Genauigkeit und der
 Fehlertoleranz sehr zufrieden waren.
 Zudem hatten wir zu wenig Zeit, ein Verfahren zu implementieren, das zusätzlich
e Refernzpunkte gut ausgenutzt hätte.
\end_layout

\begin_layout Paragraph
Rekursives traversieren von Vierecken
\end_layout

\begin_layout Standard
Auf einem mehrfarbigen Schachbrettmuster werden Quadrate erkannt mit einem
 weiter unten genannten Verfahren.
 Danach können alle Quadrate rekursiv iteriert werden.
 Die Itaration erhält die Struktur eines Baumes.
 Das Verfahren ist in der Theorie sehr stabil und und kann sehr weit angepasst
 werden.
 Bei fehlenden Erkennungen kann der Algortihmus sogar um eine Lücke herumgehen.
 Bei Versuchen haben wir jedoch gesehen,dass dieses Verfahren sehr Fehleranfälli
g ist.
 Man erhält bis zu 90% Korrektheit, jedoch ist das zu wenig für uns.
 Verbesserungen lassen sich zwar umsetzten, jedoch führen diese zu einer
 stark erhöhten Kopmlexität und tragen nur sehr wenig zur Verbesserung bei.
 Weitere Proble bereiten diesem Algorithmus fehlende Blobs, da dann die
 Diagolale als direkter Nachbar erkannt wird, was verheerende Folgen hat.
 Zudem ist keine Fehlerdetektion möglich.
\end_layout

\begin_layout Paragraph
Nutzung der Interpolation
\end_layout

\begin_layout Standard
Hierbei werden die Rechtecke anhand einer Interpolation zu den Eckpunkten
 zugeordnet.
 Dieses Verfahren ist sehr einfach und es können Fehler mit einer Abweichung
 einer halben Seitenlänge eines Rechteks korrigiert werden und zusätzlich
 eine ganze Seitenlänge detektiert werden.
 Zudem ist dieser Algorithmus sehr performant.
 Er ist allerdings auch auch von einem guten Interpolationsverfahren abhängig,
 was wiederum Referenzpunkte erübrigt.
 Dieser Algorithmus kann durch eine Vergrösserung der Rechtecke stabilisiert
 werden, was wiederum zu weniger Referenzpunkten führt.
 Mit einem schlechten Interpolationsverfahren kann es zu gravierenden Fehlerkenn
ungen kommen.
\end_layout

\begin_layout Paragraph
K-Means Clustering
\end_layout

\begin_layout Standard
Hiermit werden auf dem Bildschirm immer feiner aufgeteilte Cluster erstellt.
 Dieses Verfahren bietet gute Möglichkeiten zur Fehlerdetektion und liefert
 gute Ergebnisse.
 Mit der Fehlerdetektion kann man alle üblichen Fehlerkennungen ausschliessen.
 Allerdings ist es ziemlich intolerant gegenüber Fehlerkennungen und stellt
 ziemlich hohe anforderungen an das Kamerabild.
 Ebenso ist die Anzahl der Nutzbaren referenzpunkte von der Kameraauflösung
 abhängig.
 Dieses Verfahren ist sehr genau und stabil, jdoch stellt es erhöhte Anforderung
en, die dazu führen, dass die Kalibhration nicht immer klappt.
\end_layout

\begin_layout Subsection
Kalibrierung: Referenzpunkte
\end_layout

\begin_layout Standard
Der Beginn der Kalibrierung bildet das Finden von Referenzpunkten.
 Diese Punkte bilden die Orientierung für darauf aufbauende Abbildungen.
 Je nach Güte der Abbildung sind mehr oder weniger gemessene Referenzpunkte
 nötig.
 Die Abbildung vom Kamerabild zum ursprünglich projizierten Beamerbild ist
 eine Transformation 
\begin_inset Formula $\left(x_{k},y_{k}\right)\rightarrow\left(x_{b},y_{b}\right)$
\end_inset

 und lässt sich durch eine Transformationsmatrix mit 11 Freiheitsgraden
 korrekt beschreiben
\begin_inset Foot
status open

\begin_layout Plain Layout
3 Translation, 3 Rotation, 2 Kameranullpunkt, 1 Brennweite, 2 Bildskalierung
 
\end_layout

\end_inset

.
 Falls die Brennweite ausser Acht gelassen und mit einer bekannten Bildskalierun
g gearbeitet wird, hat die Transformation lediglich 8 Freiheitsgrade, welche
 durch 4 Messpunkte gebunden werden können.
 Unsere Implementationen der Abbildungsberechnungen verlassen sich jeweils
 auf die vier gemessenen Eckpunkte der Projektion und lassen somit Linseneffekte
 ausser Acht.
 Messungen haben ergeben, dass auftretende Ungenauigkeiten regelmässig sind
 und sich grösstenteils auf die horizontale Achse beschränken.
 Durch eine einfache Korrekturfunktion lassen sich sichtbare Effekte vermeiden.
 4 Referenzpunkte reichen also für das zu entwickelnde Präsentationssystem.
\end_layout

\begin_layout Paragraph
Selbstimplementierte Eckdetektion mit Differenzbildern
\end_layout

\begin_layout Standard
Hierbei werden auf Dizzerenzbildern entlang von Scanlinien Eckpunkte gesucht
 und so Rechtecke gefunden.
 Dieses Verfahren kann auch auf Farbkanäle erweitert werden.
 Dieses Verfahren funktioniert relativ gut auf Billdern mit konstanter Belichtun
gskorrektur und stark unterschiedlichen Helligkeitsverteilungen.
 Diese zwei Faktoren sind in unserer Problemstellung nicht gegeben, was
 die Erkennung erschwert.
 Zudem müssen gewisse Parameter angepasst werden, wenn sich die Raumhelligkeit
 oder die Kamera zu stark unterscheidet.
 Das ist nicht realistisch.
 Eine Weiterentwicklung dieses Lösung haben wir verworfen aufgrund des Verhältni
sses von Aufwand und Ertrag.
\end_layout

\begin_layout Subsubsection
Einfacher Differenzbildansatz
\end_layout

\begin_layout Standard
Bei diesen Verfahren wird ein universeller Differenzbild-Hintergrund verwendet.
 Damit kann der statische Hintergrund des Bildes gut entfernt werden und
 es muss nur ein zusätzliches Bild projiziert werden.
 Somit wird nur wenig zusätzliche Zeit für die Kalibration benötigt.
 Dieser Ansatzt hat dafür Probleme, wenn die Kamera die Belichtungskorrektur
 ändert.
 Dies kommt leider sehr häufig vor, wenn sich die Projektion ändert.
 Da dies genau unser Kalibrationsansatz ist, können wir leider auch diese
 Lösung nicht verwenden.
\end_layout

\begin_layout Subsubsection
Histogramm-Analyse
\end_layout

\begin_layout Standard
Hierbei werden keine Differenzbilder verwendet sondern mit den Aktuellen
 Kamerabildern gearbeitet.
 Darauf analysieren wir die Durchschnittlich Helligkeitsverteilung und die
 Standartabweichung.
 Alles was heller ist, akzeptieren wir.Dadurch müssen bei der Kalibration
 keine zusätzlichen Bilder angezeigt werden.
 Analysen haben jedoch gezeigt, dass der Helligkeitsunterschied zwischen
 verschiedenen Bildteilen (z.B: obere und untere Bildhälfte) viel grösser
 ist als der Projektionsrand.
 Daraus ist die Idee entstanden, das Bild aufzuteilen für die Analyse:
\end_layout

\begin_layout Subsubsection
Histogramm-Analyse auf Bildausschnitten
\end_layout

\begin_layout Standard
Hierbei wird das Bild am Anfang in kleine Ausschnitte aufgeteilt und anschliesse
nd das obige Verfahren angewandt.
 So können wir den Hauptnachteil des obigen Verfahrens eliminieren.
 Die Resultate sind relativ gut, mit dem Nachteil, dass wir keine klaren
 Kanten erhalten, wie dies bei Differenzbildern der Fall ist.
 EIne weitere Konsequenz sind uneinheitliche Übergänge an den Bildausschnitten,
 die jedoch für unsere Eckdetektion keine Rolle spielen.
 Dieses Verfahren funktioniert ziemlich gut, aber die Einschränkung der
 ungenauen Kanten stört uns relativ stark, da wir von diesen abhängig sind.
\end_layout

\begin_layout Paragraph
Individuelle Differenzbilder
\end_layout

\begin_layout Standard
Zu jedem Bild, das angezeigt werden soll, werden zwei Bilder generiert,
 deren Differenzbild genau dem gesuchten Bild entspricht.
 Diese Teilbilder müssen eine identische Helligkeitsverteilung aufweisen.
 Das verdoppelt zwar die Kalibrationszeit dadurch, dass die Zahl der anzuzeigend
en Bilder verdoppelt wird.
 Dafür erhalten wir sehr gute Differenzbilder, deren Kanten sehr genau sind.
 Wir haben uns für diesen Ansatzt entschieden, da man sehr gute Resulate
 erhält und die Kalibrationszeit immer noch im Rahmen liegt und von den
 Nutzern sicherlich akzeptiert werden wird.
\end_layout

\begin_layout Paragraph
Externe Bibliotheken
\end_layout

\begin_layout Standard
OpenCv bietet die Möglichkeit, anhand verschiedener Aufnahmen eines Referenzbild
es einen ganzen Dreidimensionalen Raum zu rekonstruhieren.
 Dafür wird für jede erkannte Ebene eine Transformationsmatrix erstellt,
 die anschliesend kombiniert werden und eine Rücktransformation auf den
 Raum erlauben.
 Da wir jedoch nur auf eine einzelne Ebene abbilden können, hätten wir diesen
 Algorithmus stark anpassen müssen.
 Dies war uns jedoch aufgrund der enormen Komplexität dieses Codes nicht
 möglich.
 In einem weiten versuch haben wir mit verschieden Testbildern versucht,
 einzelne Transformationsmatrizen zu erhalten.
 OpenCv hat jedoch zu keinem einzigen Testbild ein Resultat geliefert, obwohl
 wir die spezifizierten Refernzbilder verwendet haben.
 Zudem liefert OpenCv keine Fehlerbeschreibungen, was uns Anpassungen erlaubt
 hätte.
 Ein weiterer Nachteil besteht darin, dass das komplette 600 MB grosse Framework
 mitgeliefert werden müsste, auch wenn man nur einen Teil davon verwendet.
\end_layout

\begin_layout Subsection
Kalibrierung: Abbildung & Interpolation
\end_layout

\begin_layout Standard
Um einen Stift zu tracken ist es notwendig, dass im Kamerabild gefundene
 Punkte auf ursprüngliche Punkte im projizierten Bild (Beamerbild) abgebildet
 werden können (
\shape italic
Kamerakoordinaten
\begin_inset Formula $\rightarrow$
\end_inset

Beamerkoordinaten
\shape default
).
 In der Praxis wird dies aufgrund von Beschränkungen wie der tiefen Kameraauflös
ung und der Grösse des Stiftes nicht perfekt möglich sein.
 Es gilt eine Funktion zu finden, welche diese Abbildung möglichst gut annähert.
 Dazu wurden verschiedene Ansätze analysiert, welche im Folgenden beschrieben
 werden.
\end_layout

\begin_layout Subsubsection
Linear
\end_layout

\begin_layout Standard
Der lineare Ansatz berücksichtigt weder perspektivische Verzerrung noch
 Linseneffekte.
 Es wird davon ausgegangen, dass die Verhältnisse der Punkt zu den Ränden
 in beiden Abbildungen identisch sind.
 Wenn keine perspektivische Verzerrung vorhanden ist, funktionier dieses
 Verfahren korrekt.
 Sonst werden keine Anforderungen an das Bild gestellt.
 Das heisst, dass die Genauigkeit dieses Verfahrens abhängig von der Distanz
 zwischen der Linse des Beamers und der Kamera ist.
 Wenn diese nebeneinanderstehen funktioniert dieses Verfahren sehr gut.
 Bei diesem Verfahren werden nur die Eckpunkte für die Berechnung benötigt.
 Da dieses Verfahren nur in eine Richtung funktioniert, müssen einmalig
 alle möglichen Werte Berechnet werden, dafür sind nacher keine Berechnungen
 mehr nötig, ein einfacher Lookup reicht dafür.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open
\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Lineare Interpolation.emf
	lyxscale 30
	width 100col%
\end_inset

\begin_layout Plain Layout
\begin_inset Caption
\begin_layout Plain Layout
Lineare Interpolation
\end_layout
\end_inset
\end_layout
\end_inset

\end_layout

\begin_layout Paragraph
Baryzentrische Koordinaten
\end_layout

\begin_layout Standard
Hierbei werden die Baryzentrischen Koordinaten aus verschiedenen Dreiecken
 berechnet, zurückgerechnet und anschliessend alle Resultate gemittelt.
 Dadurch erhält man eine Genauigkeit, die proportional zur Anzahl Refernzpunkte
 steigt.
 Zuden ist der Algorithmus relativ einfach verständlich und gut testbar.
 Diese Berechnung brücksichtigt allerdings nicht, dass die Abbildung nicht
 Wikeltreu ist, was zu Fehlern führt und zu ungenauigkeiten fürht.
 Für die Mittelung ist leider nur eine begrenzte Gewichtung möglich, da
 keine Abstandsfunktion definiert ist.
 Durch übergänge und die mangelnde Gewichtung erhält man an den Übergängen
 unter Umständen Knicke in geraden Linien, was der4 Benutzer als störend
 empfindet.
 Wenn viele Dreiecke verwendet werden, führt dies zu einer besseren Korrektur
 von lokalen Ungenauigkeiten und etwas sanfteren Übergängen, allerdings
 wird dadurch auch der Rechenaufwand erhöht.
\end_layout

\begin_layout Subsubsection
Zweidimensional per Integration
\end_layout

\begin_layout Standard
Der schlussendlich in der Software verwendete Ansatz zur Punktabbildung
 berücksichtigt die perspektivische Verzerrung in X-Richtung.
 Dafür wird ein vereinfachtes zweidimensionales Lochkameramodel verwendet.
 Der leichtere Einstieg bietet die Abbildung von Beamer zu Kamera.
 Die mathematische Umkehrung wird erst nach der nun folgenden Herleitung
 gemacht.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagramme/Mathematik/2d-ansatz-lochkamera.emf
	lyxscale 20
	width 85col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Vereinfachtes Lochkameramodell - Es wird über die Strecke das Beamerbild
 in X-Richtung integriert.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Abbildungsfunktion 
\shape italic
Beamer
\begin_inset Formula $\rightarrow$
\end_inset

Kamera
\shape default
 benutzt die Tatsache, dass Strecken von Beamerbild zu Kamerabild verschieden
 aber herleitbar verschieden verzerrt sind.
 Konkret wird benutzt, dass eine Strecke links auf dem Beamerbild um einen
 Faktor 
\begin_inset Formula $a$
\end_inset

 gestreckt oder gestaucht auf das Kamerabild abgebildet wird.
 Auf der rechten Seite des Beamerbildes ist dies ein anderer Faktor 
\begin_inset Formula $b$
\end_inset

.
 Über die X-Koordinaten des Beamerbildes kann nun ein Integral definiert
 werden, welches diese Abbildung von links nach recht durchläuft und all
 diese Streckungen/Stauchungen indefinitdesimal aufsummiert bis zur Beamerpositi
on 
\begin_inset Formula $x_{b}$
\end_inset

, die gesucht ist.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
x_{k}\left(x_{b}\right)=\intop_{0}^{x}a\left(1-x_{b}\right)+bx_{b}\delta x_{b}=\frac{1}{2}\left(b-a\right)x_{b}^{2}+ax_{b}\label{eq:xk-aus-xb-quadratisch}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Die Mathematische Umkehrfunktion (
\shape italic
Kamera
\begin_inset Formula $\rightarrow$
\end_inset

Beamer
\shape default
) bildet jedes 
\begin_inset Formula $x_{k}$
\end_inset

 auf ein 
\begin_inset Formula $x_{b}$
\end_inset

 ab und ist durch das Lösen der quadratischen Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:xk-aus-xb-quadratisch"

\end_inset

 herleitbar.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
x_{b}\left(x_{k}\right)=\frac{\sqrt{a^{2}+2x_{k}(b-a)}-a}{b-a}\label{eq:xb-aus-xk-quadratisch}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Mathematik/xk-aus-xb-quadratisch.emf
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Graph der Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:xb-aus-xk-quadratisch"

\end_inset

 für 
\begin_inset Formula $a=2$
\end_inset

, 
\begin_inset Formula $b=1$
\end_inset

 (blau): In der Mitte weicht die perspektivische Verzerung in X-Richtung
 mehr vom linearen Ansatz (violett) ab als am Rand.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zu beachten gilt, dass der Ursprung des verzerrten Beamerbildes nicht unbedingt
 auf den Ursprung des Kamerabildes zu liegen kommt.
 
\begin_inset Formula $x_{b}$
\end_inset

 und 
\begin_inset Formula $x_{k}$
\end_inset

 müssen also um einen gemessenen Offset angepasst werden, bevor die jeweilige
 Abbildung ausgerechnet wird.
 In der hier beschriebenen Lösung wird nicht der korrekte Offset verwendet
 (Schnittpunkt der zwei zur Gerade verlängerten Abschnitte Kamerabild und
 Beamerbild).
 Es wird jeweils nur der Offset zum Kamerabildanfang verwendet.
 Dies hat zur Folge, dass resultierende X-Koordinaten gleichmässig zu lang
 oder zu kurz sind (je nach Abbildungsrichtung).
 Damit nicht der Schnittpunkt der zwei Ebenen Kamera und Beamer berechnet
 werden muss, wird in dieser Arbeit jeweils die berechnete X-Strecke auf
 die berechnete Maximalstrecke gegenüber der gemessenen Maximalstrecke normiert
 (Stauchung 
\begin_inset Formula $s$
\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
s=\frac{x_{maxmeasure}}{x_{maxcalc}}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Für die Abbildung der Y-Koordinaten wird ein von X abhängiger linearer Ansatz
 verwendet.
 Wieder spielt dabei der Gedanke eine Rolle, dass die rechte und die linke
 Seite des verzerrten Kamerabildes etwa parallel sind.
 
\begin_inset Formula $y_{k}$
\end_inset

 wird durch eine von 
\begin_inset Formula $y_{b}$
\end_inset

 abhängige Gerade definiert - sie wird mit 
\begin_inset Formula $x_{b}$
\end_inset

 durchlaufen.
 Die Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:yk-aus-yb-linear"

\end_inset

 beschreibt die Abbildung 
\shape italic
Beamer
\begin_inset Formula $\rightarrow$
\end_inset

Kamera.
 
\shape default
Dabei beschreibt 
\begin_inset Formula $y_{k0}$
\end_inset

 den vertikalen Offset zwischen linker und rechter Bildlinie.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
y_{k}\left(x_{b}\right)=\left(ay_{b}+y_{k0}\right)\left(1-x_{b}\right)+by_{b}x_{b}\label{eq:yk-aus-yb-linear}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Die Mathematische Umkehrfunktion (
\shape italic
Kamera
\begin_inset Formula $\rightarrow$
\end_inset

Beamer
\shape default
) bildet jedes 
\begin_inset Formula $y_{k}$
\end_inset

 auf ein 
\begin_inset Formula $y_{b}$
\end_inset

 ab und ist mit Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:yb-aus-yk-linear"

\end_inset

 beschrieben.
 Steigung und Offset der Geraden wird dabei durch 
\begin_inset Formula $x_{b}$
\end_inset

 kontrolliert.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
y_{b}\left(y_{k}\right)=\frac{x_{b}y_{k0}+y_{k}-y_{k0}}{a(-x_{b})+a+bx_{b}}\label{eq:yb-aus-yk-linear}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Mathematik/yk-aus-xb-linear.emf
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Sample der Gleichungen 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:yk-aus-yb-linear"

\end_inset

.
 Der gezeigte Ausschnitt bildet genau das verzerrte Beamerbild nach, wobei
 
\begin_inset Formula $x_{b}$
\end_inset

 auf einen Wert zwischen 0 und 1 normiert ist.
 
\begin_inset Formula $y_{k}$
\end_inset

 ist der Pixelwert ind Y-Richtung auf dem Kamerabild.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Mathematik/yb-aus-xk-linear.emf
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Sample der Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:yb-aus-yk-linear"

\end_inset

.
 Werte zwischen 0 und 400 werden auf das Beamerbild rückprojiziert.
 Das Beamerbild wird jedoch nur getroffen, wenn 
\begin_inset Formula $y_{b}$
\end_inset

 zwischen 0 und 1 resultiert.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Beispiel
\end_layout

\begin_layout Standard
Die Güte dieses Ansatzes wurde gemessen.
 Dazu wurde ein Bild an eine Leinwand projiziert und mit einer einfachen
 Laptopkamera aufgenommen.
 Die verzerrten projizierten Punkte des Beamerbildes wurden manuell auf
 dem Kamerabild gemessen und den ursprünglichen Punktpositionen auf dem
 Beamerbild zugewiesen.
 Die gemessenen Punkte des Kamerabildes wurden mit den in den Gleichungen
 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:xb-aus-xk-quadratisch"

\end_inset

 und 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:yb-aus-yk-linear"

\end_inset

 beschriebenen Ansätzen auf Beamerkoordinaten umgerechnet.
 In Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:kamera-messung-berechnung"

\end_inset

 ist das Resultat ersichtlich.
 Die Schräge im rechten Teil der Abbildung rührt davon, dass die linke und
 die rechte Seite des abgebildeten Beamerbildes nicht genau parallel sind.
 Die Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:beamer-rueckrechnung-quadratisch"

\end_inset

 zeigt die Rückberechnung der agebildeten auf die abzubildenden Koordinaten.
 Im Weiteren ist anzumerken, dass als linke und rechte Bildlinien jeweils
 genau senkrecht verlaufende gemittelte Geraden verwendet wurden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Mathematik/quadratische-berechnung-ohne-bary.emf
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Die gemessenen Punkte weichen von den geschätzen (berechneten) ab.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:kamera-messung-berechnung"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Mathematik/quadratische-rueckberechnung-ohne-bary.emf
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Vergleich zwischen Projektion und Berechnung.
 Die Schräge der linken und rechten Bildlinien ergibt Abweichungen.
\begin_inset CommandInset label
LatexCommand label
name "fig:beamer-rueckrechnung-quadratisch"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Baryzentrische Viereck-Korrektur
\end_layout

\begin_layout Standard
Die im Beispiel ersichtlichen Abweichungen lassen sich zumindest an den
 Ecken mit einer baryzentrischen Viereck-Korrektur beheben.
 Dieses Verfahren 
\begin_inset Quotes gld
\end_inset

zieht
\begin_inset Quotes grd
\end_inset

 alle Punkte in Richtung der Referenzpunkte eines vierdimensionalen baryzentrisc
hen Koordinatensystems.
 Das Resultat ist in Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:messung-projektion-mit-bary"

\end_inset

 blau markiert.
 Das Resultat wird an den meisten Orten besser.
 Sehr viel besser wird es an den Rändern.
 Dieses Verfahren kann auch bei der Rückabbildung (
\shape italic
Kamera
\begin_inset Formula $\rightarrow$
\end_inset

Beamer
\shape default
) angewendet werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Mathematik/quadratische-berechnung-mit-bary.emf
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Baryzentrische Korrektur gibt beinahe überall ein besseres Resultat.
\begin_inset CommandInset label
LatexCommand label
name "fig:messung-projektion-mit-bary"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die baryzentrische Vierecks-Korrektur bildet die gemessenen Eckpunkte der
 
\end_layout

\begin_layout Standard
TODO: genauer beschreiben.
\end_layout

\begin_layout Paragraph
Pragmatische Korrektur
\end_layout

\begin_layout Standard
Tests in der Praxis haben ergeben, dass nicht nur die perspektivische Verzerrung
 eine Rolle spielt.
 Vorallem wenn der Winkel zwischen Kamera und Beamer vergrössert wird, sind
 systematisch stärkere Abweichungen sichtbar.
 Linseneffekte und Trapezkorrektur des Beamers wurden in dieser Arbeit nicht
 weiter modelliert.
 Stattdessen wird für alle zusätzlichen Abweichungen eine quadratische Korrektur
funktion über die X-Richtung gelegt.
 Sie soll nicht ausgearbeitete Abweichungen symmetrisch ausgleichen.
 Die Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:pragmatische-korrekturfunktion"

\end_inset

 beschreibt die zur Korrektur verwendete Funktion.
 Sie geht durch 0 und 1 und hat ein durch 
\begin_inset Formula $h$
\end_inset

 festgelegtes Maximum bei 0.5.
 Wie 
\begin_inset Formula $h$
\end_inset

 zu wählen ist, hängt von der bei 0.5 zu korrigierenden Abweichung ab.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
y_{corr}\left(x\right)=-4hx^{2}+4hx\label{eq:pragmatische-korrekturfunktion}
\end{equation}

\end_inset


\end_layout

\begin_layout Subsubsection
Homogene Transformation
\end_layout

\begin_layout Standard
Die Abbildung von Punkte zwischen Kamera und Beamer mittels homogener Transforma
tion wurde nur kurz angetestet.
 Eine sauber erarbeitete Transformationsmatrix verspricht sehr genaue Resultate.
 Die für das traditionelle Lochkameramodell benötigte Matrix wird durch
 11 Freiheitsgrade beschrieben
\begin_inset Foot
status open

\begin_layout Plain Layout
3 Translation, 3 Rotation, 2 Kameranullpunkt, 1 Brennweite, 2 Bildskalierung
 
\end_layout

\end_inset

.
 Es reichen also 5.5 gemessene Referenzpunktpaare.
 Da dieses Vorgehen erweiterte mathematische Kenntnisse voraussetzt, wurde
 es nicht genauer untersucht.
 Programmbibliotheken wie OpenCV unterstützen diese Art der Transformation
 nativ und schnell
\begin_inset Foot
status open

\begin_layout Plain Layout
Der interessierte Leser möge folgenden Artikel über die benötigten Transformatio
nsmatrizen konsultieren: http://de.wikipedia.org/wiki/Homogene_Koordinaten#Wichtig
e_elementare_homogene_Transformationsmatrizen
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Baryzentrische Vierecke mit Korrekturfaktor
\end_layout

\begin_layout Standard
Durch eine eigene erweiterung der baryzentrischen Koordinaten können wir
 berücksichtigen, dass die Rechtecke nicht winkeltreu sind.
 Dies geschieht durch einen vierten Punkt der ebenfalls berücksichtigt wird.
 Dies führt zu einer viel genaueren Interpolation.
 Der Algorithmus benötigt jedich eine strukturierte Ordnung der Referenzpunkte,
 was ihn geringfügig konplizierter macht.
 Allerdings ist durch die ordnung auch eine Gewichtung möglich.
 Dieser Algorithmus führt zu einem guten Resultat, allerdings stellt er
 hohe Anforderung an die Referenzpunkte.
 Diese Ansprüche können allerdings mithilfe des K-Means Clusterings erfüllt
 werden.
\end_layout

\begin_layout Subsection
Kalibrierung: Projizieren und Messen
\end_layout

\begin_layout Standard
Die Lichtverhältnisse sind entscheidend für eine erfolgreiche Messungen.
 Für die Kalibrierung projizierte Referenzbilder haben Einfluss auf den
 automatischen Weissabgleich der Kamera.
 Grosse Helligkeitswerte im projizierten Bild verursachen schnelles Abdunkeln
 des Kamerabildes, tiefe Helligkeitswerte das Gegenteil.
 Es kann nicht genau vorausgesagt werden, wie die Kamera auf Helligkeitsuntersch
iede reagiert.
 In jedem Fall hat dies Einfluss auf in der Kalibrierung verwendete Differenzbil
der.
 Der hier beschriebene Effekt kann minimiert werden, wenn nur Bilder mit
 im Mittel ähnlichen Helligkeitswerten verwendet werden.
 Die schlussendlich eingesetzte Lösung verwendet zwei Schachbrettmuster,
 deren Durchschnittshelligkeiten beinahe gleich sind.
 Die Kamera passt den Weissabgleich kaum an.
 Dies wird unter 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Schachbrett-Differenz"

\end_inset

 genauer beschrieben.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/WhitebalanceFail/frame1.jpg
	lyxscale 20
	width 50col%

\end_inset


\begin_inset Graphics
	filename Bilder/Calibration/WhitebalanceFail/frame2.jpg
	lyxscale 20
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Zwei schlecht gewählte Referenzbilder.
 Sie haben zu grosse Helligkeitsunterschiede.
\begin_inset CommandInset label
LatexCommand label
name "fig:diff-fail-pictures"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/WhitebalanceFail/diff.jpg
	lyxscale 40
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Das aus Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:diff-fail-pictures"

\end_inset

 resultierende Differenzbild ist für die Leinwanddetektion kaum brauchbar.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Stift Erkennen
\end_layout

\begin_layout Standard
Als Ziel dieser Arbeit soll ein Stift an einer Leinwand gefunden werden.
 Dies soll das virtuelle Schreiben auf diese Leinwand ermöglichen.
 Da Bildverarbeitung auch heute noch viel Rechenleistung benötigt, gilt
 es genau zu wissen, was man wann und wieso tut.
 Das Finden eines Stiftes besteht aus verschiedenen Teilproblemen, die verschied
en zu lösen sind.
 So sind zum Beispiel Präsenz- und Positionsaspekt des Stiftes zu unterscheiden.
 Es ist teilweise nicht unbedingt notwendig zu wissen, wo der Stift auf
 dem Bild ist.
 Falls es einfach ist, die Präsenz des Stiftes festzustellen, nicht aber
 die Position, kann erstere Information verwendet werden um komplizerte
 und rechenintensive Schritte erst anzustossen wenn nötig.
 Neben den verschiedenen vorzunehmenden Schritten, ist auch Kontextwissen
 wichtig.
 Ein Bild kann gezielter nach Präsenz und Position des Stiftes durchsucht
 werden, wenn bekannt ist, wie er sich zeitlich bewegt.
\end_layout

\begin_layout Paragraph
Präsenz durch Helligkeit
\end_layout

\begin_layout Standard
Generell ist es nicht einfach, herauszufinden, ob sich ein Objekt in einem
 Bild befindet.
 Ansätze aus der digitalen Bildverarbeitung wie die Diskrete Fourier-Transformat
ion
\begin_inset Foot
status open

\begin_layout Plain Layout
Die Diskrete Fourier-Transformation erhält die Eigenschaften Verschiebung
 und Skalierung in Zeit und Frequenz.
\end_layout

\end_inset

 oder der Gradientenabstieg mittels dynamischer Bildskalierung
\begin_inset Foot
status open

\begin_layout Plain Layout
James MacLean in 
\begin_inset Quotes gld
\end_inset

Fast Pattern Recognition Using Gradient-Descent Search in an Image Pyramid
\begin_inset Quotes grd
\end_inset


\end_layout

\end_inset

 sind kompliziert und benötigen viel Rechenleistung.
 Die Komplexität des Problems wird immens reduziert, wenn die Eigenschaften
 des Stiftes klarer definiert sind.
 Es wäre möglich, Form, Farbe, Helligkeit, Farbtemperatur, Geschwindigkeit,
 Bewegung, Puls, etc.
 auf einem oder mehreren Kamerabilder zu analysieren.
 Der Einfachheit halber reduzieren wir den Stift auf seine Helligkeit.
 Wir gehen noch weiter und sagen, der Stift ist der hellste Punkt in einem
 Bild.
 Zur Umsetzung könnte ein optisches Licht (ev.
 Infrarot) als Stift verwendet werden.
\end_layout

\begin_layout Paragraph
Präsenz durch Kardinalität
\end_layout

\begin_layout Standard
Der hellste Punkt auf dem Kamerabild bildet den Stift ab.
 Es gibt verschiedene Möglichkeiten den Fall, dass mehrere Spot auftreten,
 zu behandeln.
 
\end_layout

\begin_layout Itemize
Es könnte lediglich der hellste Punkt gewertet werden.
\end_layout

\begin_layout Itemize
Es könnte eine genaue Anzahl Punkte aus dem Kontext gewählt werden.
\end_layout

\begin_layout Itemize
Es könnten alle Punkte verworfen werden.
\end_layout

\begin_layout Standard
Um Fehler zu vermeiden, scheint es sinnvoll, alle undefinierten Zustände
 zu verwerfen, Punkte also nur zu werten, wenn sie alleine in ihrem definierten
 Zustand auftreten.
 Es befindet sich also ein Stift auf dem Kamerabild, wenn ein gewisser Helligkei
tswert überschritten wird.
 Diese Entscheidung ist nur sinnvoll, wenn die Fehlerrate (zu viele Punkte
 erkannt) nicht zu hoch und die Framerate nicht zu tief ist.
\end_layout

\begin_layout Paragraph*
Position durch Mittelwert oder Schwerpunkt
\end_layout

\begin_layout Standard
Die Position des Stiftes hängt vorzugsweise von der Präsenz eines Stiftes
 ab.
 So muss die Position des Stiftes nur dann gesucht werden wenn er präsent
 ist.
 Dies spart Rechenzeit.
 Die oben beschriebenen Kriterien zur Präsenz ergeben jeweils eine Stiftpräsenz.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/theory/light-point.png
	scale 200

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Stehender Lichtpunkt in der Theorie
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die genaue Position des Stiftes befindet sich in der Mittel am hellsten
 Punkt.
 In der Theorie ist das der Mittelwert aller hellen umgebenden Pixel oder
 der Schwerpunkt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs/frame1.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs/frame2.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs/diff.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Frame x, Frame x+1, Differenz - Der Punkt bewegt sich nach rechts unten.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Messungen zeigen, dass ein bewegter Lichtpunkt in der Praxis nicht rund
 ist, sondern in der Bewegungsrichtung gestaucht.
 Die Stauchung wird durch die Belichtung verursacht.
 In der Bewegungsrichtung erfährt der CCD-Sensor der Kamera eine starke
 Intensitätsänderung, während sich die Intensität am Rand der Laufrichtung
 weniger stark ändert.
 Der CCD trägt der starken Änderung mehr Rechnung als der schwachen.
 Im Weiteren ist die Helligkeit des Lichtpunktes vom Zentrum her nicht weich
 abfallend, sonder eher scharfkantig.
 Dies rührt von Reflexionen auf der dahinter liegenden Leinwand.
\end_layout

\begin_layout Standard
Um der Stabilität Willen wird vorgeschlagen, die Position der Stiftposition
 nicht zu genau zu bestimmen.
 Für eine Anwendung, die lediglich auf eine Leinwand zeichnen kann, sollte
 die Mitte einer Umrandung der hellsten Werte mittels fixem Grenzwert reichen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/theory/light-point - thresholded.png
	scale 200

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Per Grenzwert wird der Lichtpunkt in das Zentrum eines Vierecks gelegt.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Gezieltes Suchen
\end_layout

\begin_layout Standard
Ein Algorithmus zum Finden der Stiftposition sollte den erarbeiteten Kontext
 berücksichtigen.
 In einem Bild kann zum Beispiel in der Nähe eines im vorherigen Bild gefundenen
 Punktes gesucht werden.
 So reduziert sich der Aufwand des Algorithmus von 
\begin_inset Formula $O\left(cn^{2}\right)$
\end_inset

auf 
\begin_inset Formula $O\left(c\left(\frac{n}{x}\right)^{2}\right)$
\end_inset

wobei 
\begin_inset Formula $x$
\end_inset

 die Seitenlänge 
\begin_inset Formula $n$
\end_inset

 des Kamerabildes in ein kleineres Suchfenster mit Seitenlänge 
\begin_inset Formula $\frac{n}{x}$
\end_inset

 teilt
\begin_inset Foot
status open

\begin_layout Plain Layout
Asymptotisch wird angenommen, dass das Kamerabild quadratisch ist.
\end_layout

\end_inset

.
 Im Fall, dass entweder keine oder keine brauchbaren Kontextinformationen
 vorhanden sind, kann die Suche auf ein grösseres oder das ganze Suchfenster
 ausgeweitet werden.
 Dies erhöht die Worstcase Laufzeit auf 
\begin_inset Formula $O\left(c\left(\frac{n}{x}\right)^{2}+c\left(y\frac{n}{x}\right)^{2}\right)$
\end_inset

, wobei 
\begin_inset Formula $y$
\end_inset

 der Faktor der Vergrösserung ist.
 Wir denken, dass es reicht, 
\begin_inset Formula $y:=x$
\end_inset

 zu setzen, wenn das erste Suchfenster gut gewählt ist, da die Wahrscheinlichkei
t gross ist, dass entweder gar kein Punkt gefunden wird oder dass sich der
 Punkte entgegen dem Kontext verhält
\begin_inset Foot
status open

\begin_layout Plain Layout
Dies würde den kontextabhängigen Algorithmus per se unbrauchbar machen.
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph*
Stabilität durch Differenzbilder
\end_layout

\begin_layout Standard
Reduktion des Kontextes muss nicht unbedingt wie oben beschrieben zu Instabilitä
t und mehr Fallunterscheidungen führen.
 Zum Beispiel können relevante Informationen durch Differenzbilder hervorgehoben
 und Rauschen unterdrückt werden.
 Sogar Kriterien, die mit den Eigenschaften eines Stiftes konkurrieren,
 wie zum Beispiel helle statische Reflexionen auf der Leinwand können so
 unterdrückt werden.
 Falls Differenzbilder verwendet werden, müssen weitere Überlegungen zur
 Kardinalität der Lichtpunkte gemacht werden.
 Was nun ein oder zwei resultierende Punkte auf dem Bild bedeuten ist nicht
 ganz klar (s.u.).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/rauschen-small.png
	width 50col%

\end_inset


\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/rauschen-small-diff.png
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Auf dem Differenzbild (rechts) ist der Laserpointer Punkt viel besser sichtbar
 als auf dem Quellbild (links).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Umsetzung
\end_layout

\begin_layout Subsection
Technologien
\end_layout

\begin_layout Subsubsection
Programmiersprache
\end_layout

\begin_layout Standard
Wir haben uns für die Programmiersprache C# entschieden, da uns diese besser
 liegt (TODO schnellere Entwicklungszeit...).
 Zudem war es einfacher auf Systemfunktionen wie z.B.
 Direct Show und Mausemulation zuzugreifen.
 In Java wäre das nicht möglich gewesen.
 Mit C++ hätten wir bei der Bildbearbeitung etwas weniger Performance benötigt,
 dafür hätten wir mehr Einarbeitungszeit benötigt.
 Aus unserer Sicht haben wir uns richtig entschieden.
\end_layout

\begin_layout Subsubsection
Framework
\end_layout

\begin_layout Standard
Beim grafischen Framework haben wir uns für AForge entschieden, da es nativ
 in C# geschrieben ist und gut dokumentiert ist.
 Im Gegensatz dazu hätten wir mit OpenCV etwas besser optimierte Algorithmen
 gehabt.
 Da wir nur einen Prototypen produzieren, ist Performance für uns nicht
 besonders wichtig, was unsere Wahl ebenfalls beeinflusst hat.
\end_layout

\begin_layout Paragraph
OpenCV
\end_layout

\begin_layout Standard
OpenCV ist ein riesiges Produkt, das alle Möglichkeiten zur Bildanalyse
 bietet.
 Es gibt einen Wrapper für C#, jedoch hat sich auch dieser in unseren Versuchen
 als nicht besonders einfach in der Benutzung herausgestellt.
 Die Dokumentation ist sehr spärlich gehalten und erleichtert die Benutztung
 nicht.
 Mit der grossen Community sollte es allerdings möglich sein Antworten zu
 erhalten.
 Möglichkeiten, den Code zu analysieren hat man leider aufgrund dessen Komplexit
ät nicht und es gibt keine Möglichkeiten, die Algorithmen auf eigene Bedürfnisse
 anzupassen.
 Ein weiterer Nachteil ist, dass man zur Nutzung das ganze Framework einbinden
 muss, was über 600 MB gross ist.
 Da der Aufwand zur Einarbeitung für uns zu hoch war, haben wir uns gegen
 OpenCv entschieden.
\end_layout

\begin_layout Paragraph
AForge
\end_layout

\begin_layout Standard
AForge bietet eine stabile Blob-Detektion, die zuverlässig funktioniert
 und Attribute zur Analyse und Fehlerdetektion bieten.
 Zudem funktioniert das Anwenden von Filtern auf Bilder sehr zuverlässig
 und intuitiv.
 Die berechnungen sind etwas weniger optimiert als bei OpenCv, allerdings
 reicht die Performance für uns aus.
 Der Code enthält leider immer noch einige Bugs, die jedoch aufgrund der
 guten Verständlichkeit selber behoben werden können.
 Der Entwickler kümmert sich nämlich nicht besonders aktiv um sein Projekt.
 Für einen Prototypen ist die Nutzung ideal, da er einfach zu benutzen und
 gut dokumentiert ist.
\end_layout

\begin_layout Subsection
Architektur
\end_layout

\begin_layout Subsubsection
Domain
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Domain.emf
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Das Domain Modell berücksichtigt modulare Erweiterungen.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Hauptsequenz
\end_layout

\begin_layout Standard
Unser Hauptprojekt wird eine ausführbare Datei, die alle unsere Subprojekte
 zusammenbringt.
 
\end_layout

\begin_layout Standard
\noindent
Grobablauf unseres Programms: 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/SSD.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
SSD
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Enumerate
Verbindung mit der Kamera 
\end_layout

\begin_deeper
\begin_layout Enumerate
Der Nutzer kriegt eine Auswahl aller gefundenen Kameras und entscheidet
 sich für eine.
 
\end_layout

\begin_layout Enumerate
Anhand der Auswahl wird die Kamera angelegt und gestartet.
 
\end_layout

\end_deeper
\begin_layout Enumerate
Das Programm sucht einen passenden Visualisierer und legt diesen an.
 
\end_layout

\begin_layout Enumerate
Ein DataParser wird angelegt.
 
\end_layout

\begin_layout Enumerate
Die Kalibration kann nun automatisch oder nach einer Interaktion des Benutzers
 gestartet werden.
 
\end_layout

\begin_layout Enumerate
Die Details über den Ablauf des Kalibrationsvorgang sind im Abschnitt Kalibratio
n aufgeführt.
 
\end_layout

\begin_layout Enumerate
Kalibration wird erfolgreich abgeschlossen und das Pentracking gestartet.
 Die Details über den Ablauf des Trackings sind im Abschnitt Pen-Tracking
 aufgeführt.
 
\end_layout

\begin_layout Subsection
Visualisierung 
\end_layout

\begin_layout Standard
Ein erstes Problem bot sich uns, als wir versuchten, aus einer Library auf
 den Bildschirm zu zeichnen.
 Das wiederspricht eigentlich allen Architekturmodellen, jedoch ist es bei
 unserer Lösung nötig für die Kalibration.
 
\end_layout

\begin_layout Subsubsection
Probleme
\end_layout

\begin_layout Itemize
Wir wissen nicht, in welcher Umgebung (Anzahl Treads) unsere Library läuft.
 Gewisse Kameras erzeugen zudem verschiede Threads in denen die Frames übergeben
 werden.
 
\end_layout

\begin_layout Itemize
Jedes GUI muss in einem eigenen Thread laufen das ein spezielles ThreadSTA-Attri
but hat.
 
\end_layout

\begin_layout Itemize
Der Garbage-Collector räumt den GUI-Thread ab, selbst wenn er in Zukunft
 noch verwendet werden müsste.
 
\end_layout

\begin_layout Itemize
Wenn ein GUI gestartet wird, öffnet es sich sofort.
 Das ist in unseren Fall nicht erwünscht.
 Ein Hide, das gerade nach dem Start aufgerufen wird, hat keine Wirkung.
 Es muss erst der komplette Start und die Darstellung des GUIs(ca.
 10ms) abgewartet werden, bis es versteckt werden kann.
 
\end_layout

\begin_layout Subsubsection
Umsetzungen
\end_layout

\begin_layout Paragraph
WPF
\end_layout

\begin_layout Standard
Sämtliche Interaktionen müssen über den Dispatcher geschehen.
 Andernfalls wird sofort eine Exception geworfen.
 Dadurch kann die Concurrency vom aufrufenden Code wieder Sequenziell abgearbeit
et werden, wie es für ein GUI nötig ist.
 Eine Lösung zu entwickeln, die komplett Concurrency-Safe ist ziemlich aufwändig
 und zeitintensiv.
 
\end_layout

\begin_layout Paragraph
WinForms 
\end_layout

\begin_layout Standard
Mit dem AllowUnsafeThreadExecution Attribut kann die ganze Thread-security
 abgeschaltet werden.
 Dafür müssen alle Grafikelemente vor dem Bearbeiten gelockt werden und
 der aufrufende Code ist verantwortlich dafür, dass die Aufrufreihenfolge
 und der Ablauf stimmt.
 Durch Double-Buffering kann die Performance erhöht werden, wenn mehrere
 Objekte gezeichnet werden.
 Es ist uns klar, dass diese Umsetzung diverse Architekturprinzipien und
 Guidelines verletzt.
 
\end_layout

\begin_layout Standard

\series bold
In einem finalen Release darf diese Umsetzung nicht verwendet werden.

\series default
 
\end_layout

\begin_layout Subsection
Kalibrierung
\end_layout

\begin_layout Standard
Die Grundüberlegung jedes Ansatzes der Kalibration ist derselbe: Im ersten
 Schritt werden die Ecken des Bildschirms gefunden, in den weiteren Schritten
 werden zusätzliche Daten gesammelt um die Interpolation zu verbessern.
 
\end_layout

\begin_layout Standard
TODO: Übergang zu Erkenntnissen in der folgenden Liste:
\end_layout

\begin_layout Enumerate
Als erster Schritt ist es nötig, dass ein Frame einzulesen, um die Auflösung
 der Kamera zu erhalten.
 
\end_layout

\begin_layout Enumerate
Das erhaltene Bild ist weder Flächen- noch Winkeltreu.
 
\end_layout

\begin_layout Enumerate
Die Belichtungskorrektur der Kamera ist sehr gefährlich, um ein sinnvolles
 Differenzbild zu erhalten, muss darauf geachtet werden, dass auf beiden
 Bildern die gleiche Helligkeitsverteilung herrscht.
 Dies Verunmöglicht, ein universelles Bild zu speichern, mit dem man den
 Hintergrund entfernen könnte.
 
\end_layout

\begin_layout Enumerate
Die Belichtungskorrektur benötigt ca.
 1-2 Frames, bis sie reagiert.
 Aus Performance-Gründen lässt sich das leider nicht zu unserem Vorteil
 nutzen.
 
\end_layout

\begin_layout Enumerate
Von gewissen Webcams wird das Bild gespiegelt zurückgegeben, von anderen
 nicht.
 
\end_layout

\begin_layout Enumerate
Bis die Bilder der Kamera dem entsprechen, was man erwarten würde, muss
 man ca.
 100ms warten.
 Diese Dauer ist zudem vom gewählten Visualisierer abhängig.
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/Verzögerung1.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/Verzögerung2.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Verzögerung der Darstellung
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Die Linse der Kamera kann für eine zusätzliche Verzerrung sorgen.
 
\end_layout

\begin_layout Enumerate
Berechnungen mit C# Bitmaps sind extrem inperformant.
 
\end_layout

\begin_layout Enumerate
Eine sequentielle Bearbeitung der Daten führt dazu, dass man mit veralteten
 (und somit falschen) Daten arbeitet.
 
\end_layout

\begin_layout Enumerate
Eine parallele Bearbeitung der führt meistens zum unkontrollierten Spawnen
 von Tasks, die das System verlangsamen und schliesslich ein Ablaufen verunmögli
chen.
 Falls das Auftritt, hat man ebenfalls Probleme mit alten Daten.
 
\end_layout

\begin_layout Enumerate
Wenn ein Teil der Anzeige durch ein anderes Fenster oder einem Objekt verdeckt
 wird, ist das unmöglich automatisch zu detektieren.
 Daher muss die Erkennung noch durch den Nutzer verifiziert werden.
 
\end_layout

\begin_layout Paragraph
Allgemeine Massnahmen
\end_layout

\begin_layout Itemize
Der Ablauf wird von einer Semaphore geschützt.
 Wenn kein Lock akquiriert werden kann, wird das ankommende Bild verworfen
 und nicht behandelt.
 
\end_layout

\begin_layout Itemize
Nach jedem Zeichnen wird 100 ms gewartet bevor die Semaphore freigegeben
 wird, damit sichergegangen werden kann, dass das erwartete Bild von der
 Kamera ankommt.
 
\end_layout

\begin_layout Subsection
Umsetzung: Schachbrett-Differenzbilder
\begin_inset CommandInset label
LatexCommand label
name "sub:Schachbrett-Differenz"

\end_inset


\end_layout

\begin_layout Standard
Um Differenzbilder nutzen zu können, aber sich nicht durch die Belichtungskorrek
tur beeinflussen zu lassen, muss darauf geachtet werden, dass jedes projizierte
 Bild eine identische Helligkeitsverteilung zum Referenzbild besitzt.
 Das bedeutet, dass für jedes Bild, das man analysieren möchte, zwei Bilder
 Projiziert werden müssen.
 Da diese Art der Erkennung viel genauer ist, nehmen wir diesen Overhead
 in Kauf und verzichten allenfalls auf ein paar Referenzbilder.
 „Lieber wenig gute Daten, als viel schlechte“ 
\end_layout

\begin_layout Paragraph
Ablauf
\end_layout

\begin_layout Enumerate
Es wird ein Schachbrett mit 
\begin_inset Formula $n\times m$
\end_inset

 Quadraten projiziert.
 Das Verhältnis von n zu m sollte dem Bildschirmverhältnis entsprechen und
 die Quadrate sollten noch gut auf dem Kamerabild sichtbar sein (15-30 Pixel
 Seitenlänge) 
\end_layout

\begin_layout Enumerate
Das Schachbrett wird erneut projiziert, diesmal mit invertierten Farben.
 Auf dem Differenzbild sollte jetzt die Leinwand klar zu erkennen sein.
 Da es an den Kanten der Quadrate Lücken haben wird (diejenigen Pixelreihen,
 die von der Kamera auf beiden Bildern als Beleuchtet erkannt hat), müssen
 wir diese z.B.
 mit einem Gaussfilter mit einer kleinen Kernel-Size eliminieren, da es
 sonst bei der Bloberkennung zu Fehlerkennungen kommt.
 Jetzt können die Ecken des Bildschirms sehr genau erkannt werden.
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/img01-0-0.jpg
	lyxscale 30
	width 40col%

\end_inset

 - 
\begin_inset Graphics
	filename Bilder/Calibration/img02-0-0.jpg
	lyxscale 30
	width 40col%

\end_inset

 = 
\begin_inset Graphics
	filename Bilder/Calibration/diff.png
	width 90col%

\end_inset


\end_layout

\begin_layout Plain Layout
Gaussfilter mit Radius 3, um die Erkennung zu verbessern:
\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/diffblur.png
	width 90col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Erkennung des Bildschirms
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Stifterkennung
\end_layout

\begin_layout Subsubsection
Verfahren
\end_layout

\begin_layout Standard
Wie oben beschrieben, haben wir uns auf den Ansatz beschränkt, dass der
 Stift das hellste sichtbare Licht auf dem Kamerabild darstellt.
 Der hellste Punkt sollte also die aktuelle Stiftposition sein.
 Es gibt zwei naheliegende Ansätze um diesen Punkt zu finden.
\end_layout

\begin_layout Itemize
Finde den hellsten Punkt auf dem Bild.
 Das hat Schwächen.
 Insbesondere wenn das Bild viel Rauschen beinhaltet.
\end_layout

\begin_layout Itemize
Finde den hellsten Punkt der sich bewegt.
\end_layout

\begin_layout Standard
In unserer Software verwenden wird für guten Input den Ansatz ohne Differenzbild
er und für schlechten Input (wenig Licht, viel Rauschen) den stabileren
 Ansatz mit Differenzbildern.
\end_layout

\begin_layout Paragraph
Beispiel
\end_layout

\begin_layout Standard
Im folgenden Beispiel wurde der automatische Weissabgleich der Kamera auf
 Rot konzentriert und die Überbeleuchtung drastisch reduziert.
 Resultierend sieht man die hellsten Punkte auf dem Beamerbild.
 Der alleinstehende Punkt im ersten Bild ist ein Laserpointer-Punkt.
 Im zweiten Bild befindet er sich im verrauschten Bereich.
 Den Punkt dort in einem einzelnen Bild per Software zu finden, kann Schwierigke
iten bereiten, da der Laserpunkt nicht der hellste sein muss.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/laser-standalone.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Der Laserpointer ist gut sichtbar
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/laser-rauschen.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Der Laserpointer ist im Rauschen kaum sichtbar
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Differenzbilder
\end_layout

\begin_layout Standard
Ein stabilerer Ansatz ist, den Lichtpunkt über Differenzbilder zu finden.
 Das Differenzbild filtert helles Rauschen und stehende helle Lichtquellen
 zuverlässiger raus als eine einfache Hell/Dunkel-Schranke.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/laser-diff.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Differenzbild zweier Frames mit Laserpunkten
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/laser-diffgray.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Nachdem die Rotanteile zu Graustufen übersetzt wurden, sieht man die gesuchten
 Laserpunkte besser.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/RedDot ohne Weissabgleich/laser-diffthreshold.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Nun ergibt ein Hell/Dunkel-Filter (Threshold oder Binarize) gute Anhaltspunkte
 wo sich gesuchte Punkte befinden.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Kardinalität der gefundenen Punkte
\end_layout

\begin_layout Standard
Alle zusammenhängenden hellen Bereiche werden Blobs genannt.
 Diese Blobs repräsentieren Positionen wo sich der Stift im aktuellen und
 im vorherigen Frame befunden hat.
 Es gibt verschiedene Fälle die nach dem Finden der Blobs unterschieden
 werden müssen.
\end_layout

\begin_layout Itemize
Es wurde kein Blob gefunden:
\begin_inset Newline newline
\end_inset

Für die Software ist kein Stift sichtbar.
 Es wird kein Punkt gefunden.
 Dies kann der Fall sein, wenn die präsentierende Person nicht schreibt,
 vor dem Stift steht und der Kamera die Sicht verdeckt oder wenn die Lichtverhäl
tnisse nicht ideal sind und der Stift von der Kamera nicht hell genug wahrgenomm
en wird.
\end_layout

\begin_layout Itemize
Es wurde ein Blob gefunden:
\begin_inset Newline newline
\end_inset

Entweder hat sich der Stift nicht, oder zu wenig bewegt um zwei Blobs zu
 erzeugen oder es handelt sich um eine Fehlerkennung.
 
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-or-two-blobs/frame1.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-or-two-blobs/frame2.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-or-two-blobs/diff.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Frame x, Frame x+1, Differenz
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-blob/frame1.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-blob/frame2.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/one-blob/diff.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Frame x, Frame x+1, Differenz
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Es wurden zwei Blobs gefunden:
\begin_inset Newline newline
\end_inset

Das ist der gewünschte Fall.
 Beide Punkte bilden gültige Positionen des letzten und des momentanen Frames.
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs/frame1.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs/frame2.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs/diff.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Frame x, Frame x+1, Differenz - Die Punkte gehen 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Es wurden mehr als zwei Blobs gefunden:
\begin_inset Newline newline
\end_inset

Ungültig.
 Wird gemüllt.
 Optimierung: Man könnte den hellsten Punkt suche und als Resultat zurückgeben.
\end_layout

\begin_layout Standard
Generell wird angenommen, dass alle Blobs, falls deren Anzahl zwei oder
 kleiner ist, gültige Stiftpositionen bilden und dass Fehlerkennungen vorher
 gefiltert werden konnten.
 Gute Filter setzen die Eigenschaften eines gültigen Lichtpunktes gut um
 (s.u.).
 
\end_layout

\begin_layout Paragraph
Resultierende Punktposition
\end_layout

\begin_layout Standard
Der Einfachheit halber wird nun das euklidische Zentrum der zwei gefundenen
 Blobs berechnet und als Resultatposition genommen.
 Falls nur ein Punkt gefunden wurde, wird dieser als Resultat gewählt.
 Dieses Verfahren beschränkt den Kontext und damit die Komplexität des Algorithm
us auf das Vorhandensein von genau zwei Bildaufnahmen.
 Es werden weder Geschwindigkeit, noch Vorgängerpunkte vorausgesetzt.
 Ein Nachteil, der dabei in Kauf genommen wird, ist, dass die gefundene
 Punktposition von korrekter Zeit und korrektem Ort abweichen kann.
 Diese Abweichung wird stärker, je schneller sich der Punkt auf der Leinwand
 bewegt.
 Mit Überlegungen aus dem WKS-Abtasttheorem wird aber klar, dass sich dieser
 Effekt nicht sehr stark in der mittleren Erkennungsqualität niederschlägt.
 Die Abtastrate vor und nach der Interpolation ist die gleiche.
 Die Abbildung der zwei gemessenen Punkte auf den Mittelwert resultiert
 in einer Position, die höchstwahrscheinlich gemessen worden wäre, wenn
 mit der doppelten Rate abgetastet worden wäre.
 Diese Behauptung gilt für unbeschleunigte gerade Bewegungen genau und für
 das Schreiben an eine Leinwand bei hoher Abtastrate näherungsweise.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/Interpolation/interpolation-random.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Zufällig verteilte Punkte (blau) mit grossen Abständen.
 Die Interpolation (violett) taugt nichts.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/Interpolation/interpolation-smoothed.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Die Interpolation dient als Glättung
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/Interpolation/interpolation-curves.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Bei genug Punkten bleibt die Ursprungsfigur gut erhalten.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Zeitlich korrekte Punktposition
\end_layout

\begin_layout Standard
Es wäre möglich, die genaue Punktposition zu finden, indem auf dem aktuellen
 Differenzbild der Vorgänger bestimmt wird.
 Im folgenden werden zwei Ansätze diskutiert, wie dies bewerkstelligt werden
 könnte.
 Abbildung 15 zeigt die Situation: Es wurden drei Aufnahmen gemacht, davon
 wiederum zwei Differenzbilder.
 Die zeitliche Abfolge der gefundenen Punkte ist mit den Zahlen 1 bis 3
 gekennzeichnet.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/timed-position/frames1.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/timed-position/frames2.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Zeitliche Abfolge 
\begin_inset Formula $Differenz(Bild_{x},Bild_{x+1})$
\end_inset

 und 
\begin_inset Formula $Differenz(Bild_{x+1},Bild_{x+2})$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der erste Ansatz bezieht sich auf die im Differenzbild per Threshold gefundenen
 Blobs.
 Die gefundenen Positionen könnten mit dem im vorigen Differenzbild gefundenen
 Punkt verglichen werden.
 Der noch unbekannte Punkt ist der neue resultierende Punkt.
 Im Gegensatz zum oben genannten Interpolationsverfahren wird hier immer
 die aktuelle und richtige Position gefunden.
 Dieses Vorgehen erhöht jedoch die Komplexität des Algorithmus, da zusätzliche
 Fallunterscheidungen gemacht werden müssen.
 So muss separat unterschieden werden, was das Finden eines einzelnen Blobs
 nun bedeutet.
 Ansätze wären den Mittelpunkt oder Schwerpunkt zu berechnen oder genauere
 Analysen im Bild vorzunehmen.
 Man muss sich jedoch bewusst sein, dass Mischen von Interpolation mit Messung
 den Nachteil hat, dass Grössen wie Position und Geschwindigkeit verschwommen
 werden.
 Bei einem einzelnen grossen Blob wäre die Interpolation ungenau und korrelliert
 nicht mit den Messinformationen, die aus vorherigen zwei Blobs gewonnen
 wurde.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs-overlay/diff1.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs-overlay/diff2.png

\end_inset

 
\begin_inset Graphics
	filename Bilder/PenTracking/LightPoints/two-blobs-overlay/diff3.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Problematische Einzelfunde
\end_layout

\end_inset


\end_layout

\end_inset

Tests haben gezeigt, dass das aktuelle Interpolationsverfahren genügend
 genau ist.
 Bei stabilem Input wird ohne Differenzbilder direkt mit dem hellsten Punkt
 gearbeitet.
 Da hat die Interpolation keine negativen Auswirkungen.
\end_layout

\begin_layout Standard
Für gute Kamerabilder (wenig rauschen) wird der Differenzbildansansatz nicht
 verwendet.
 Automatisch sind dann Ort und Zeit eines gefundenen Punktes besser.
\end_layout

\begin_layout Subsubsection
Umsetzung
\end_layout

\begin_layout Standard
Die Umsetzung ist auf die Stabilität des Verfahrens mit Differenzbildern
 ausgerichtet.
 Sie funktioniert bei sehr schwachen Lichtpunkten wie Laserpointern und
 mit viel Rauschen.
 Nichtsdestotrotz wurde schlussendlich im Prototypen wieder auf die einfachere
 Version ohne Differenzbilder umgestellt.
 Bei guten Umgebungsbedingungen, wie guter Sichtbarkeit des Lichts und wenig
 Rauschen benötigt man die Stabilität nicht.
 Zudem wird so Rechenzeit gespart.
\end_layout

\begin_layout Paragraph
Laufzeit
\end_layout

\begin_layout Standard
Falls schon Punkte gefunden wurden, wird zuerst nur ein Bildausschnitt um
 den zuletzt gefundenen Punkt analysiert.
 Im Erfolgsfall spart das Rechenzeit.
 Falls man im Bildausschnitt kein Punkt findet, wird die Suche auf das ganze
 Bild ausgeweitet.
 Im Mittel benötigt man so auf einem Intel Core Duo mit 2Ghz ca 4ms pro
 gefundenem Lichtpunkt.
 Gerade falls die Software auf einem schwächeren Rechner läuft, sollte sicherges
tellt werden, dass der Kamerainput nicht verrauscht ist.
 Dann kann die Punkterkennung ohne Differenzbilder ablaufen und so Rechenleistun
g sparen.
\end_layout

\begin_layout Paragraph
Eigenschaften eines Lichtpunktes
\end_layout

\begin_layout Standard
Ein von einem Stift erzeugter Lichtpunkt hat diverse Eigenschaften.
 Im Folgenden werden diese genauer ausgeführt.
\end_layout

\begin_layout Subsubsection
Einschränkungen
\end_layout

\begin_layout Standard
- Das Licht hat eine wichtige Rolle gespielt.
\begin_inset Newline newline
\end_inset

- Es wurde eine einfache Laptopkamera eines T430s verwendet (640x480px à
 40ms).
\begin_inset Newline newline
\end_inset

- Der Weissabgleich ist lästig.
\begin_inset Newline newline
\end_inset

- Die Einstellungen zum Weissabgleich können unter Windows nur per DirectShow
 Menu eingestellt werden.
 
\end_layout

\begin_layout Subsubsection
Wahl des Stiftes
\end_layout

\begin_layout Standard
Leuchtwerkzeug über optisches Licht für Proof Of Concept.
 Wahrscheinlich würde in einem Produkt Infrarot-Technologie eingesetzt.
\end_layout

\begin_layout Itemize
Glühbirne
\end_layout

\begin_layout Itemize
LED
\end_layout

\begin_layout Itemize
Laser Pointer, Frequenzband
\end_layout

\begin_layout Itemize
Infrarot Lambsa 1/4 Pass-Filter
\end_layout

\begin_layout Subsection
Input Emulation
\end_layout

\begin_layout Standard
Gemäss Aufgabenstellung war in unserem Fall lediglich eine PowerPoint-Integratio
n gefordert.
 Wir haben uns jedoch überlegt, dass wir mit einer Mausemulation weit mehr
 machen könnten.
 Ausserdem kann man auch PowerPoint mit einer emulierten Maus gut bedienen.
 Zudem haben wir schon Erfahrungen gesammelt, wie man mit C# Mausbefehle
 auf Driver-Level injizieren kann.
 Diesen Weg benutzten ebenfalls Devices anderer Hersteller, wie z.B.
 Logitec Presenter.
 Diese emulieren jedoch eine Tastatur, was für uns nicht sinnvoll, aber
 optional auch möglich ist.
 Unter Windows 8 ist es zudem möglich, Touch-Events zu generieren.
 Damit müssten wir uns nicht mehr um die Analyse der Gesten kümmern, da
 uns das vom Betriebssystem abgenommen wird.
 Da wir jedoch auch ältere Systeme unterstützen wollen, haben wir einen
 Teil der Windows 8 Touch-funktionalität nachgebildet, die wir mit Mausbefehlen
 nachbauen.
 Dies ist z.B.
 ein Rechtsklick durch warten an einem Ort.
\end_layout

\begin_layout Standard
Um die erkannten Pixel zu glätten, mitteln wir jeweils die letzten 6 Punkte,
 die wir interpoliert haben.
 So können wir einen grossen Teil des Rauschens ausgleichen und erhalten
 eine Genauigkeit, die höher ist, als wir überhaupt aus dem Kamerabild extrahier
en können.
 Die Verzögerung wird für den User erst ab einer Mittelung mit 15 Punkten
 bemerkbar.
\end_layout

\begin_layout Subsection
Erkenntnisse
\end_layout

\begin_layout Subsubsection*
Kamera
\end_layout

\begin_layout Standard
Wir müssen die Kamera noch mit einem eigenen Fenster konfigurieren.
 Das ist nicht ideal, aber immerhin können wir gewisse Werte einstellen.
\end_layout

\begin_layout Subsubsection*
Kalibration
\end_layout

\begin_layout Standard
Wir haben gesehen, dass man auch anhand von vier Referenzpunkten sehr genau
 interpolieren kann.
 Es gibt Möglichkeiten, um mehr Referenzpunkte zu erhalten, diese sind aber
 meist relativ kompliziert und Zeitintensiv.
 Wenn man eine stabile und sichere Kalibration möchte, sollte man sich auf
 die Eckpunkte beschränken.
\end_layout

\begin_layout Subsubsection*
Emulation
\end_layout

\begin_layout Standard
Unser Prototyp funktioniert sehr genau und ist sehr Fehlertolerant.
 Durch die Mittelung von Uneren Ergebnissen der Interpolation erhalten wir
 sehr gute Ergebnisse, die sehr feine Zeichnungen ermöglichen.
 Zudem gibt es durch die Mittelung keine Sprünge der Linien da solche Pixelgenau
 gezeichnet werden können.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Ausblick
\end_layout

\begin_layout Subsection
Kamera
\end_layout

\begin_layout Standard
Hier besteht noch viel Verbesserungspotenzial.
 Die Konfiguration müsste irgendwie Automatisiert werden.
 Zudem wäre eine Nutzung von Infrarot-Signalen sehr nützlich.
\end_layout

\begin_layout Standard
Auswahl???
\end_layout

\begin_layout Subsection
Kalibrierung
\end_layout

\begin_layout Standard
Hier gibt es zwei Ansätzte, die weiterverfolgt werden können um mehr Referenzpun
kte zu erhalten.
 Diese knn man nutzen um allfälliger Korrekturfaktoren einzuführen und die
 Genuigkeit zu verbessern.
\end_layout

\begin_layout Standard
Ein anderer Ansatz wäre, dass man die Kalibration nicht mehr automatisch
 durchführt, sondern durch den Nutzer machen lässt.
 Das ist aufwändiger für diesen, andernseits kann man so noch Störfaktoren
 korrigieren, die vom Stift und dem Winkel, mit dem dieser gehalten wird,
 korrigiert werden.
\end_layout

\begin_layout Paragraph
Kamera mit Infrarot-Kanal
\end_layout

\begin_layout Standard
Hierbei haben wir natürlich stark erweiterte Möglichkeiten
\end_layout

\begin_layout Itemize
Überprüfen, ob die Kalibration immer noch stimmt, während dem laufenden
 Betrieb
\end_layout

\begin_layout Itemize
In-Time anpassen der Korrekturfaktoren
\end_layout

\begin_layout Itemize
Verifizieren, ob sich der Pen dort befindet, wo er erwartet wird und allenfalls
 korrigieren.
\end_layout

\begin_layout Itemize
Nachkalibration auslösen, wenn die Webcam oder der Beamer bewegt wird.
\end_layout

\begin_layout Standard
Das kann sehr viel Verbesserungen bringen, erübrigt eine Kalibration der
 Kamera und verkürzt die Kalibrationszeit.
 Dies wird zusätzlichen Aufwand bedeuten, jedoch sollte sich das eigentlich
 gut in unsere Ansätze integrieren lassen.
 Durch diese Anpassung wird die Nutzerfreundlichkeit sehr stark verbessert.
 Dieser Schritt ist nötig, um dieses Produkt verschiedenen Kundensegmenten
 anzubieten, da eis die Benutzung ungemein vereinfacht.
\end_layout

\begin_layout Subsection
Pen Tracking
\end_layout

\begin_layout Standard
MultiPen für Multitouch?
\end_layout

\begin_layout Subsection
Handdetektion
\end_layout

\begin_layout Subsection
Input Emulation
\end_layout

\begin_layout Standard
Wenn weiterhin der ganze PC damit bedient werden soll, ist die injection
 in den Maustreiber die einzige gangbare Möglichkeit.
 Dabei sollte aber darauf geachtet werden, dass relative Mausbewegungen
 gesendet werden, da es sonst mit gewissen Programmen, die Mausinputs auf
 einem sehr tiefen Level verarbeiten, zu komplikationen kommen wird.
 Dies erfordert jedoch die Möglichkeit, die am PC eingestellte Mausbeschleunigun
g auslesen zu können und Positionen verifizieren zu können.
\end_layout

\begin_layout Paragraph
Touch
\end_layout

\begin_layout Standard
Mit der Touch-Emulation unter Windows 8 unterstützen wir schon alle implementier
ten Touch-Gesten.
 In kombination mit einem Pentracker, der mehrer Pens detektieren kann,
 wären auch Multitouch-Gesten möglich.
\end_layout

\begin_layout Standard
Diese Funktionalität sollte jedoch unter anderen Betriebssystemen nachgebildet
 werden, damit man zumindest eine ähnliche Funktionalität unter älteren
 Systemen gewährleistet werden kann.
\end_layout

\begin_layout Paragraph
API
\end_layout

\begin_layout Standard
Eine weitere Möglichkeit ist, eine API bereitzuistellen, die von anderen
 Softwareherstellern verwendet werden kann, und so unser Produkt in ihre
 Software einbinden können.
 Das kann auch zusätzlich zur Mausemulation gemacht werden.
 Dies wird zwar für unsere Software nicht unbedingt benötigt und ich erachte
 diesen Schritt im Moment als unnötig.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Anhang
\end_layout

\begin_layout Subsection
Kalibrierung: Bilderkennung
\end_layout

\begin_layout Subsubsection
Selber programmierte Eckdetecktion mit Differenzbildern und zufällig verteilten
 Rechtecken.
 
\end_layout

\begin_layout Standard
Hierbei werden kein zusätzlichen Libraries verwendet.
 Da die Bitmaps sehr inperformant sind verwenden wir zudem eine eigene Bitmapkla
sse, welche die Bitmaps zu Bytearrays umwandelt.
 Damit können nur Metrizenberechnungen und Analysen durchgeführt werden.
\end_layout

\begin_layout Subparagraph
Ablauf
\end_layout

\begin_layout Enumerate
Der Bildschirm wird Schwarz gemacht.
 Das entsprechende Bild wird gespeichert.
 
\end_layout

\begin_layout Enumerate
Der Bildschirm wird weiss gemacht und das Differenzbild gemacht.
 Mit 4 Scanlinien werden von jeder Ecke ausgehend unter 45° ein Punkt gesucht,
 dessen Nachbarn in Richtung der gegenüberliegenden Ecke Liegen eine bestimmte
 Deckung besitzen.
 Es wird ein Quadrat mit Seitenlänge 3-5 Pixel berücksichtigt.
 
\end_layout

\begin_layout Enumerate
Es werden 3 Rechtecke mit zufälligen Eckpunkten gezeichnet und die Eckpunkte
 gespeichert, eins pro Farbkanal.
 Auf dem Differenzbild zum Ersten werden mit dem geleichen Verfahren zu
 jedem Farbkanal die Ecken gesucht.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Scanlinien.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Sacnlinien
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Verwendung des AForge-Blob-Detctors
\end_layout

\begin_layout Standard
Diese wird in den kommenden Lösungen immer eingesetzt.
 Ich werde bei jeder Lösung nur auf geänderte und wichtige Aspekte erwähnen.
 Funktionierende Teile wurden jeweils übernommen.
 Die verschiedenen Kalibratoren die Im Code existieren sind keine 1 zu 1
 Umsetzungen der hier beschriebenen Ansätze, sondern Kombinationen davon.
 Der Code von verworfenen Umsetzungen wurde in anderen Umsetzungen teilweise
 Übernommen und aktualisiert.
 Diese Aktualisierungen wurden nicht Nachgepflegt aus dem Grund, dass ich
 diese Lösungen nicht als sinnvoll für ein Weiterverfolgen erachte.
 
\end_layout

\begin_layout Subsubsection
Einfacher Differenzbild-Kalibrator
\end_layout

\begin_layout Enumerate
Als erstes Bild wird der Bildschirm schwarz gefärbt.
 Dieses Bild dient als Grundbild für alle folgenden Differenzbilder 
\end_layout

\begin_layout Enumerate
Der Bildschirm wird komplett weiss gefärbt.
 Auf dem Differenzbild wird der grösste Blob gesucht.
 Das sind dann die Ecken des Bildschirms.
 
\end_layout

\begin_layout Enumerate
Es werden Grüne und blaue Quadrate jeweils versetzt auf den Bildschirm projizier
t, die bei jedem Frame leicht verschoben werden um mehr Referenzpunkte zu
 bekommen.
 Die Erkennung des roten Farbkanals ist am schlechtesten, deshalb verwenden
 wir blau und grün.
 Zwei Farben sind ausreichend, wenn sie mit einem Feld Abstand projiziert
 werden, dass es keine Nachbarschaftskonflikte gibt.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/bgSchachbrett.png
	width 45text%

\end_inset


\begin_inset Formula $\rightarrow$
\end_inset


\begin_inset Graphics
	filename Bilder/Calibration/Scahcbrett erkannt.png
	width 45text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Schachbrettmuster über zwei Farbkanäle
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Diese werden auf dem Differenzbild gesucht.
 Deren Zuordnung wird in einem Folgenden Abschnitt auf Seite ??? behandelt.
 
\end_layout

\begin_layout Standard
Probleme: 
\end_layout

\begin_layout Itemize
Durch die Belichtungskorrektur der Kamera wird ein universeller Hintergrund
 für ein Differenzbild verunmöglicht.
 Es gibt zu viele Fehlerkennungen auf dem Bild.
 
\end_layout

\begin_layout Subsubsection
Histogramm-analyse 
\end_layout

\begin_layout Standard
Hierbei werden keine Differenzbilder gebildet, sondern Helligkeitswerte
 des Bildes analysiert und so können überdurchschnittlich helle Flächen
 (Projektionen) gefunden werden.
 Die restlichen Bildinformationen werden entfernt um eine Blob-Erkennung
 zu ermöglichen.
 
\end_layout

\begin_layout Standard
Durch unterschiedliche Lichtverhältnisse in Bildbereichen ist dieser Ansatz
 anfällig auf Störungen.
 Die Lösung für dieses Problem ist ein aufteilen des Bildes.
 Dabei wird das Bild in verschiedene Regionen aufgeteilt, wo die Helligkeitswert
e weniger stark verteilt sind.
 Anschliesend werden die Flächen wieder zu einem Bild zusammengesetzt.
 
\end_layout

\begin_layout Paragraph
Ablauf
\end_layout

\begin_layout Enumerate
Es wird eine weisse Fläche projiziert.
 Das Bild wird in 2x2 Teile aufgeteilt und der grösste Blob gesucht.
 Das führt zu den Eckepunkten.
 
\end_layout

\begin_layout Enumerate
Es werden die grünen und blauen Quadrate aus dem Vorherigen Verfahren projiziert.
 Das Bild wird in 4 x 4 Teile aufgeteilt und der blaue oder grüne Farbkanal
 separat analysiert.
 In den zwei resultierenden Bildern werden Blobs erkannt und analysiert.
 
\end_layout

\begin_layout Paragraph
Erkenntnisse
\end_layout

\begin_layout Itemize
Die Erkennung der Blobs klappt relativ gut, jedoch sind die Kanten relativ
 unscharf was für eine genaue Erkennung ein Nachteil ist.
 
\end_layout

\begin_layout Itemize
Die automatische Belichtungskorrektur ist kein Problem mehr.
 
\end_layout

\begin_layout Itemize
An den Kanten bei denen das Bild aufgeteilt wurde entstehen häufig Einschnitte
 oder sonstige Ungenauigkeiten.
 Diese sind keine grossen Probleme für den Blob-Detector, jedoch sind sie
 eine weitere Quelle für Ungenauigkeiten.
 Durch eine Filterung nach Grösse erhält man ein gutes Resultat.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/img3.jpg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Erkannte grüne Quadrate
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Erweitertes Differenzbild
\end_layout

\begin_layout Enumerate
Anschliessend werden jeweils zwei Bilder projiziert, deren Differenz genau
 das bekannte Blau-Grüne Muster ergibt.
 Bild So können die Recktecke auf dem Bild ganz scharf und klar erkannt
 werden und identifiziert werden.
 Durch das Bilden eines weiteren Differenzbildes mit den beiden erwünschten
 Farbkanälen kann das meiste Bildrauschen und allfällige Unsicherheiten
 entfernt werden.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/img03-1-0.jpg
	width 45col%

\end_inset

- - 
\begin_inset Graphics
	filename Bilder/Calibration/img03-0-0.jpg
	width 45col%

\end_inset


\end_layout

\begin_layout Plain Layout
=
\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/Colordiff.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Farbmuster
\end_layout

\end_inset


\end_layout

\end_inset

Störungen wie sie hier in der oberen linken Ecke Vorhanden sind können entfernt
 werden, dadurch, dass sie nicht innerhalb der erkannten Bildschirmecken
 liegen.
 Die Grundkalibration ist durchch die Bedingung, dass alle Bildschirmecken
 mindestens 5 Pixel Abstand zu jedem Rand haben müssen.
\end_layout

\begin_layout Subsection
Kalibrierung: Zuordnung von Punkten
\end_layout

\begin_layout Standard
Vom AForge BlobCounter erhalten wir genau alle Blobs die auf dem Kamerabild
 gefunden wurden.
 
\end_layout

\begin_layout Standard
Diese Daten beinhalten: Schwerpunkt, Umfassungsrechteck, Fläche, Breite,
 Höhe.
 Eine Zuordnung zu machen, welcher Blob zu welchen pojizietem Quadrat gehört.
 Durch eine Filterung mit einer vordefinierten minimalen und maximalen Höhe/Brei
te können wir die Blobs filtern und rauschen entfernen.
 Da wir die Ecken des Bildschirms mit Sicherheit kennen, können wir anhand
 des konstruierten Vierecks bestimmen ob ein Blob innerhalb der Projektion
 liegt und andernfalls entfernen.
 Somit können wir jetzt 99% der Fehlerkennungen eliminieren.
 Die Schwerpunkte der Blobs sind jedoch mit Koordinaten des Kamerabildes
 beschrieben, was es für uns schwierig macht, deren Position auf dem Bildschirm
 zu bestimmen, da diese relativ komplex voneinander abhängen.
 So kann z.B.
 die kleinste X-Koordinate zuunterst liegen und die grösste Y-Koordinate
 rechts oben.
 Je nach Verzerrung ist es so schon sehr schwierig nur schon die obere linke
 Ecke zu finden.
 
\end_layout

\begin_layout Paragraph
Mögliche Ansätze
\end_layout

\begin_layout Subsubsection
Rekursiv: 
\end_layout

\begin_layout Standard
Hierbei nehmen wir an, dass die Nachbarn eines Blobs eindeutig bestimmt
 werden können.
 Dies ist möglich anhand der Distanz.
 
\end_layout

\begin_layout Paragraph
Ablauf
\end_layout

\begin_layout Enumerate
Der Algorithmus bestimmt auf jedem Farbkanal denjenigen Blob, der am nächsten
 bei der oberen linken Ecke liegt.
 Durch die Positionsangabe 0|0 für grün oder 1|1 ist bekannt, dass es sich
 um einen Eckpunkt handeln muss.
 Der Punkt wird markiert, dass er nicht nochmals bearbeitet werden muss.
 
\end_layout

\begin_layout Enumerate
Es werden also die zwei nächsten Nachbarn gesucht.
 Anhand der Differenz der der Koordinaten kann bestimmt werden, ob der Punkt
 oberhalb (Y-Differenz ist grösser als die Differenz der X-Achse und negativ),
 rechts (X-Differenz ist grösser und positiv), unten oder links liegt.
 
\end_layout

\begin_layout Enumerate
Die Funktion berechnet die Koordinaten die der gefundene Blob haben muss
 (zwei in die entsprechende Achse verschoben) und startet einen Rekursiven
 Aufruf auf jedem unmarkierten Nachbar, nachdem der Ausgangspunkt als erledigt
 markiert wurde.
 
\end_layout

\begin_layout Enumerate
Der rekursive Aufruf prüft zudem, ob die übergebenen Koordinaten plausibel
 erscheinen und bestimmt anhand deren, wie viele Nachbarn zu erwarten sind.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Rekursion.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Vorgehen Rekursion
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Erkenntnisse
\end_layout

\begin_layout Itemize
Dieser Algorithmus funktioniert perfekt unter synthetischen Umständen, d.h.
 mit generierten Bildern.
 
\end_layout

\begin_layout Itemize
Aufgrund des iterativen Vorgehens sollte dieser Algorithmus in der Lage
 sein, um Bereiche, in denen keine Blobs gefunden wurden, herumzugehen.
 
\end_layout

\begin_layout Itemize
Wenn ein Quadrat nicht erkannt wurde, wird meist die Diagonale als nächster
 Nachbar gefunden, das für die folgende Erkennung schwerwiegende Folgen
 hat.
 
\end_layout

\begin_layout Itemize
Häufig werden nicht alle Blobs erreicht.
 Somit werden nicht alle Blobs zugeordnet und Informationen verloren.
 
\end_layout

\begin_layout Itemize
Falsch zugeordnete Blobs können unmöglich identifiziert werden.
 Eine solche hat jedoch für die nachfolgende Interpolation schwerwiegende
 Folgen indem sie in einem Bildbereich das mapping komplett zerstört.
 
\end_layout

\begin_layout Paragraph
Verbesserungen
\end_layout

\begin_layout Itemize
Es wird nicht nur eine erwartete Position gespeichert, sondern mehrere.
 
\end_layout

\begin_layout Itemize
Die Position wird nicht bei der Iteration gespeichert, sondern jedes Mal,
 wenn der Blob als Nachbar gefunden wurde.
 
\end_layout

\begin_layout Itemize
Es wird nicht nur in der linken oberen Ecke gestartet, sondern in allen
 vier Ecken.
 
\end_layout

\begin_layout Itemize
Die finale Position wird festgelegt durch Auswahl der Position, die am häufigste
n bestimmt wurde.
 
\end_layout

\begin_layout Itemize
Man hat die Möglichkeit, die Position anhand eines folgenden ähnlichen Bildes
 zu verifizieren.
 Dabei werden zur Verifikation ausserdem die Daten desjenigen Blobs verwendet,
 der den ähnlichsten Schwerpunkt hat und die sich somit entsprechen sollten.
 
\end_layout

\begin_layout Itemize
Es werden nicht mehr die nächsten Nachbarn gesucht, sondern es wird analysiert,
 auf welcher Achse die Blobs liegen und gezielt dort der nächste Blob gesucht.
 So können Diagonal liegende Punkte nicht mehr die Erkennung stören.
 
\end_layout

\begin_layout Paragraph
Weitere Erkenntnisse
\end_layout

\begin_layout Itemize
Die Ergebnisse sind nur wenig besser geworden und genügen den Anforderungen
 noch nicht.
 
\end_layout

\begin_layout Itemize
Die Fehlerkennungen sind auf folgenden Bildern ähnlich, somit bringt die
 Verifikation praktisch nichts.
 
\end_layout

\begin_layout Itemize
Das Debugging, das schon vorher aufwendig und mühsam zurückzuverfolgen war,
 ist jetzt praktisch unmöglich.
 Man kann nicht mehr herausfinden woher gewisse Werte kommen oder den Ablauf
 rekonstruieren.
 
\end_layout

\begin_layout Subsubsection
Nutzung der Interpolation 
\end_layout

\begin_layout Standard
Hierbei wird ausgenutzt, dass man anhand der Interpolation mit den Eckpunkten
 die Bildschirmkoordinaten ungefähr voraussagen kann.
 Es gibt dazu mehrere Möglichkeiten, die im Abschnitt ??? beschrieben werden.
 
\end_layout

\begin_layout Paragraph
Ablauf: 
\end_layout

\begin_layout Enumerate
Man iteriert durch die Blobs und bestimmt zu jedem die Interpolation des
 Schwerpunkts.
 
\end_layout

\begin_layout Enumerate
Es wird überprüft, in welchem Quadrat der Schwerpunkt zu liegen kommt.
 Falls das Quadrat die gleiche Farbe hat, wird die Position als gültig angenomme
n.
 
\end_layout

\begin_layout Paragraph
Erkenntnisse
\end_layout

\begin_layout Itemize
Mit dieser Methode können Abweichungen von +- einem Quadrat erkannt werden.
 
\end_layout

\begin_layout Itemize
Es gibt praktisch keine Fehlerkennungen.
 
\end_layout

\begin_layout Itemize
Durch vergrössern der Quadrate kann die Erkennung verbessert werden.
 
\end_layout

\begin_layout Itemize
Dieses Verfahren ist viel performanter als andere.
 
\end_layout

\begin_layout Itemize
Dieses Verfahren ist von einer guten Interpolation abhängig.
 
\end_layout

\begin_layout Itemize
Wenn dieses jedoch gut ist, erübrigen sich weitere Kalibrationsschritte.
 
\end_layout

\begin_layout Itemize
Mit einem linearen Ansatz werden nur ein kleiner Teil der Blobs korrekt
 erkannt, die meisten bleiben ungültig.
\end_layout

\begin_layout Itemize
Durch Vergrösserung der Quadrate wird die Menge der nutzbaren Daten ebenfalls
 verkleinert.
\end_layout

\begin_layout Itemize
Vereinzelt kommt es mit dem linearen Ansatz zu Fehlerkennungen, die als
 gültig erkannt werden.
 Dies resultiert in schwerwiegenden Fehlern bei kommenden Schritten und
 kann nicht detektiert werden.
\end_layout

\begin_layout Subsubsection
Strahlensatz
\end_layout

\begin_layout Standard
Es wird ein physikalisches Modell mit einer Lochkamera erstellt.
 Durch Anwendung des Strahlensatzes kann ein mapping erstellt werden.
 
\end_layout

\begin_layout Standard
Eine zusätzliche Voraussetzung dafür ist dafür ist, dass die Projektion
 ein rechtwinkliges Dreieck ist.
 Das heisst, dass die Trapezkorrektur des Beamers immer zwingend ausgeführt
 werden muss.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Lochkamera.emf
	lyxscale 30
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Lochkamera Modell
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
K-Means Cluster-zuordnung mit steigender Genauigkeit
\end_layout

\begin_layout Paragraph
Ablauf
\end_layout

\begin_layout Enumerate
Es werden die Eckpunkte des Bildschirms erkannt.
 
\end_layout

\begin_layout Enumerate
Alle Kanten werden in der Mitte geteilt und deren Mittelpunkte visualisiert.
 
\end_layout

\begin_layout Enumerate
Die erkannten Punkte werden mit K-Means zu den erwarteten Werten zugeordnet.
 
\end_layout

\begin_layout Enumerate
Aus dem Ergebnis resultieren weitere Rechtecke, auf denen das Verfahren
 wieder angewandt werden kann.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Clustering.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Ablauf K-Means
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Erkenntnisse 
\end_layout

\begin_layout Itemize
Es ist schwierig die Punkte an den Rändern zu visualisieren und zu erkennen.
 Der Grund dafür liegt darin, dass man nicht über die Kanten des Beamers
 hinaus projizieren kann.
 Die Lösung dafür haben wir erreicht durch Analyse der Kanten der Blobs
 an den Rändern.
 
\end_layout

\begin_layout Itemize
Ein fehlender Punkt könnte aus den anderen interpoliert werden.
 
\end_layout

\begin_layout Itemize
Die Blobs müssen relativ klein projiziert werden, dass die folgenden Schritte
 funktionieren.
 Das erfordert eine genauere Erkennung.
 
\end_layout

\begin_layout Itemize
Fehlerkennungen führen dazu, dass die weiteren Schritte fehlschlagen werden.
 Das ermöglicht eine gute Fehlererkennung.
 
\end_layout

\begin_layout Itemize
Es gibt praktisch keine Fehlerkennungen.
 Stattdessen wird die Erkennung komplett fehlschlagen, auf was besser reagiert
 werden kann.
 
\end_layout

\begin_layout Subsubsection
Open CV Kamerakalibration
\end_layout

\begin_layout Standard
Das OpenCV Framework bietet die Möglichkeit, Webcambilder zu analysieren
 und Schachbrettmuster zu erkennen.
 Anhand von denen wird zu jedem erkannten Muster eine Transformationsmatrix
 erstellt.
 Mit mehreren Erkennungen kann so ein Teil des Bildraums dreidimensional
 erkannt werden.
 
\end_layout

\begin_layout Paragraph
Anwendung
\end_layout

\begin_layout Itemize
Anhand der verschiedenen erkannten Ebenen lassen sich 3d Transformationen
 durchzuführen.
 
\end_layout

\begin_layout Itemize
Die Erkennung klappt nur selten, das ist aber nicht störend, da auch dann
 noch genügend Ebenen vorhanden sind.
 
\end_layout

\begin_layout Itemize
Die Erkennung lässt sich anhand der Parameter nur wenig beeinflussen.
 
\end_layout

\begin_layout Paragraph
Erkenntnisse
\end_layout

\begin_layout Itemize
Die Erkennung hat in meinem Fall nie gekappt.
 
\end_layout

\begin_layout Itemize
Wir brauchen keine 3d Rekonstruktion, nur eine Ebene.
 Dabei nützt uns dieser Algorithmus nur wenig.
 
\end_layout

\begin_layout Itemize
Das Framework ist sehr schlecht dokumentiert.
 
\end_layout

\begin_layout Itemize
Ein umschreiben des Codes auf unsere Anwendung ist viel zu aufwändig aufgrund
 der Komplexität.
 
\end_layout

\begin_layout Itemize
Es gibt abgesehen von offiziellen Codesample praktisch keine Einsatzmöglickeiten.
 
\end_layout

\begin_layout Subsection
Interpolation
\end_layout

\begin_layout Standard
Hierbei geht es darum, wie man anhand der gefundenen Referenzpunkte die
 genauste Interpolation für ein mapping eines Kamerapixels auf eine Bildschirmko
ordinate erhält.
 Diese Verfahren haben wir testweise auch auf die Ecken des erkannten Bildschirm
s angewandt, um die Genauigkeit zu überprüfen.
 
\end_layout

\begin_layout Subsubsection
Lineare Interpolation
\end_layout

\begin_layout Standard
Skizze 
\end_layout

\begin_layout Standard
Hierbei wird ausgenutzt, dass die Verhältnisse der Strecken auf der Abbildung
 identisch bleiben.
 Dies ist in unserem Fall nicht ganz korrekt, da es die perspektivische
 Verzerrung nicht berücksichtigt, was sich nicht schwerwiegend auswirkt,
 jedoch zu einer gewissen Ungenauigkeit führt.
 Nachteile dieses Verfahrens sind zudem, dass in jedem Quadranten des gesuchten
 Punktes ein Punkt gefunden werden muss, die zusammen auf dem Bildschirm
 ein Rechteck bilden.
 Diese Voraussetzung ist für die Eckpunkte gegeben, jedoch ein erschwerender
 Faktor wenn eine unregelmässige Verteilung von Referenzpunkten gegeben
 ist.
 Ausserdem kann dieses Verfahren nur in eine Richtung angewandt werden,
 nämlich von Bildschirmkoordinaten zu Kamerapixeln.
 Dies ist für uns die falsche Richtung, sodass wir alle Werte vorberechnen
 und speichern müssen.
 
\end_layout

\begin_layout Standard
Formel: 
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Lineare Interpolation.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $Ratio_{X}=\frac{Q_{X}}{Screen_{X}}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $Ratio_{Y}=\frac{Q_{Y}}{Screen_{Y}}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $E=A+\overrightarrow{AB}*Ratio_{X}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $F=A+\overrightarrow{AC}*Ratio_{Y}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $G=B+\overrightarrow{BD}*Ratio_{Y}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $H=C+\overrightarrow{CD}*Ratio_{X}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $P=Schnittpunkt(\overrightarrow{EH},\overrightarrow{FG})\Rightarrow$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $A_{EH}x+B_{EH}=C_{EH}\Rightarrow$
\end_inset

 
\begin_inset Formula $A_{EH}=Y_{H}-Y_{E}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $B=X_{E}-X_{H}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $C_{EH}=A_{EH}*X_{E}+B_{EH}*Y_{E}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
Die Berechnung der anderen Koefizienten läuft identisch.
\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $Det=A_{EH}*B_{FG}-A_{FG}*B_{EH}$
\end_inset


\end_layout

\begin_layout Plain Layout
Wenn die Determinante gleich null ist, sind die Linien parallel.
 Diesen Fall können wir aber ausschliessen.
\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $X_{P}=\frac{(B_{FG}*C_{EH}-B_{EH}*C_{FG})}{Det}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $Y_{P}=\frac{(A_{EH}*C_{FG}-A_{FG}*C_{EH})}{Det}$
\end_inset


\end_layout

\begin_layout Plain Layout
\paragraph_spacing double
\begin_inset Formula $P=(X_{P}|Y_{P})$
\end_inset

, wenn 
\begin_inset Formula $Det\neq0$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Berechnung der linearen Interpolation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Baryzentrische Koordinaten
\end_layout

\begin_layout Paragraph
Funktionsweise
\end_layout

\begin_layout Standard
Baryzentrische Koordinaten beschreiben in jedem n-Eck n Faktoren, die das
 Flächenverhältnis zwischen den Flächen zwischen den Kanten und einem Punkt
 beschreiben.
 Deren Summe ist immer 1.
 Anhand dieser Faktoren lässt sich sehr einfach ein Rebasing durchführen.
 Das heisst, wenn man Die Punkte in einem anderen System hat, die den Eckpunkten
 im Ursprungssystem entsprechen, kann man die Position des Punktes im Zielsystem
 analysieren.
 Dies ist in unserem Fall bei allen Referenzpunkten gegeben.
 Ein Punkt kann sogar bestimmt werden, wenn er nicht innerhalb des Dreiecks
 liegt.
 Wir werden hier dieses Thema nicht weiter behandeln, es gibt viele andere
 Papers, die dieses Thema sehr ausführlich behandeln.
 
\end_layout

\begin_layout Paragraph
Unsere Anwendung
\end_layout

\begin_layout Standard
Byzantinische Koordinaten berücksichtigen leider keine perspektivischen
 Verzerrungen, wie sie bei uns vorkommen, was deren Funktionalität leider
 etwas einschränkt.
 Somit können wir sie nur verwenden, wenn ein Punkt innerhalb oder zumindest
 in der Nähe liegt.
 Andernfalls gibt es extreme Ungenauigkeiten, die ein Resultat unbrauchbar
 machen.
 Wir definieren die Nähe dadurch, dass alle Faktoren kleiner als 1.5 sein
 müssen.
 Wenn sie kleiner als 1 sind ist der Punkt innerhalb.
 Mit 1.5 darf er zu einer Kante eine Fläche gegen aussen aufspannen, die
 maximal der Hälfte der ganzen Fläche entspricht.
 Das entspricht einen maximalen Abstand der halben Dreieckshöhe zur Kante.
 Da die Nutzung von n-Ecken weder zusätzliche Genauigkeit noch sonstige
 Vorteile bringt, nutzen wir Baryzentrische Koordinaten nur in Dreiecken.
 Durch eine Mittelung der resultierenden Koordinaten anhand mehrerer Dreiecke
 können wir die Störungen der Verzerrung etwas minimieren.
 Wenn wir genügend Referenzpunkte haben, fällt das nicht mehr ins Gewicht.
 
\end_layout

\begin_layout Paragraph
Ergebnisse
\end_layout

\begin_layout Standard
Wenn der Beamer und das Notebook nebeneinander stehen, funktioniert die
 Interpolation anhand der Eckepunkte ziemlich gut.
 Wir haben jedoch hauptsächlich unter erschwerenden Umständen getestet.
 Hier gab es bei der linearen Interpolation gewisse Verschiebungen in horizontal
er Richtung.
 Es entspricht nicht unserer erwünschten Genauigkeit.
 Mit den baryzentrischen Koordinaten anhand der Eckpunkte hatten wir anfangs
 sehr viele Ungenauigkeiten.
 Zudem waren Knicke in den Linien sichtbar über die Diagonale.
 
\end_layout

\begin_layout Standard
Eine Mittelung der Ergebnisse aller vier Dreiecke hat jedoch geholfen, die
 Knicke zu eliminieren und die vertikalen Fehlerfaktoren zu eliminieren.
 Dafür haben wir damit Probleme an den Rändern, da dort unrealistische Werte
 entstehen.
 Zudem sieht man, wie stark sich die Perspektivische Verzerrung auswirkt.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
Y Werte:
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Soll
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
links
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mitte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rechts
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-62
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
86
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
125
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
200
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
150
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
193
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
212
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
264
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
289
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
297
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
400
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
368
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
390
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
391
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
505
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
495
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
479
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
600
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
632
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
594
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
574
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
700
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
761
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
689
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
662
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
768
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
838
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
756
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
700
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
X Werte: 
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="12">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Soll
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
200
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
400
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
600
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
700
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
800
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
900
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1000
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
oben
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
152
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
263
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
382
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
486
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
593
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
686
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
772
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
857
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
939
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1005
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mitte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
148
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
266
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
384
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
494
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
600
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
689
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
780
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
865
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
950
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1023
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unten
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
130
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
265
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
381
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
491
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
600
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
695
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
779
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
870
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
950
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1034
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Genauigkeit baryzentrische Interpolation
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die horizontale Verschiebung ist je nach Versuchsaufbau ähnlich zum linearen
 Ansatz.
 Mir mehr Referenzpunkten lässt sich dieses Problem aber sicher lösen.
 
\end_layout

\begin_layout Paragraph
Kompensation der Verzerrung
\end_layout

\begin_layout Standard
Wenn nur drei oder vier Referenzpunkte für eine Interpolation verwendet
 werden, ist das Resultat in der aufgespannten Fläche korrekt und sollte
 keine Störungen beinhalten.
 Wenn mit diesem Verfahren jedoch eine Linie über mehrere Dreiecke gezogen
 wird, hat diese an jedem Übergang eine neue Richtung.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Knicke in gezeichneten Linien
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das wird von einem Nutzer dadurch wahrgenommen, dass seine gezogene Linie
 nicht gerade ist, sondern Knicke enthält.
 Das wird als störend empfunden.
 
\end_layout

\begin_layout Paragraph
Lösung
\end_layout

\begin_layout Standard
Es wird nicht nur das Resultat eines Vierecks analysiert, sondern direkte
 Nachbarn werden ebenfalls berücksichtigt.
 Durch eine entsprechende Gewichtung sollte das Resultat nicht verfälscht
 werden, aber die Knicke soweit geglättet werden, dass sie den Nutzer nicht
 mehr auffallen.
 Da Baryzentrische Koordinaten leider keine Abstandsfunktion definieren,
 gewichten wir Resultate, die innerhalb liegen doppelt, solche in der Nähe(siehe
 Oben) einfach.
 Anschliessend werden die Werte linear gemittelt.
 So können wir dennoch eine leichte Gewichtung einfügen.
 Erkenntnisse: Interpolation anhand der Eckpunkte: Hierbei ist die Genauigkeit
 identisch mit dem linearen Ansatz, wenn man die vier möglichen Dreiecke
 berücksichtigt und entsprechend gewichtet.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/GewichtungCrop.pdf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Gewichtung der Vierecke
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Interpolation anhand eines feineren Gitters
\end_layout

\begin_layout Standard
Die Anzahl berücksichtigter Dreiecke ist hier sehr wichtig.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
Mittelung von 3 Resultaten:
\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/Cluster3.bmp
	width 70col%

\end_inset


\begin_inset Graphics
	filename Bilder/Calibration/Cluster3Detail.bmp
	width 30col%

\end_inset


\end_layout

\begin_layout Plain Layout
Mittelung von 15 Resultaten:
\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/Cluster15.bmp
	width 70col%

\end_inset


\begin_inset Graphics
	filename Bilder/Calibration/Cluster15Detail.bmp
	width 30col%

\end_inset


\end_layout

\begin_layout Plain Layout
Der Rotanteil der Pixel entspricht den interpolierten X-Werten, der Grünanteil
 den Y-Werten
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Interpolation anhand eines feinen Gitters mit baryzentrischen Dreiecken
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hier sieht man, dass man mit der Mittelung von mehreren Resultaten lokale
 unstimmigkeiten beheben kann.
 Es hat jedoch viele globale Unstimmigkeiten, die nicht korrigiert werden
 können.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/perfBarycentric.eps
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Benötigter Aufwand für baryzentrische Berechnung
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Ausblick: Interpolation anhand Vierecken 
\end_layout

\begin_layout Standard
Durch eine bestimmte Erweiterung der Baryzentrischen Koordinaten auf Vierecke,
 welche den Fakt berücksichtigen, dass die Vierecke nicht winkeltreu sind,
 können wir zudem die Verzerrung an den Übergängen korrigieren.
 
\end_layout

\begin_layout Standard
Formel 
\end_layout

\begin_layout Standard
Durch eine entsprechende Gewichtung kann man zu dem die Knicke so interpolieren,
 dass Knicke an den Kanten geglättet werden.
 Das ist gegeben durch die Möglichkeit, dass wir auch Punkte ausserhalb
 des Rechtecks bestimmen können.
 Diese korrigieren jedoch die perspektivische Verzerrung nicht.
 Diesen Faktor können jedoch mit einem feineren Raster kompensieren.
\end_layout

\begin_layout Subsection
Exkurs: Bewegter Lichtpunkt
\end_layout

\begin_layout Subsection
Versuche zur Umsetzung von Touch
\end_layout

\begin_layout Standard
Dieser Exkurs befasst sich mit der Vision, eine projizierte Beamerwand mittels
 Touch zu bedienen.
 Der Benutzer soll die projizierte Fläche mit der Hand antippen und so das
 System hinter der Projektion steuern können.
 Diese Aufgabenstellung lässt sich über verschiedene Fragestellungen analysieren.
\end_layout

\begin_layout Paragraph
Relevante Informationen finden
\end_layout

\begin_layout Standard
Zuerst muss klar werden, woraus die benötigten Informationen gewonnen werden.
 Es sind ein oder mehrere Kamerabilder denkbar
\begin_inset Foot
status open

\begin_layout Plain Layout
3D-Analysesysteme wurden vollständig ausser acht gelassen, da sie teurer
 sind als die in dieser Arbeit gesetzten Kostengrenze von Zusatzhardwarekosten
 (ca.
 20.-).
\end_layout

\end_inset

.
 Ebenfalls fragt sich, wie die Informationen aus diesem Kontext gewonnen
 werden können.
 Es ist möglich, die Person vor der Leinwand gegen ein Basisbild zu vergleichen
 oder bewegte Teile mittels Differenzbildanalyse über zwei oder mehr Bilder
 zu erkennen.
 Es könne der Person ein Handschuh angezogen werden, der eine eindeutige
 Farbe hat und so immer sogar in nur einem Kamerabild zu erkennen ist.
 Es wäre denkbar, eine Person mit komplizerteren Algorithmen über ein vorher
 konfiguriertes Pattern zu tracken.
 Die Mathematik birgt mit Fouriertransformation und Direct Linear Transformation
 viele Möglichkeiten Patternmatching zu betreiben.
 Die in dieser Arbeit untersuchten Ansätze sind einfacherer Art und beschränken
 sich darauf zu zeigen welche Aspekte betrachtet werden müssen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Handtracking/no-touch-basediff.png
	lyxscale 20
	width 49col%

\end_inset

 
\begin_inset Graphics
	filename Bilder/Handtracking/touch-basediff.png
	lyxscale 20
	width 49col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Finger in Ruhestellung (links) - Finger tippt auf Leinwand (rechts)
\begin_inset CommandInset label
LatexCommand label
name "fig:perspos-diffs"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Hand und Finger finden
\end_layout

\begin_layout Standard
Die Hand einer Person zu finden mit wenig Aufwand gut zu beschreiben.
 Über den unteren Rand des Kamerabildes wird die im Bild stehende Person
 mittels Differenzbilder gefunden.
 Die Position und das Ausmass des Körpers der Person ist mit wenig Spiel
 gut abschätzbar entlang zweier senkrechter Linien am Rand der Beine (siehe
 Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PersonPosition"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Handtracking/PersonPosition/pos-base.png
	lyxscale 20
	width 49.25col%

\end_inset


\begin_inset space \enskip{}
\end_inset


\begin_inset Graphics
	filename Bilder/Handtracking/PersonPosition/pos-frame.png
	lyxscale 20
	width 49.25col%

\end_inset


\begin_inset VSpace 0.5em
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Handtracking/PersonPosition/pos-diff.png
	lyxscale 20
	width 49.25col%

\end_inset


\begin_inset space \enskip{}
\end_inset


\begin_inset Graphics
	filename Bilder/Handtracking/PersonPosition/pos-median.png
	lyxscale 20
	width 49.25col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 0.5em
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Handtracking/PersonPosition/pos-final.png
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
1)
\begin_inset space ~
\end_inset

Basisbild, 2)
\begin_inset space ~
\end_inset

Frame, 3)
\begin_inset space ~
\end_inset

Differenz, 4)
\begin_inset space ~
\end_inset

entrauschtes Differenzbild, 5)
\begin_inset space ~
\end_inset

Personenposition
\begin_inset CommandInset label
LatexCommand label
name "fig:PersonPosition"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Handgesten erkennen
\end_layout

\begin_layout Standard
Handgesten wie Touch oder Greifen zu erkenn ist nicht ganz trivial.
 Der hier vorgeschlagene Ansatz versucht den Körper der Person vom Hintergrund
 durch den Schatten zu trennen.
 Die Unterscheidung zwischen Schatten und Person geschieht auf der Differenz
 gegen das Basisbild.
 So bleiben alle nicht benötigten Informationen unbeachtet.
 In Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:farbanalyse-schatten"

\end_inset

 ist der Unterschied zwischen Schatten und Arm auf dem Differenzbild sichtbar.
 Im Diagramm wurde analysiert, welche durchschnittlichen Farbwerte das Differenz
bild in einem vertikalen Streifen besitzt.
 Der Streifen wurde von oben nach unten über 480 Pixel durchlaufen.
 Das Maximux bezeichnet den Schatten das lokale Minimum den Arm.
 Sobald klar ist, an welcher Position sich der Übergang von Schatten zu
 Arm befindet, kann die Schattenfarbe im Originalbild nachgeschaut werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Handtracking/Gestenanalyse/arm-shadow-stripe.png
	lyxscale 50
	width 100col%

\end_inset


\begin_inset VSpace 0.5em
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Handtracking/arm-colors.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Die Helligkeitsanalyse innerhalb des oben gekennzeichneten vertikalen Streifen
 des Differenzbildes ergibt im Schnitt diese Farbaufteilung (unten).
\begin_inset CommandInset label
LatexCommand label
name "fig:farbanalyse-schatten"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Schattenfarbe wird aus dem Originalbild als weiss markiert und vom eingeschr
änkten Differenzbild abgezogen.
 Dann bleibt der Arm übrig ohne Schatteninformation.
 Der Gesamtanteil an Schatteninformation sind die vom eingeschränkten Differenzb
ild abgezogenen Pixel.
 Unter Umständen könnte die Menge an Schattenpixel und deren Position für
 die Detektion verwendet werden ob die Person die Leinwand antippt oder
 nicht.
 Dies ist eine sehr vage Theorie und bedarf weiterer Untersuchungen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Handtracking/Gestenanalyse/arm-shadow-diff.png
	lyxscale 50
	width 23.5col%

\end_inset


\begin_inset space \enskip{}
\end_inset


\begin_inset Graphics
	filename Bilder/Handtracking/Gestenanalyse/arm-shadow-thres.png
	lyxscale 50
	width 23.5col%

\end_inset


\begin_inset space \enskip{}
\end_inset


\begin_inset Graphics
	filename Bilder/Handtracking/Gestenanalyse/shadow-base.png
	lyxscale 50
	width 23.5col%

\end_inset


\begin_inset space \enskip{}
\end_inset


\begin_inset Graphics
	filename Bilder/Handtracking/Gestenanalyse/just-the-arm.png
	lyxscale 50
	width 23.5col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
1)
\begin_inset space ~
\end_inset

Differenzbild gegen Basis, 2)
\begin_inset space ~
\end_inset

Helldunkel-Schranke über Differenzbild, 3)
\begin_inset space ~
\end_inset

Schattenfarbe weiss markiert aus dem Originalbild, 4)
\begin_inset space ~
\end_inset

zweites minus drittes Bild
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Da nun der Arm gefunden ist, könnte in diesem eingeschränkten Bereich ein
 Pattern Matching durchgeführt werden.
 Ein Sample der Hand oder des Fingers könnte an Schlüsselpositionen gefunden
 werden.
 Die Information ob eine Geste wie Touch durchgeführt wurde, kann aus der
 streifenweisen Schattenanalyse geholt werden.
 Ist der Schatten in der richtigen Intensität am Richtigen Ort, so fand
 ein Touch statt, sonst nicht.
 Einfach dürfte dieses Vorgehen jedoch nicht sein.
 Es gibt zu viele Arten, wie die Schattenverteilung sein könnte.
 Hier wird vorgeschlagen, sich zuerst auf das genaue Finden der Hand festzulegen.
 Sobald die Hand getrackt werden kann, ist es möglich, weitere Schlüsse
 aus den sich daraus ergebenden Analysemöglichkeiten zu ziehen.
 
\end_layout

\begin_layout Standard
Eine Idee dazu ist, Bewegungen der Gelenke Schulter, Ellbogen und Hand aufzuzeic
hnen.
 Dies könnte über einen Ansatz mit Ausgleichsgeraden geschehen.
 Dazu wird von der Schulter mit einer radialen Scanline von unten über die
 Punktmenge des Armes gefahren.
 Sobald ein Punkt auftaucht, ist entweder die Hand oder der Ellbogen gefunden
 worden.
 Je nach Entfernung des Punktes von der Schulter lässt sich das einfach
 entscheiden.
 Am Ellbogen wird das Verfahren wiederholt bis der erste Punkt der Hand
 gefunden wurde.
 Das Fahren der Scanline kann mathematisch als Koordinatentransformation
 von euklidischen- zu Polarkoordinaten beschrieben werden.
 Dies vereinfacht das Modellieren der Scanline.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/Handtracking/Gestenanalyse/polar-scan.emf
	lyxscale 10
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Scanline-Ansatz um Gelenke zu finden
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Ergebnisse
\end_layout

\begin_layout Standard
Es ist schwierig zu sagen, ob es sinnvoll ist, Touch auf der Leinwand weiter
 zu verfolgen.
 Einerseits wäre diese Funktionalität innovativ und wünschenswert.
 Sie ist an keine weitere Hardware gebunden und die zugehörige Software
 könnte mit dem Betriebsystem zusammen ausgeliefert werden.
 Andererseits ist es sehr schwierig zu erkennen, ob eine Person die Leinwand
 angetippt hat.
 Bei schlechten Lichtbedingungen und komplizierteren projizierten Bildern
 konnte die Hand bei schneller Bewegung nicht einmal mehr mit blossem Auge
 erkannt werden.
 Ob eine Webcam mit schlechter Auflösung, niedriger Framerate und schlechter
 Belichtung überhaupt den Input für eine zuverlässige Datenverarbeitung
 liefern kann ist fraglich.
 Es sollte möglich sein, die Hand zu tracken und bei einem geübten Benutzer
 die Finger.
 Dies allerdings nur bei optimalen Lichtbedingungen.
 Es ist hingegen nicht klar, wie dass mit hoher Trefferrate festgestellt
 werden kann, ob die Person die Leinwand angetippt hat.
 Das oben beschriebene Vorgehen für die Schattenanalyse befasst sich lediglich
 mit den Daten, welche in dieser Arbeit aufgenommen wurde.
 Es müsste systematische untersucht werden, ob die dies für jeden Fall zuverläss
ig gelöst werden könnte.
\end_layout

\end_body
\end_document
