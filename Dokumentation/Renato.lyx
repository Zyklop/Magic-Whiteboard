#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{changepage}
\strictpagecheck

\newlength{\totalleftmargin}
\newcommand{\calctotalleftmargin}{%
  \setlength{\totalleftmargin}{\dimexpr+\hoffset+1in+\leftskip}%
  \checkoddpage%
  \addtolength{\totalleftmargin}{\ifoddpage\oddsidemargin\else\evensidemargin\fi}%
}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language german-ch
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Ausgangslage
\end_layout

\begin_layout Standard
Für eine erfolgreiche Anwendung vom PresentationWriter sind folgende Geräte
 nötig:
\end_layout

\begin_layout Itemize
Beamer, der auf eine Leinwand projiziert, die keine Unebenheiten hat 
\end_layout

\begin_layout Itemize
Webcam: 
\end_layout

\begin_deeper
\begin_layout Itemize
Die das ganze projizierte Bild erkennt.
 
\end_layout

\begin_layout Itemize
Mindestens 24 fps(Frames pro Sekunde) liefert 
\end_layout

\begin_layout Itemize
Die Projektion auf mindestens 300 x 200 Pixeln abgebildet wird 
\end_layout

\end_deeper
\begin_layout Itemize
Eine CPU mit mindestens 2 Cores mit mindestens 2 GHz.
 
\end_layout

\begin_layout Standard
Diese Kriterien sind für eine optimale Funktionalität nötig.
 Falls diese nicht erfüllt sind, ist ein Funktionieren möglich, kann aber
 nicht gewährleistet werden.
 
\end_layout

\begin_layout Subsection
Technologien
\end_layout

\begin_layout Subsubsection
Programmiersprache
\end_layout

\begin_layout Standard
Wir haben uns für die Programmiersprache C# entschieden, da uns diese besser
 liegt.
 Zudem war es einfacher auf Systemfunktionen wie z.B.
 Direct Show und Mausemulation zuzugreifen.
 
\end_layout

\begin_layout Standard
In Java wäre das nicht möglich gewesen.
 
\end_layout

\begin_layout Standard
Mit C++ hätten wir bei der Bildbearbeitung etwas weniger Performance benötigt,
 dafür hätten wir mehr Einarbeitungszeit benötigt.
 Aus unserer Sicht haben wir uns richtig entschieden.
 
\end_layout

\begin_layout Subsubsection
Framework
\end_layout

\begin_layout Standard
Beim grafischen Framework haben wir uns für AForge entschieden, da es nativ
 in C# geschrieben ist und gut dokumentiert ist.
 Im Gegensatz dazu hätten wir mit OpenCV etwas besser optimierte Algorithmen
 gehabt.
 Da wir nur einen Prototypen produzieren, ist Performance für uns nicht
 besonders wichtig, was unsere Wahl ebenfalls beeinflusst hat.
 
\end_layout

\begin_layout Section
Architektur 
\end_layout

\begin_layout Subsection
Grundüberlegungen
\end_layout

\begin_layout Standard
Unser Hauptprojekt wird eine ausführbare Datei, die alle unsere Subprojekte
 zusammenbringt.
 
\end_layout

\begin_layout Standard
\noindent
Grobablauf unseres Programms: 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/SSD.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
SSD
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Enumerate
Verbindung mit der Kamera 
\end_layout

\begin_deeper
\begin_layout Enumerate
Der Nutzer kriegt eine Auswahl aller gefundenen Kameras und entscheidet
 sich für eine.
 
\end_layout

\begin_layout Enumerate
Anhand der Auswahl wird die Kamera angelegt und gestartet.
 
\end_layout

\end_deeper
\begin_layout Enumerate
Das Programm sucht einen passenden Visualisierer und legt diesen an.
 
\end_layout

\begin_layout Enumerate
Ein DataParser wird angelegt.
 
\end_layout

\begin_layout Enumerate
Die Kalibration kann nun automatisch oder nach einer Interaktion des Benutzers
 gestartet werden.
 
\end_layout

\begin_layout Enumerate
Die Details über den Ablauf des Kalibrationsvorgang sind im Abschnitt Kalibratio
n aufgeführt.
 
\end_layout

\begin_layout Enumerate
Kalibration wird erfolgreich abgeschlossen und das Pentracking gestartet.
 Die Details über den Ablauf des Trackings sind im Abschnitt Pen-Tracking
 aufgeführt.
 
\end_layout

\begin_layout Section
Visualisierung 
\end_layout

\begin_layout Standard
Ein erstes Problem bot sich uns, als wir versuchten, aus einer Library auf
 den Bildschirm zu zeichnen.
 Das wiederspricht eigentlich allen Architekturmodellen, jedoch ist es bei
 unserer Lösung nötig für die Kalibration.
 
\end_layout

\begin_layout Subsection
Probleme
\end_layout

\begin_layout Itemize
Wir wissen nicht, in welcher Umgebung (Anzahl Treads) unsere Library läuft.
 Gewisse Kameras erzeugen zudem verschiede Threads in denen die Frames übergeben
 werden.
 
\end_layout

\begin_layout Itemize
Jedes GUI muss in einem eigenen Thread laufen das ein spezielles ThreadSTA-Attri
but hat.
 
\end_layout

\begin_layout Itemize
Der Garbage-Collector räumt den GUI-Thread ab, selbst wenn er in Zukunft
 noch verwendet werden müsste.
 
\end_layout

\begin_layout Itemize
Wenn ein GUI gestartet wird, öffnet es sich sofort.
 Das ist in unseren Fall nicht erwünscht.
 Ein Hide, das gerade nach dem Start aufgerufen wird, hat keine Wirkung.
 Es muss erst der komplette Start und die Darstellung des GUIs(ca.
 10ms) abgewartet werden, bis es versteckt werden kann.
 
\end_layout

\begin_layout Subsection
Umsetzungen
\end_layout

\begin_layout Subsection
WPF
\end_layout

\begin_layout Standard
Sämtliche Interaktionen müssen über den Dispatcher geschehen.
 Andernfalls wird sofort eine Exception geworfen.
 Dadurch kann die Concurrency vom aufrufenden Code wieder Sequenziell abgearbeit
et werden, wie es für ein GUI nötig ist.
 Eine Lösung zu entwickeln, die komplett Concurrency-Safe ist ziemlich aufwändig
 und zeitintensiv.
 
\end_layout

\begin_layout Subsubsection
WinForms 
\end_layout

\begin_layout Standard
Mit dem AllowUnsafeThreadExecution Attribut kann die ganze Thread-security
 abgeschaltet werden.
 Dafür müssen alle Grafikelemente vor dem Bearbeiten gelockt werden und
 der aufrufende Code ist verantwortlich dafür, dass die Aufrufreihenfolge
 und der Ablauf stimmt.
 Durch Double-Buffering kann die Performance erhöht werden, wenn mehrere
 Objekte gezeichnet werden.
 Es ist uns klar, dass diese Umsetzung diverse Architekturprinzipien und
 Guidelines verletzt.
 
\end_layout

\begin_layout Standard

\series bold
In einem finalen Release darf diese Umsetzung nicht verwendet werden.

\series default
 
\end_layout

\begin_layout Section
Kalibration 
\end_layout

\begin_layout Subsection
Überlegungen 
\end_layout

\begin_layout Standard
Die Grundüberlegung jedes Ansatzes der Kalibration ist derselbe: Im ersten
 Schritt werden die Ecken des Bildschirms gefunden, in den weiteren Schritten
 werden zusätzliche Daten gesammelt um die Interpolation zu verbessern.
 
\end_layout

\begin_layout Subsection
Erste Erkenntnisse 
\end_layout

\begin_layout Enumerate
Als erster Schritt ist es nötig, dass ein Frame einzulesen, um die Auflösung
 der Kamera zu erhalten.
 
\end_layout

\begin_layout Enumerate
Das erhaltene Bild ist weder Flächen- noch Winkeltreu.
 
\end_layout

\begin_layout Enumerate
Die Belichtungskorrektur der Kamera ist sehr gefährlich, um ein sinnvolles
 Differenzbild zu erhalten, muss darauf geachtet werden, dass auf beiden
 Bildern die gleiche Helligkeitsverteilung herrscht.
 Dies Verunmöglicht, ein universelles Bild zu speichern, mit dem man den
 Hintergrund entfernen könnte.
 
\end_layout

\begin_layout Enumerate
Die Belichtungskorrektur benötigt ca.
 1-2 Frames, bis sie reagiert.
 Aus Performance-Gründen lässt sich das leider nicht zu unserem Vorteil
 nutzen.
 
\end_layout

\begin_layout Enumerate
Von gewissen Webcams wird das Bild gespiegelt zurückgegeben, von anderen
 nicht.
 
\end_layout

\begin_layout Enumerate
Bis die Bilder der Kamera dem entsprechen, was man erwarten würde, muss
 man ca.
 100ms warten.
 Diese Dauer ist zudem vom gewählten Visualisierer abhängig.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/Verzögerung1.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/Verzögerung2.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Verzögerung der Darstellung
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Die Linse der Kamera kann für eine zusätzliche Verzerrung sorgen.
 
\end_layout

\begin_layout Enumerate
Berechnungen mit C# Bitmaps sind extrem inperformant.
 
\end_layout

\begin_layout Enumerate
Eine sequentielle Bearbeitung der Daten führt dazu, dass man mit veralteten
 (und somit falschen) Daten arbeitet.
 
\end_layout

\begin_layout Enumerate
Eine parallele Bearbeitung der führt meistens zum unkontrollierten Spawnen
 von Tasks, die das System verlangsamen und schliesslich ein Ablaufen verunmögli
chen.
 Falls das Auftritt, hat man ebenfalls Probleme mit alten Daten.
 
\end_layout

\begin_layout Enumerate
Wenn ein Teil der Anzeige durch ein anderes Fenster oder einem Objekt verdeckt
 wird, ist das unmöglich automatisch zu detektieren.
 Daher muss die Erkennung noch durch den Nutzer verifiziert werden.
 
\end_layout

\begin_layout Subsection
Allgemeine Massnahmen
\end_layout

\begin_layout Itemize
Der Ablauf wird von einer Semaphore geschützt.
 Wenn kein Lock akquiriert werden kann, wird das ankommende Bild verworfen
 und nicht behandelt.
 
\end_layout

\begin_layout Itemize
Nach jedem Zeichnen wird 100 ms gewartet bevor die Semaphore freigegeben
 wird, damit sichergegangen werden kann, dass das erwartete Bild von der
 Kamera ankommt.
 
\end_layout

\begin_layout Subsection
Umsetzungsversuche 
\end_layout

\begin_layout Subsubsection
Selber programmierte Eckdetecktion mit Differenzbildern und zufällig verteilten
 Rechtecken.
 
\end_layout

\begin_layout Subparagraph
Ablauf
\end_layout

\begin_layout Enumerate
Der Bildschirm wird Schwarz gemacht.
 Das entsprechende Bild wird gespeichert.
 
\end_layout

\begin_layout Enumerate
Der Bildschirm wird weiss gemacht und das Differenzbild gemacht.
 Mit 4 Scanlinien werden von jeder Ecke ausgehend unter 45° ein Punkt gesucht,
 dessen Nachbarn in Richtung der gegenüberliegenden Ecke Liegen eine bestimmte
 Deckung besitzen.
 Es wird ein Quadrat mit Seitenlänge 3-5 Pixel berücksichtigt.
 
\end_layout

\begin_layout Enumerate
Es werden 3 Rechtecke mit zufälligen Eckpunkten gezeichnet und die Eckpunkte
 gespeichert, eins pro Farbkanal.
 Auf dem Differenzbild zum Ersten werden mit dem geleichen Verfahren zu
 jedem Farbkanal die Ecken gesucht.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Scanlinien.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Sacnlinien
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Erfolge
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
Ecken des Bildschirms wurden ungefähr erkannt, die meisten der dargestellten
 Rechtecken auch.
 
\end_layout

\begin_layout Subparagraph
Nachteile
\end_layout

\begin_layout Enumerate
Ich habe nur wenig Verbesserungspotenzial bei dieser Lösung gesehen, und
 dieses wäre teuer zu erkaufen gewesen.
 
\end_layout

\begin_layout Enumerate
Da grosse Teile des Bildschirms umgefärbt wurden, gab es Probleme mit der
 Belichtungskorrektur.
 
\end_layout

\begin_layout Enumerate
Die Farbkanäle waren schwierig sauber zu trennen und haben häufig Probleme
 verursacht.
 Überschneidungen waren sehr Problematisch.
 
\end_layout

\begin_layout Subsubsection
Verwendung des AForge-Blob-Detctors
\end_layout

\begin_layout Standard
Diese wird in den kommenden Lösungen immer eingesetzt.
 Ich werde bei jeder Lösung nur auf geänderte und wichtige Aspekte erwähnen.
 Funktionierende Teile wurden jeweils übernommen.
 Die verschiedenen Kalibratoren die Im Code existieren sind keine 1 zu 1
 Umsetzungen der hier beschriebenen Ansätze, sondern Kombinationen davon.
 Der Code von verworfenen Umsetzungen wurde in anderen Umsetzungen teilweise
 Übernommen und aktualisiert.
 Diese Aktualisierungen wurden nicht Nachgepflegt aus dem Grund, dass ich
 diese Lösungen nicht als sinnvoll für ein Weiterverfolgen erachte.
 
\end_layout

\begin_layout Subsubsection
Einfacher Differenzbild-Kalibrator
\end_layout

\begin_layout Enumerate
Als erstes Bild wird der Bildschirm schwarz gefärbt.
 Dieses Bild dient als Grundbild für alle folgenden Differenzbilder 
\end_layout

\begin_layout Enumerate
Der Bildschirm wird komplett weiss gefärbt.
 Auf dem Differenzbild wird der grösste Blob gesucht.
 Das sind dann die Ecken des Bildschirms.
 
\end_layout

\begin_layout Enumerate
Es werden Grüne und blaue Quadrate jeweils versetzt auf den Bildschirm projizier
t, die bei jedem Frame leicht verschoben werden um mehr Referenzpunkte zu
 bekommen.
 Die Erkennung des roten Farbkanals ist am schlechtesten, deshalb verwenden
 wir blau und grün.
 Zwei Farben sind ausreichend, wenn sie mit einem Feld Abstand projiziert
 werden, dass es keine Nachbarschaftskonflikte gibt.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/bgSchachbrett.png
	width 45text%

\end_inset


\begin_inset Formula $\rightarrow$
\end_inset


\begin_inset Graphics
	filename Bilder/Calibration/Scahcbrett erkannt.png
	width 45text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Schachbrettmuster über zwei Farbkanäle
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Diese werden auf dem Differenzbild gesucht.
 Deren Zuordnung wird in einem Folgenden Abschnitt auf Seite ??? behandelt.
 
\end_layout

\begin_layout Standard
Probleme: 
\end_layout

\begin_layout Itemize
Durch die Belichtungskorrektur der Kamera wird ein universeller Hintergrund
 für ein Differenzbild verunmöglicht.
 Es gibt zu viele Fehlerkennungen auf dem Bild.
 
\end_layout

\begin_layout Subsubsection
Histogramm-analyse 
\end_layout

\begin_layout Standard
Hierbei werden keine Differenzbilder gebildet, sondern Helligkeitswerte
 des Bildes analysiert und so können überdurchschnittlich helle Flächen
 (Projektionen) gefunden werden.
 Die restlichen Bildinformationen werden entfernt um eine Blob-Erkennung
 zu ermöglichen.
 
\end_layout

\begin_layout Standard
Durch unterschiedliche Lichtverhältnisse in Bildbereichen ist dieser Ansatz
 anfällig auf Störungen.
 Die Lösung für dieses Problem ist ein aufteilen des Bildes.
 Dabei wird das Bild in verschiedene Regionen aufgeteilt, wo die Helligkeitswert
e weniger stark verteilt sind.
 Anschliesend werden die Flächen wieder zu einem Bild zusammengesetzt.
 
\end_layout

\begin_layout Paragraph
Ablauf
\end_layout

\begin_layout Enumerate
Es wird eine weisse Fläche projiziert.
 Das Bild wird in 2x2 Teile aufgeteilt und der grösste Blob gesucht.
 Das führt zu den Eckepunkten.
 
\end_layout

\begin_layout Enumerate
Es werden die grünen und blauen Quadrate aus dem Vorherigen Verfahren projiziert.
 Das Bild wird in 4 x 4 Teile aufgeteilt und der blaue oder grüne Farbkanal
 separat analysiert.
 In den zwei resultierenden Bildern werden Blobs erkannt und analysiert.
 
\end_layout

\begin_layout Paragraph
Erkenntnisse
\end_layout

\begin_layout Itemize
Die Erkennung der Blobs klappt relativ gut, jedoch sind die Kanten relativ
 unscharf was für eine genaue Erkennung ein Nachteil ist.
 
\end_layout

\begin_layout Itemize
Die automatische Belichtungskorrektur ist kein Problem mehr.
 
\end_layout

\begin_layout Itemize
An den Kanten bei denen das Bild aufgeteilt wurde entstehen häufig Einschnitte
 oder sonstige Ungenauigkeiten.
 Diese sind keine grossen Probleme für den Blob-Detector, jedoch sind sie
 eine weitere Quelle für Ungenauigkeiten.
 Durch eine Filterung nach Grösse erhält man ein gutes Resultat.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/img3.jpg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Erkannte grüne Quadrate
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Schachbrett-Differenzbilder
\end_layout

\begin_layout Standard
Um Differenzbilder nutzen zu können, aber sich nicht durch die Belichtungskorrek
tur beeinflussen zu lassen, muss darauf geachtet werden, dass jedes projizierte
 Bild eine identische Helligkeitsverteilung zum Referenzbild besitzt.
 Das bedeutet, dass für jedes Bild, das man analysieren möchte, zwei Bilder
 Projiziert werden müssen.
 Da diese Art der Erkennung viel genauer ist, nehmen wir diesen Overhead
 in Kauf und verzichten allenfalls auf ein paar Referenzbilder.
 „Lieber wenig gute Daten, als viel schlechte“ 
\end_layout

\begin_layout Paragraph
Ablauf
\end_layout

\begin_layout Enumerate
Es wird ein Schachbrett mit n x m Quadraten projiziert.
 Das Verhältnis von n zu m sollte dem Bildschirmverhältnis entsprechen und
 die Quadrate sollten noch gut auf dem Kamerabild sichtbar sein (15 – 30
 Pixel Seitenlänge) 
\end_layout

\begin_layout Enumerate
Das Schachbrett wird erneut projiziert, diesmal mit invertierten Farben.
 Auf dem Differenzbild sollte jetzt die Leinwand klar zu erkennen sein.
 Da es an den Kanten der Quadrate Lücken haben wird (diejenigen Pixelreihen,
 die von der Kamera auf beiden Bildern als Beleuchtet erkannt hat), müssen
 wir diese z.B.
 mit einem Gaussfilter mit einer kleinen Kernel-Size eliminieren, da es
 sonst bei der Bloberkennung zu Fehlerkennungen kommt.
 Jetzt können die Ecken des Bildschirms sehr genau erkannt werden.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/img01-0-0.jpg
	width 45col%

\end_inset

- 
\begin_inset Graphics
	filename Bilder/Calibration/img02-0-0.jpg
	width 45col%

\end_inset

 = 
\begin_inset Graphics
	filename Bilder/Calibration/diff.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
Gaussfilter mit Rafius 3, um die Erkennung zu verbessern:
\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/diffblur.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Erkennung des Bildschirms
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Anschliessend werden jeweils zwei Bilder projiziert, deren Differenz genau
 das bekannte Blau-Grüne Muster ergibt.
 Bild So können die Recktecke auf dem Bild ganz scharf und klar erkannt
 werden und identifiziert werden.
 Durch das Bilden eines weiteren Differenzbildes mit den beiden erwünschten
 Farbkanälen kann das meiste Bildrauschen und allfällige Unsicherheiten
 entfernt werden.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/img03-1-0.jpg
	width 45col%

\end_inset

 - 
\begin_inset Graphics
	filename Bilder/Calibration/img03-0-0.jpg
	width 45col%

\end_inset


\end_layout

\begin_layout Plain Layout
=
\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Calibration/Colordiff.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Farbmuster
\end_layout

\end_inset


\end_layout

\end_inset

Störungen wie sie hier in der oberen linken Ecke Vorhanden sind können entfernt
 werden, dadurch, dass sie nicht innerhalb der erkannten Bildschirmecken
 liegen.
 Die Grundkalibration ist durchch die Bedingung, dass alle Bildschirmecken
 mindestens 5 Pixel Abstand zu jedem Rand haben müssen.
\end_layout

\begin_layout Subsection
Mapping der Quadrate
\end_layout

\begin_layout Standard
Vom AForge BlobCounter erhalten wir genau alle Blobs die auf dem Kamerabild
 gefunden wurden.
 
\end_layout

\begin_layout Standard
Diese Daten beinhalten: Schwerpunkt, Umfassungsrechteck, Fläche, Breite,
 Höhe.
 Eine Zuordnung zu machen, welcher Blob zu welchen pojizietem Quadrat gehört.
 Durch eine Filterung mit einer vordefinierten minimalen und maximalen Höhe/Brei
te können wir die Blobs filtern und rauschen entfernen.
 Da wir die Ecken des Bildschirms mit Sicherheit kennen, können wir anhand
 des konstruierten Vierecks bestimmen ob ein Blob innerhalb der Projektion
 liegt und andernfalls entfernen.
 Somit können wir jetzt 99% der Fehlerkennungen eliminieren.
 Die Schwerpunkte der Blobs sind jedoch mit Koordinaten des Kamerabildes
 beschrieben, was es für uns schwierig macht, deren Position auf dem Bildschirm
 zu bestimmen, da diese relativ komplex voneinander abhängen.
 So kann z.B.
 die kleinste X-Koordinate zuunterst liegen und die grösste Y-Koordinate
 rechts oben.
 Je nach Verzerrung ist es so schon sehr schwierig nur schon die obere linke
 Ecke zu finden.
 
\end_layout

\begin_layout Paragraph
Mögliche Ansätze
\end_layout

\begin_layout Subsubsection
Rekursiv: 
\end_layout

\begin_layout Standard
Hierbei nehmen wir an, dass die Nachbarn eines Blobs eindeutig bestimmt
 werden können.
 Dies ist möglich anhand der Distanz.
 
\end_layout

\begin_layout Paragraph
Ablauf
\end_layout

\begin_layout Enumerate
Der Algorithmus bestimmt auf jedem Farbkanal denjenigen Blob, der am nächsten
 bei der oberen linken Ecke liegt.
 Durch die Positionsangabe 0|0 für grün oder 1|1 ist bekannt, dass es sich
 um einen Eckpunkt handeln muss.
 Der Punkt wird markiert, dass er nicht nochmals bearbeitet werden muss.
 
\end_layout

\begin_layout Enumerate
Es werden also die zwei nächsten Nachbarn gesucht.
 Anhand der Differenz der der Koordinaten kann bestimmt werden, ob der Punkt
 oberhalb (Y-Differenz ist grösser als die Differenz der X-Achse und negativ),
 rechts (X-Differenz ist grösser und positiv), unten oder links liegt.
 
\end_layout

\begin_layout Enumerate
Die Funktion berechnet die Koordinaten die der gefundene Blob haben muss
 (zwei in die entsprechende Achse verschoben) und startet einen Rekursiven
 Aufruf auf jedem unmarkierten Nachbar, nachdem der Ausgangspunkt als erledigt
 markiert wurde.
 
\end_layout

\begin_layout Enumerate
Der rekursive Aufruf prüft zudem, ob die übergebenen Koordinaten plausibel
 erscheinen und bestimmt anhand deren, wie viele Nachbarn zu erwarten sind.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagramme/Rekursion.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Vorgehen Rekursion
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Erkenntnisse
\end_layout

\begin_layout Itemize
Dieser Algorithmus funktioniert perfekt unter synthetischen Umständen, d.h.
 mit generierten Bildern.
 
\end_layout

\begin_layout Itemize
Aufgrund des iterativen Vorgehens sollte dieser Algorithmus in der Lage
 sein, um Bereiche, in denen keine Blobs gefunden wurden, herumzugehen.
 
\end_layout

\begin_layout Itemize
Wenn ein Quadrat nicht erkannt wurde, wird meist die Diagonale als nächster
 Nachbar gefunden, das für die folgende Erkennung schwerwiegende Folgen
 hat.
 
\end_layout

\begin_layout Itemize
Häufig werden nicht alle Blobs erreicht.
 Somit werden nicht alle Blobs zugeordnet und Informationen verloren.
 
\end_layout

\begin_layout Itemize
Falsch zugeordnete Blobs können unmöglich identifiziert werden.
 Eine solche hat jedoch für die nachfolgende Interpolation schwerwiegende
 Folgen indem sie in einem Bildbereich das mapping komplett zerstört.
 
\end_layout

\begin_layout Paragraph
Verbesserungen
\end_layout

\begin_layout Itemize
Es wird nicht nur eine erwartete Position gespeichert, sondern mehrere.
 
\end_layout

\begin_layout Itemize
Die Position wird nicht bei der Iteration gespeichert, sondern jedes Mal,
 wenn der Blob als Nachbar gefunden wurde.
 
\end_layout

\begin_layout Itemize
Es wird nicht nur in der linken oberen Ecke gestartet, sondern in allen
 vier Ecken.
 
\end_layout

\begin_layout Itemize
Die finale Position wird festgelegt durch Auswahl der Position, die am häufigste
n bestimmt wurde.
 
\end_layout

\begin_layout Itemize
Man hat die Möglichkeit, die Position anhand eines folgenden ähnlichen Bildes
 zu verifizieren.
 Dabei werden zur Verifikation ausserdem die Daten desjenigen Blobs verwendet,
 der den ähnlichsten Schwerpunkt hat und die sich somit entsprechen sollten.
 
\end_layout

\begin_layout Itemize
Es werden nicht mehr die nächsten Nachbarn gesucht, sondern es wird analysiert,
 auf welcher Achse die Blobs liegen und gezielt dort der nächste Blob gesucht.
 So können Diagonal liegende Punkte nicht mehr die Erkennung stören.
 
\end_layout

\begin_layout Paragraph
Weitere Erkenntnisse
\end_layout

\begin_layout Itemize
Die Ergebnisse sind nur wenig besser geworden und genügen den Anforderungen
 noch nicht.
 
\end_layout

\begin_layout Itemize
Die Fehlerkennungen sind auf folgenden Bildern ähnlich, somit bringt die
 Verifikation praktisch nichts.
 
\end_layout

\begin_layout Itemize
Das Debugging, das schon vorher aufwendig und mühsam zurückzuverfolgen war,
 ist jetzt praktisch unmöglich.
 Man kann nicht mehr herausfinden woher gewisse Werte kommen oder den Ablauf
 rekonstruieren.
 
\end_layout

\begin_layout Subsubsection
Nutzung der Interpolation 
\end_layout

\begin_layout Standard
Hierbei wird ausgenutzt, dass man anhand der Interpolation mit den Eckpunkten
 die Bildschirmkoordinaten ungefähr voraussagen kann.
 Es gibt dazu mehrere Möglichkeiten, die im Abschnitt ??? beschrieben werden.
 
\end_layout

\begin_layout Paragraph
Ablauf: 
\end_layout

\begin_layout Enumerate
Man iteriert durch die Blobs und bestimmt zu jedem die Interpolation des
 Schwerpunkts.
 
\end_layout

\begin_layout Enumerate
Es wird überprüft, in welchem Quadrat der Schwerpunkt zu liegen kommt.
 Falls das Quadrat die gleiche Farbe hat, wird die Position als gültig angenomme
n.
 
\end_layout

\begin_layout Paragraph
Vorteile 
\end_layout

\begin_layout Itemize
Mit dieser Methode können Abweichungen von +- einem Quadrat erkannt werden.
 
\end_layout

\begin_layout Itemize
Es gibt praktisch keine Fehlerkennungen.
 
\end_layout

\begin_layout Itemize
Durch vergrössern der Quadrate kann die Erkennung verbessert werden.
 
\end_layout

\begin_layout Itemize
Dieses Verfahren ist viel performanter als andere.
 
\end_layout

\begin_layout Paragraph
Nachteile
\end_layout

\begin_layout Itemize
Dieses Verfahren ist von einer guten interpolation abhängig.
 Wenn dieses jedoch gut ist, erübrigen sich weitere Kalibrationsschritte.
\end_layout

\begin_layout Itemize
Mit einem linearen Ansatz werden nur ein kleiner Teil der Blobs korrekt
 erkannt, die meisten bleiben ungültig.
 
\end_layout

\begin_layout Itemize
Durch Vergrösserung der Quadrate wird die Menge der nutzbaren Daten ebenfalls
 verkleinert.
\end_layout

\begin_layout Itemize
Vereinzelt kommt es unter schlechten  zu Fehlerkennungen, die als gültig
 erkannt werden.
 Dies resultiert in schwerwiegenden Fehlern beim komende mapping und kann
 nicht detektiert werden.
\end_layout

\begin_layout Subsubsection
Strahlensatz
\end_layout

\begin_layout Standard
Es wird ein physikalisches Modell mit einer Lochkamera erstellt.
 Durch Anwendung des Strahlensatzes kann ein mapping erstellt werden.
 
\end_layout

\begin_layout Standard
Eine zusätzliche Voraussetzung dafür ist dafür ist, dass die Projektion
 ein rechtwinkliges Dreieck ist.
 Das heisst, dass die Trapezkorrektur des Beamers immer zwingend ausgeführt
 werden muss.
 
\end_layout

\begin_layout Subsubsection
K-Means Cluster-zuordnung mit steigender Genauigkeit
\end_layout

\begin_layout Paragraph
Ablauf
\end_layout

\begin_layout Enumerate
Es werden die Eckpunkte des Bildschirms erkannt.
 
\end_layout

\begin_layout Enumerate
Alle Kanten werden in der Mitte geteilt und deren Mittelpunkte visualisiert.
 
\end_layout

\begin_layout Enumerate
Die erkannten Punkte werden mit K-Means zu den erwarteten Werten zugeordnet.
 
\end_layout

\begin_layout Enumerate
Aus dem Ergebnis resultieren weitere Rechtecke, auf denen das Verfahren
 wieder angewandt werden kann.
 
\end_layout

\begin_layout Paragraph
Erkenntnisse 
\end_layout

\begin_layout Itemize
Es ist schwierig die Punkte an den Rändern zu visualisieren und zu erkennen.
 Der Grund dafür liegt darin, dass man nicht über die Kanten des Beamers
 hinaus projizieren kann.
 Die Lösung dafür haben wir erreicht durch Analyse der Kanten der Blobs
 an den Rändern.
 
\end_layout

\begin_layout Itemize
Ein fehlender Punkt könnte aus den anderen interpoliert werden.
 
\end_layout

\begin_layout Itemize
Die Blobs müssen relativ klein projiziert werden, dass die folgenden Schritte
 funktionieren.
 Das erfordert eine genauere Erkennung.
 
\end_layout

\begin_layout Itemize
Fehlerkennungen führen dazu, dass die weiteren Schritte fehlschlagen werden.
 Das ermöglicht eine gute Fehlererkennung.
 
\end_layout

\begin_layout Itemize
Es gibt praktisch keine Fehlerkennungen.
 Stattdessen wird die Erkennung komplett fehlschlagen, auf was besser reagiert
 werden kann.
 
\end_layout

\begin_layout Itemize

\series bold
Diesen Ansatz lohnt es sich weiterzuverfolgen
\series default
.
 
\end_layout

\begin_layout Subsubsection
Open CV Kamerakalibration
\end_layout

\begin_layout Standard
Das OpenCV Framework bietet die Möglichkeit, Webcambilder zu analysieren
 und Schachbrettmuster zu erkennen.
 Anhand von denen wird zu jedem erkannten Muster eine Transformationsmatrix
 erstellt.
 Mit mehreren Erkennungen kann so ein Teil des Bildraums dreidimensional
 erkannt werden.
 
\end_layout

\begin_layout Paragraph
Anwendung
\end_layout

\begin_layout Itemize
Anhand der verschiedenen erkannten Ebenen lassen sich 3d Transformationen
 durchzuführen.
 
\end_layout

\begin_layout Itemize
Die Erkennung klappt nur selten, das ist aber nicht störend, da auch dann
 noch genügend Ebenen vorhanden sind.
 
\end_layout

\begin_layout Itemize
Die Erkennung lässt sich anhand der Parameter nur wenig beeinflussen.
 
\end_layout

\begin_layout Paragraph
Erkenntnisse
\end_layout

\begin_layout Itemize
Die Erkennung hat in meinem Fall nie gekappt.
 
\end_layout

\begin_layout Itemize
Wir brauchen keine 3d Rekonstruktion, nur eine Ebene.
 Dabei nützt uns dieser Algorithmus nur wenig.
 
\end_layout

\begin_layout Itemize
Das Framework ist sehr schlecht dokumentiert.
 
\end_layout

\begin_layout Itemize
Ein umschreiben des Codes auf unsere Anwendung ist viel zu aufwändig aufgrund
 der Komplexität.
 
\end_layout

\begin_layout Itemize
Es gibt abgesehen von offiziellen Codesample praktisch keine Einsatzmöglickeiten.
 
\end_layout

\begin_layout Section
Interpolation
\end_layout

\begin_layout Standard
Hierbei geht es darum, wie man anhand der gefundenen Referenzpunkte die
 genauste Interpolation für ein mapping eines Kamerapixels auf eine Bildschirmko
ordinate erhält.
 Diese Verfahren haben wir testweise auch auf die Ecken des erkannten Bildschirm
s angewandt, um die Genauigkeit zu überprüfen.
 
\end_layout

\begin_layout Subsection
Lineare Interpolation
\end_layout

\begin_layout Standard
Skizze 
\end_layout

\begin_layout Standard
Hierbei wird ausgenutzt, dass die Verhältnisse der Strecken auf der Abbildung
 identisch bleiben.
 Dies ist in unserem Fall nicht ganz korrekt, da es die perspektivische
 Verzerrung nicht berücksichtigt, was sich nicht schwerwiegend auswirkt,
 jedoch zu einer gewissen Ungenauigkeit führt.
 Nachteile dieses Verfahrens sind zudem, dass in jedem Quadranten des gesuchten
 Punktes ein Punkt gefunden werden muss, die zusammen auf dem Bildschirm
 ein Rechteck bilden.
 Diese Voraussetzung ist für die Eckpunkte gegeben, jedoch ein erschwerender
 Faktor wenn eine unregelmässige Verteilung von Referenzpunkten gegeben
 ist.
 Ausserdem kann dieses Verfahren nur in eine Richtung angewandt werden,
 nämlich von Bildschirmkoordinaten zu Kamerapixeln.
 Dies ist für uns die falsche Richtung, sodass wir alle Werte vorberechnen
 und speichern müssen.
 
\end_layout

\begin_layout Standard
Formel: Formel 
\end_layout

\begin_layout Subsection
Baryzentrische Koordinaten
\end_layout

\begin_layout Paragraph
Funktionsweise
\end_layout

\begin_layout Standard
Baryzentrische Koordinaten beschreiben in jedem n-Eck n Faktoren, die das
 Flächenverhältnis zwischen den Flächen zwischen den Kanten und einem Punkt
 beschreiben.
 Deren Summe ist immer 1.
 Anhand dieser Faktoren lässt sich sehr einfach ein Rebasing durchführen.
 Das heisst, wenn man Die Punkte in einem anderen System hat, die den Eckpunkten
 im Ursprungssystem entsprechen, kann man die Position des Punktes im Zielsystem
 analysieren.
 Dies ist in unserem Fall bei allen Referenzpunkten gegeben.
 Ein Punkt kann sogar bestimmt werden, wenn er nicht innerhalb des Dreiecks
 liegt.
 Wir werden hier dieses Thema nicht weiter behandeln, es gibt viele andere
 Papers, die dieses Thema sehr ausführlich behandeln.
 
\end_layout

\begin_layout Paragraph
Unsere Anwendung
\end_layout

\begin_layout Standard
Byzantinische Koordinaten berücksichtigen leider keine perspektivischen
 Verzerrungen, wie sie bei uns vorkommen, was deren Funktionalität leider
 etwas einschränkt.
 Somit können wir sie nur verwenden, wenn ein Punkt innerhalb oder zumindest
 in der Nähe liegt.
 Andernfalls gibt es extreme Ungenauigkeiten, die ein Resultat unbrauchbar
 machen.
 Wir definieren die Nähe dadurch, dass alle Faktoren kleiner als 1.5 sein
 müssen.
 Wenn sie kleiner als 1 sind ist der Punkt innerhalb.
 Mit 1.5 darf er zu einer Kante eine Fläche gegen aussen aufspannen, die
 maximal der Hälfte der ganzen Fläche entspricht.
 Das entspricht einen maximalen Abstand der halben Dreieckshöhe zur Kante.
 Da die Nutzung von n-Ecken weder zusätzliche Genauigkeit noch sonstige
 Vorteile bringt, nutzen wir Baryzentrische Koordinaten nur in Dreiecken.
 Durch eine Mittelung der resultierenden Koordinaten anhand mehrerer Dreiecke
 können wir die Störungen der Verzerrung etwas minimieren.
 Wenn wir genügend Referenzpunkte haben, fällt das nicht mehr ins Gewicht.
 
\end_layout

\begin_layout Paragraph
Ergebnisse
\end_layout

\begin_layout Standard
Wenn der Beamer und das Notebook nebeneinander stehen, funktioniert die
 Interpolation anhand der Eckepunkte ziemlich gut.
 Wir haben jedoch hauptsächlich unter erschwerenden Umständen getestet.
 Hier gab es bei der linearen Interpolation gewisse Verschiebungen in horizontal
er Richtung.
 Es entspricht nicht unserer erwünschten Genauigkeit.
 Mit den baryzentrischen Koordinaten anhand der Eckpunkte hatten wir anfangs
 sehr viele Ungenauigkeiten.
 Zudem waren Knicke in den Linien sichtbar über die Diagonale.
 
\end_layout

\begin_layout Standard
Eine Mittelung der Ergebnisse aller vier Dreiecke hat jedoch geholfen, die
 Knicke zu eliminieren und die vertikalen Fehlerfaktoren zu eliminieren.
 Dafür haben wir damit Probleme an den Rändern, da dort unrealistische Werte
 entstehen.
 
\end_layout

\begin_layout Standard
Tabelle.
 
\end_layout

\begin_layout Standard
Die horizontale Verschiebung ist je nach Versuchsaufbau ähnlich zum linearen
 Ansatz.
 Mir mehr Referenzpunkten lässt sich dieses Problem aber sicher lösen.
 
\end_layout

\begin_layout Paragraph
Kompensation der Verzerrung
\end_layout

\begin_layout Standard
Wenn nur drei oder vier Referenzpunkte für eine Interpolation verwendet
 werden, ist das Resultat in der aufgespannten Fläche korrekt und sollte
 keine Störungen beinhalten.
 Wenn mit diesem Verfahren jedoch eine Linie über mehrere Dreiecke gezogen
 wird, hat diese an jedem Übergang eine neue Richtung.
 
\end_layout

\begin_layout Standard
Bild.
 
\end_layout

\begin_layout Standard
Das wird von einem Nutzer dadurch wahrgenommen, dass seine gezogene Linie
 nicht gerade ist, sondern Knicke enthält.
 Das wird als störend empfunden.
 
\end_layout

\begin_layout Paragraph
Lösung
\end_layout

\begin_layout Standard
Es wird nicht nur das Resultat eines Vierecks analysiert, sondern direkte
 Nachbarn werden ebenfalls berücksichtigt.
 Durch eine entsprechende Gewichtung sollte das Resultat nicht verfälscht
 werden, aber die Knicke soweit geglättet werden, dass sie den Nutzer nicht
 mehr auffallen.
 Da Baryzentrische Koordinaten leider keine Abstandsfunktion definieren,
 gewichten wir Resultate, die innerhalb liegen doppelt, solche in der Nähe(siehe
 Oben) einfach.
 Anschliessend werden die Werte linear gemittelt.
 So können wir dennoch eine leichte Gewichtung einfügen.
 Erkenntnisse: Interpolation anhand der Eckpunkte: Hierbei ist die Genauigkeit
 identisch mit dem linearen Ansatz, wenn man die vier möglichen Dreiecke
 berücksichtigt und entsprechend gewichtet.
 
\end_layout

\begin_layout Paragraph
Interpolation anhand eines feineren Gitters
\end_layout

\begin_layout Standard
Die Anzahl berücksichtigter Dreiecke ist hier sehr wichtig.
 
\end_layout

\begin_layout Standard
Bilder 
\end_layout

\begin_layout Standard
Gewisse Ungenauigkeiten können jedoch nicht eliminiert werden.
 
\end_layout

\begin_layout Paragraph
Ausblick: Interpolation anhand Vierecken 
\end_layout

\begin_layout Standard
Durch eine bestimmte Erweiterung der Baryzentrischen Koordinaten auf Vierecke,
 welche den Fakt berücksichtigen, dass die Vierecke nicht winkeltreu sind,
 können wir zudem die Verzerrung an den Übergängen korrigieren.
 
\end_layout

\begin_layout Standard
Formel 
\end_layout

\begin_layout Standard
Durch eine entsprechende Gewichtung kann man zu dem die Knicke so interpolieren,
 dass Knicke an den Kanten geglättet werden.
 Das ist gegeben durch die Möglichkeit, dass wir auch Punkte ausserhalb
 des Rechtecks bestimmen können.
 Diese korrigieren jedoch die perspektivische Verzerrung nicht.
 Diesen Faktor können jedoch mit einem feineren Raster kompensieren.
 
\end_layout

\begin_layout Section
Input-Emulation
\end_layout

\begin_layout Standard
Gemäss Aufgabenstellung war in unserem Fall lediglich eine PowerPoint-Integratio
n gefordert.
 Wir haben uns jedoch überlegt, dass wir mit einer Mausemulation weit mehr
 machen könnten.
 Ausserdem kann man auch PowerPoint mit einer emulierten Maus gut bedienen.
 Zudem haben wir schon Erfahrungen gesammelt, wie man mit C# Mausbefehle
 auf Driver-Level injizieren kann.
 Diesen Weg benutzten ebenfalls Devices anderer Hersteller, wie z.B.
 Logitec Presenter.
 Diese emulieren jedoch eine Tastatur, was für uns nicht sinnvoll, aber
 optional auch möglich ist.
 Unter Windows 8 ist es zudem möglich, Touch-Events zu generieren.
 Damit müssten wir uns nicht mehr um die Analyse der Gesten kümmern, da
 uns das vom Betriebssystem abgenommen wird.
 Da wir jedoch auch ältere Systeme unterstützen wollen, haben wir einen
 Teil der Windows 8 Touch-funktionalität nachgebildet, die wir mit Mausbefehlen
 nachbauen.
 Dies ist z.B.
 ein Rechtsklick durch warten an einem Ort.
 
\end_layout

\end_body
\end_document
